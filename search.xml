<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[http协议与httpd]]></title>
    <url>%2F2018%2F10%2F17%2Fhttp%E5%8D%8F%E8%AE%AE%E4%B8%8Ehttpd%2F</url>
    <content type="text"><![CDATA[http协议与httpdSocket套接字&hearts; 跨网络的主机间通讯 在建立通信连接的每一端，进程间的传输要有两个标志 IP地址和端口号，合称为套接字地址 socket address 客户机套接字地址定义了一个唯一的客户进程 服务器套接字地址定义了一个唯一的服务器进程&diams; 示图 &hearts; Socket套接字介绍 Socket:套接字，进程间通信IPC的一种实现，允许位于不同主机（或同一主机）上不同进程之间进行通信和数据交换，SocketAPI出现于1983年，4.2 BSD实现 Socket API：封装了内核中所提供的socket通信相关的系统调用 Socket Domain：根据其所使用的地址&diams; AF_INET：Address Family，IPv4&diams; AF_INET6：IPv6&diams; AF_UNIX：同一主机上不同进程之间通信时使用 Socket Type：根据使用的传输层协议&diams; SOCK_STREAM：流，tcp套接字，可靠地传递、面向连接&diams; SOCK_DGRAM：数据报，udp套接字，不可靠地传递、无连接&diams; SOCK_RAW: 裸套接字,无须tcp或udp,APP直接通过IP包通信 套接字相关的系统调用&diams; socket(): 创建一个套接字&diams; bind()： 绑定IP和端口&diams; listen()： 监听&diams; accept()： 接收请求&diams; connect()： 请求连接建立&diams; write()： 发送&diams; read()： 接收&diams; close(): 关闭连接 基于TCP客户/服务器程序的套接字函数&diams; 示图1&diams; 示图2 http协议协议介绍&hearts; http协议介绍及术语 超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议,80/tcp http/0.9：1991，原型版本，功能简陋，只有一个命令GET。GET/index.html ,服务器只能回应HTML格式字符串，不能回应别的格式 http/1.0: 1996年5月,支持cache, MIME, method&diams; 每个TCP连接只能发送一个请求，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接&diams; 引入了POST命令和HEAD命令&diams; 头信息是 ASCII 码，后面数据可为任何格式。服务器回应时会告诉客户端，数据是什么格式，即Content-Type字段的作用。这些数据类型总称为MIME 多用途互联网邮件扩展，每个值包括一级类型和二级类型，预定义的类型，也可自定义类型, 常见Content-Type值：text/xml image/jpeg audio/mp3 http/1.1：1997年1月&diams; 引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。对于同一个域名，大多数浏览器允许同时建立6个持久连接&diams; 引入了管道机制（pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率&diams; 新增方法：PUT、PATCH、OPTIONS、DELETE&diams; 同一个TCP连接里，所有的数据通信是按次序进行的。服务器只能顺序处理回应，前面的回应慢，会有许多请求排队，造成”队头堵塞”（Head-of-lineblocking）&diams; 为避免上述问题，两种方法：一是减少请求数，二是同时多开持久连接。网页优化技巧，如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domainsharding）等&diams; HTTP 协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度 Spdy：2009年,谷歌研发,解决 HTTP/1.1 效率不高问题 http/2.0：2015年&diams; 头信息和数据体都是二进制，称为头信息帧和数据帧&diams; 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了“队头堵塞“,此双向的实时通信称为多工（Multiplexing）&diams; 引入头信息压缩机制（header compression）,头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度&diams; HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送（serverpush） Http相关术语&hearts; http相关术语 html: Hyper Text Markup Language 超文本标记语言，编程语言&diams; 用html语言编写的文本及超文本 CSS: Cascading Style Sheet 层叠样式表&diams; 层叠样式表（英语：Cascading Style Sheets，简写CSS），又称串样式列表、级联样式表、串接样式表、阶层式样式表，一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言，由W3C定义和维护。 js: javascript&diams; JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 MIME MIME： Multipurpose Internet Mail Extensions多用途互联网邮件扩展 /etc/mime.types 格式：major/minor&diams; text/plain&diams; text/html&diams; text/css&diams; image/jpeg&diams; image/png&diams; video/mp4&diams; application/javascript&diams; 参考：http://www.w3school.com.cn/media/media_mimeref.asp MIME类型&diams; Web服务器要负责确定响应主体的MIME类型。多种配置服务器的方法可将MIME类型与资源管理起来 &diams; 魔法分类：Apache web服务器可以扫描每个资源的内容，并将其与一个已知模式表(被称为魔法文件)进行匹配，以决定每个文件的MIME类型。这样做可能比较慢，但很方便，尤其是文件没有标准扩展名时 &diams; 显式分类：可以对Web服务器进行配置，使其不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型 &diams; 类型协商： 有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，可以配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式(及相关的MIME类型)”最好” URI URI: Uniform Resource Identifier 统一资源标识，分为URL和URN 两者区别：URN如同一个人的名称，而URL代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。URN仅用于命名，而不指定地址 URN URN: Uniform Resource Naming，统一资源命名 示例： P2P下载使用的磁力链接是URN的一种实现&diams; xfanyinet:?xt=urn:btih:660557A6890EF888666 URL URL: Uniform Resorce Locator，统一资源定位符，用于描述某服务器某特定资源位置 &lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; &diams; scheme:方案，访问服务器以获取资源时要使用哪种协议 &diams; user:用户，某些方案访问资源时需要的用户名 &diams; password:密码，用户对应的密码，中间用：分隔 &diams; Host:主机，资源宿主服务器的主机名或IP地址 &diams; port:端口,资源宿主服务器正在监听的端口号，很多方案有默认端口号 &diams; path:路径,服务器资源的本地名，由一个/将其与前面的URL组件分隔 &diams; params:参数，指定输入的参数，参数为名/值对，多个参数，用;分隔 &diams; query:查询，传递参数给程序，如数据库，用？分隔,多个查询用&amp;分隔 &diams; frag:片段,一小片或一部分资源的名字，此组件在客户端使用，用#分隔 示例&diams; http://www.xfanyi.top/images/logo.jpg&diams; ftp://xfanyi:password@172.16.0.1/pub/linux.ppt&diams; rtsp://videoserver/video_demo/&diams; http://www.xfanyi.com/bbs/hello;gender=f/send;type=title&diams; http://apache.org/index.html#projects-list WEB资源 Web资源：web resource&diams; 一个网页由多个资源构成，打开一个页面，会有多个资源展示出来，但是每个资源都要单独请求。因此，一个“Web 页面”通常并不是单个资源，而是一组资源的集合 文件类型 &diams; 静态文件：无需服务端做出额外处理 &diams; 文件后缀：.html, .txt, .jpg, .js, .css, .mp3, .avi &diams; 动态文件：服务端执行程序，返回执行的结果 &diams; 文件后缀：.php, .jsp ,.as 网站访问量 IP(独立IP)：即Internet Protocol,指独立IP数。一天内来自相同客户机IP地址只计算一次，记录远程客户机IP地址的计算机访问网站的次数，是衡量网站流量的重要指标 PV(访问量)： 即Page View, 页面浏览量或点击量，用户每次刷新即被计算一次，PV反映的是浏览某网站的页面数，PV与来访者的数量成正比，PV并不是页面的来访者数量，而是网站被访问的页面数量 UV(独立访客)：即Unique Visitor,访问网站的一台电脑为一个访客。一天内相同的客户端只被计算一次。可以理解成访问某网站的电脑的数量。网站判断来访电脑的身份是通过来访电脑的cookies实现的。如果更换了IP后但不清除cookies，再访问相同网站，该网站的统计中UV数是不变的 网站统计：http://www.alexa.cn/rank/ QPS：request per second，每秒请求数&diams; PV，QPS,并发连接数换算公式QPS= PV* 页⾯衍⽣连接次数/ 统计时间（86400）并发连接数 =QPS * http平均响应时间 &diams; 峰值时间：每天80%的访问集中在20%的时间里，这20%时间为峰值时间 &diams; 峰值时间每秒请求数(QPS)=( 总PV数 *页⾯衍⽣连接次数）*80% ) / (每天秒数 * 20% ) 示例&diams; 甲乙丙三人在同一台通过ADSL上网的电脑上（中间没有断网），分别访问www.xfanyi.yi网站，并且每人各浏览了2个页面，那么网站的流量统计是：&diams; IP: 1 PV:6 UV：1 &diams; 若三人都是ADSL重新拨号后,各浏览了2个页面，则 &diams; IP: 3 PV:6 UV：1 http工作机制&hearts; http工作机制 工作机制&diams; http请求：http request&diams; http响应：http response&diams; 一次http事务：请求响应 提高HTTP连接性能方案&diams; 并行连接：通过多条TCP连接发起并发的HTTP请求&diams; 持久连接：keep-alive,长连接，重用TCP连接，以消除连接和关闭的时延,以事务个数和时间来决定是否关闭连接&diams; 管道化连接：通过共享TCP连接发起并发的HTTP请求&diams; 复用的连接：交替传送请求和响应报文（实验阶段）&diams; http连接请求 &diams; 串行和并行连接 &diams; 串行,持久连接和管道 一次完整http请求过程 建立连接：接收或拒绝连接请求 接收请求：接收客户端请求报文中对某资源的一次请求的过程 Web访问响应模型（Web I/O）&diams; 单进程I/O模型&diams; 启动一个进程处理用户请求，而且一次只处理一个，多个请求被串行响应 &diams; 多进程I/O模型&diams; 并行启动多个进程,每个进程响应一个连接请求 &diams; 复用I/O结构&diams; 启动一个进程，同时响应N个连接请求&diams; 多线程模型：一个进程生成N个线程，每线程响应一个连接请求&diams; 事件驱动：一个进程处理N个请求 &diams; 复用的多进程I/O模型&diams; 启动M个进程，每个进程响应N个连接请求，同时接收M*N个请求 处理请求：服务器对请求报文进行解析，并获取请求的资源及请求方法等相关信息，根据方法，资源，首部和可选的主体部分对请求进行处理 元数据：请求报文首部&diams; &lt;method&gt; &lt;URL&gt; &lt;VERSION&gt; 起始行&diams; HEADERS 格式 name:value 请求首部或响应首部&diams; &lt;request body&gt; 实体部分 示例&diams; Host: www.xfanyi.top 请求的主机名称&diams; Server: Apache/2.4.7 HTTP常用请求方式，Method&diams; GET、POST、HEAD、PUT、DELETE、TRACE、OPTIONS 访问资源 服务器获取请求报文中请求的资源web服务器，即存放了web资源的服务器，负责向请求者提供对方请求的静态资源，或动态运行后生成的资源&diams; 资源放置于本地文件系统特定的路径：DocRoot&diams; DocRoot /var/www/html&diams; /var/www/html/images/logo.jpg web服务器资源路径映射方式&diams; docroot&diams; alias&diams; 虚拟主机docroot&diams; 用户家目录docroot 构建响应报文 一旦Web服务器识别除了资源，就执行请求方法中描述的动作，并返回响应报文。响应报文中 包含有响应状态码、响应首部，如果生成了响应主体的话，还包括响应主体&diams; 响应实体：如果事务处理产生了响应主体，就将内容放在响应报文中回送过去。响应报文中通常包括&diams; 描述了响应主体MIME类型的Content-Type首部&diams; 描述了响应主体长度的Content-Length &diams; 实际报文的主体内容 &diams; URL重定向：web服务构建的响应并非客户端请求的资源，而是资源另外一个访问路径 &diams; 永久重定向：http://www.360buy.com &diams; 临时重定向：http://www.taobao.com 发送响应报文 Web服务器通过连接发送数据时也会面临与接收数据一样的问题。服务器可能有很多条到各个客户端的连接，有些是空闲的，有些在向服务器发送数据，还有一些在向客户端回送响应数据。服务器要记录连接的状态，还要特别注意对持久连接的处理。对非持久连接而言，服务器应该在发送了整条报文之后，关闭自己这一端的连接。对持久连接来说，连接可能仍保持打开状态，在这种情况下，服务器要正确地计算Content-Length首部，不然客户端就无法知道响应什么时候结束了 记录日志 最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务 http服务器应用服务器程序介绍&hearts; http服务器程序 httpd apache nginx lighttpd &hearts; 应用程序服务器 IIS .asp tomcat .jsp jetty 开源的servlet容器，基于Java的web容器 Resin CAUCHO公司，支持servlets和jsp的引擎 webshpere(IBM), weblogic(BEA), jboss,oc4j(Oracle) 市场占有率统计&diams; http://www.netcraft.com httpdhttpd介绍 20世纪90年代初，国家超级计算机应用中心NCSA开发1995年开源社区发布apache（a patchy server）&diams; ASF: apache software foundation&diams; FSF：Free Software Foundation httpd功能特性&diams; 高度模块化：core + modules&diams; DSO: Dynamic Shared Object 动态加/卸载&diams; MPM：multi-processing module多路处理模块&diams; 虚拟主机：IP、Port、FQDN&diams; CGI：Common Gateway Interface，通用网关接口&diams; 反向代理&diams; 负载均衡&diams; 路径别名&diams; 丰富的用户认证机制： basic、digest&diams; 支持第三方模块 httpd安装 版本&diams; CentOS 6: 2.2&diams; CentOS 7: 2.4 安装方式&diams; rpm：centos发行版，稳定，建议使用&diams; 编译：定制或特殊需求 CentOS 6程序环境：httpd-2.2 配置文件&diams; /etc/httpd/conf/httpd.conf&diams; /etc/httpd/conf.d/*.conf 检查配置语法&diams; httpd –t&diams; service httpd configtest 服务脚本&diams; /etc/rc.d/init.d/httpd&diams; 脚本配置文件：/etc/sysconfig/httpd 服务控制和启动&diams; chkconfig httpd on|off&diams; service {start|stop|restart|status|configtest|reload} httpd 站点网页文档根目录&diams; /var/www/html 模块文件路径&diams; /etc/httpd/modules&diams; /usr/lib64/httpd/modules 主程序文件&diams; /usr/sbin/httpd&diams; /usr/sbin/httpd.worker&diams; /usr/sbin/httpd.event 主进程文件&diams; /etc/httpd/run/httpd.pid 日志文件目录&diams; /var/log/httpd&diams; access_log: 访问日志&diams; error_log：错误日志 帮助文档包&diams; httpd-manual httpd配置文件的组成&diams; grep “Section” /etc/httpd/conf/httpd.conf&diams; Section 1: Global Environment&diams; Section 2: ‘Main’ server configuration&diams; Section 3: Virtual Hosts 配置格式：directive value&diams; directive: 不区分字符大小写&diams; value: 为路径时，是否区分大小写，取决于文件系统 查看模块列表&diams; 查看静态编译的模块&diams; httpd -l &diams; 查看静态编译及动态装载的模块 &diams; httpd –M &diams; 动态模块路径 &diams; /usr/lib64/httpd/modules/ httpd 2.2常见配置 显示服务器版本信息&diams; 示例ServerTokens Major|Minor|Min[imal]|Prod[uctOnly]|OS|FullServerTokens Prod[uctOnly] ：Server: ApacheServerTokens Major: Server: Apache/2ServerTokens Minor: Server: Apache/2.0ServerTokens Min[imal]: Server: Apache/2.0.41ServerTokens OS: Server: Apache/2.0.41 (Unix)ServerTokens Full (or not specified): Server: Apache/2.0.41 (Unix)PHP/4.2.2 MyMod/1.2This setting applies to the entire server and cannot be enabled ordisabled on a virtualhost-by-virtualhost basis.After version 2.0.44, this directive also controls the information presentedby the ServerSignature directive.建议使用：ServerTokens Prod 修改监听的IP和Port Listen [IP:]PORT&diams; 省略IP表示为本机所有IP&diams; Listen指令至少一个，可重复出现多次 示例&diams; Lsten 80&diams; Listen 192.168.1.100:8080 持久连接 Persistent Connection：连接建立，每个资源获取完成后不会断开连接，而是继续等待其它的请求完成，默认关闭持久连接 断开条件&diams; 数量限制：100&diams; 时间限制：以秒为单位， httpd-2.4 支持毫秒级&diams; 副作用：对并发访问量较大的服务器，持久连接会使有些请求得不到响应折衷：使用较短的持久连接时间 设置&diams; KeepAlive On|Off&diams; KeepAliveTimeout 15&diams; MaxKeepAliveRequests 100 测试&diams; telnet WEB_SERVER_IP PORT&diams; GET /URL HTTP/1.1&diams; Host: WEB_SERVER_IP MPM MPM（ Multi-Processing Module）多路处理模块prefork, worker, event（试验阶段） httpd-2.2不支持同时编译多个模块，所以只能编译时选定一个；rpm安装的包提供三个二进制程序文件，分别用于实现对不同MPM机制的支持 确认方法&diams; ps aux | grep httpd&diams; 默认为/usr/sbin/httpd, 即prefork模式 httpd 2.2更换使用的httpd程序&diams; vim /etc/sysconfig/httpd&diams; HTTPD=/usr/sbin/httpd.worker&diams; 重启服务生效&diams; pstree -p|grep httpd 查看进程和线程 httpd 2.4更换使用的httpd程序&diams; 以动态模块方式提供&diams; 配置文件：vim /etc/httpd/conf.modules.d/00-mpm.conf&diams; LoadModule mpm_prefork_module modules/mod_mpm_worker.so&diams; httpd –M |grep mpm&diams; 重启服务生效&diams; pstree -p|grep httpd 查看进程和线程 prefork的默认配置&diams; 示例 1234567891011121314&lt;IfModule prefork.c&gt;#默认开启的进程数StartServers 8#最少空闲进程数MinSpareServers 5#最大空闲进程数MaxSpareServers 20#最多进程数,最大20000ServerLimit 256#最大并发MaxClients 256#每个进程接收多少次请求、生命周期结束MaxRequestsPerChild 4000&lt;/IfModule&gt; worker的默认配置&diams; 示例 1234567891011121314&lt;IfModule worker.c&gt;#开启的进程数StartServers 4#最大并发MaxClients 300#最少空闲进程数MinSpareThreads 25#最大空闲进程数MaxSpareThreads 75#第个子进程、生成多少个线程ThreadsPerChild 25#每个进程接收多少次请求、生命周期结束 0 无限制MaxRequestsPerChild 0 &lt;/IfModule&gt; DSO DSO： Dynamic Shared Object&diams; 加载动态模块配置&diams; /etc/httpd/conf/httpd.conf&diams; 配置指定实现模块加载格式：&diams; LoadModule &lt;mod_name&gt; &lt;mod_path&gt;&diams; 模块文件路径可使用相对路径：&diams; 相对于ServerRoot（默认/etc/httpd）&diams; 示例LoadModule auth_basic_module modules/mod_auth_basic.so 定义’Main’ server的文档页面路径 DocumentRoot “/path”&diams; 文档路径映射&diams; DocumentRoot指向的路径为URL路径的起始位置&diams; 示例&diams; DocumentRoot &quot;/app/data“&diams; http://HOST:PORT/test/index.html --&gt; /app/data/test/index.html&diams; 注意：SELinux和iptables的状态 定义站点主页面 DirectoryIndex index.html index.html.var 站点访问控制常见机制 可基于两种机制指明对哪些资源进行何种访问控制访问控制机制有两种：客户端来源地址，用户账号 中“基于源地址”实现访问控制 Options：后跟1个或多个以空白字符分隔的选项列表在选项前的+，- 表示增加或删除指定选项&diams; 常见选项&diams; Indexes：指明的URL路径下不存在与定义的主页面资源相符的资源文件时，返回索引列表给用户 &diams; FollowSymLinks：允许访问符号链接文件所指向的源文件&diams; None：全部禁用&diams; All： 全部允许&diams; 示例 123&lt;Directory /web/docs&gt;Options Indexes FollowSymLinks&lt;/Directory&gt; AllowOverride&diams; 与访问控制相关的哪些指令可以放在指定目录下的.htaccess（由AccessFileName指定）文件中，覆盖之前的配置指令&diams; 只对&lt; directory &gt;语句有效&diams; AllowOverride All: .htaccess中所有指令都有效&diams; AllowOverride None： .htaccess 文件无效&diams; AllowOverride AuthConfig Indexes 除了AuthConfig 和Indexes的其它指令都无法覆盖 order和allow、deny&diams; 放在directory, .htaccess中&diams; order：定义生效次序；写在后面的表示默认法则&diams; Order allow,deny&diams; Order deny,allow&diams; Allow from和Deny from：定义客户端地址&diams; 客户端地址&diams; IP&diams; 网络: 172.16&diams; 示例 12345&lt;files "*.txt"&gt;order deny,allowdeny from 172.16. 100.100allow from 172.16&lt;/files&gt; 日志设定 日志类型&diams; 访问日志&diams; 错误日志 错误日志&diams; ErrorLog logs/error_log&diams; LogLevel warn&diams; LogLevel 可选值: debug, info, notice, warn,error, crit, alert, emerg 访问日志&diams; 定义日志格式： 123LogFormat format stringsLogFormat "%h %l %u %&#123;%Y-%m-%d %H:%M:%S&#125;t \"%r\" %&gt;s %b\"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\"" testlog 使用日志格式&diams; CustomLog logs/access_log testlog&diams; 参考帮助http://httpd.apache.org/docs/2.2/mod/mod_log_config.html#formats 日志参数&diams; %h 客户端IP地址&diams; %l 远程用户,启用mod_ident才有效，通常为减号“-”&diams; %u 验证（basic，digest）远程用户,非登录访问时，为一个减号“-”&diams; %t 服务器收到请求时的时间&diams; %r First line of request，即表示请求报文的首行；记录了此次请求的“方法”，“URL”以及协议版本&diams; %&gt;s 响应状态码&diams; %b 响应报文的大小，单位是字节；不包括响应报文http首部&diams; %{Referer}i 请求报文中首部“referer”的值；即从哪个页面中的超链接跳转至当前页面的&diams; %{User-Agent}i 请求报文中首部“User-Agent”的值；即发出请求的应用程序 设定默认字符集 AddDefaultCharset UTF-8 此为默认值&diams; 中文字符集：GBK, GB2312, GB18030 定义路径别名 格式：Alias /URL/ “/PATH/“&diams; 示例12Alias /download/ "/rpms/pub/"http://www.magedu.com/download/bash.rpm ==&gt;/rpms/pub/bash.rpm 基于用户的访问控制 认证质询：WWW-Authenticate：响应码为401，拒绝客户端请求，并说明要求客户端提供账号和密码 认证：Authorization：客户端用户填入账号和密码后再次发送请求报文；认证通过时，则服务器发送响应的资源 认证方式两种&diams; basic：明文 &diams; digest：消息摘要认证,兼容性差&diams; 安全域：需要用户认证后方能访问的路径；应该通过名称对其进行标识，以便于告知用户认证的原因&diams; 用户的账号和密码&diams; 虚拟账号：仅用于访问某服务时用到的认证标识&diams; 存储：文本文件，SQL数据库，ldap目录存储，nis等 basic认证配置示例&diams; 定义安全域 12345678&lt;Directory “/path"&gt;Options NoneAllowOverride NoneAuthType BasicAuthName "String“AuthUserFile "/PATH/HTTPD_USER_PASSWD_FILE"Require user username1 username2 ...&lt;/Directory&gt; &diams; 允许账号文件中的所有用户登录访问&diams; Require valid-user 提供账号和密码存储（文本文件）使用专用命令完成此类文件的创建及用户管理&diams; htpasswd [options] /PATH/HTTPD_PASSWD_FILE username&diams; -c 自动创建文件，仅应该在文件不存在时使用&diams; -p 明文密码&diams; -d CRYPT格式加密，默认&diams; -m md5格式加密&diams; -s sha格式加密&diams; -D 删除指定用户 基于组账号进行认证&diams; 定义安全域 1234567&lt;Directory “/path"&gt;AuthType BasicAuthName "String“AuthUserFile "/PATH/HTTPD_USER_PASSWD_FILE"AuthGroupFile "/PATH/HTTPD_GROUP_FILE"Require group grpname1 grpname2 ...&lt;/Directory&gt; &diams; 创建用户账号和组账号文件&diams; 组文件：每一行定义一个组&diams; GRP_NAME: username1 username2 …&diams; 示例 123456789&lt;Directory "/www/htdocs/admin"&gt;Options NoneAllowOverride NoneAuthType BasicAuthName "Administator private"AuthUserFile "/etc/httpd/conf.d/.htpasswd"AuthGroupFile "/etc/httpd/conf.d/.htgroup"Require group webadmins&lt;/Directory&gt; &diams; vim /etc/httpd/conf.d/.htgroup&diams; webadmins:xiong fang]]></content>
      <categories>
        <category>linuxweb</category>
      </categories>
      <tags>
        <tag>linuxweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS服务]]></title>
    <url>%2F2018%2F09%2F25%2FDNS%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[DNS服务和BINDDNS相关概念DNS介绍&hearts; DNS介绍 DNS域名系统是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。 DNS:Domain Name Service 应用层协议使用TCP和UDP端口53。 &hearts; DNS域名 DNS域名结构&diams; 示图 &hearts; DNS查询 DNS查询类型&diams; 递归查询 直接访回请求结果&diams; 迭代查询 不直接访问请求结果，而是访回下一级域名的IP 解析类型&diams; FQDN –&gt; IP&diams; IP –&gt; FQDN&diams; FQDN=主机名|别名 + 域名 www.xfanyi.top&raquo; www为主机名，xfanyi.top为域名,组合起来为FQDN &hearts; DNS服务器类型 DNS服务器的类型：&diams; 主DNS服务器&raquo; 管理和维护所负责解析的域内解析库的服务器&diams; 从DNS服务器&raquo; 从主服务器或从服务器“复制”（区域传输）解析库副本 序列号：解析库版本号，主服务器解析库变化时，其序列递增 刷新时间间隔：从服务器从主服务器请求同步解析的时间间隔 重试时间间隔：从服务器请求同步失败时，再次尝试时间间隔 过期时长：从服务器联系不到主服务器时，多久后停止服务&raquo; 通知”机制：主服务器解析库发生变化时，会主动通知从服务器&diams; 缓存DNS服务器（转发器） &hearts; DNS解析 一次完整的查询请求经过的流程：&diams; Client –&gt;hosts文件 –&gt;DNS Service Local Cache –&gt; DNS Server (recursion) –&gt; Server Cache –&gt; iteration(迭代) –&gt; 根–&gt; 顶级域名DNS–&gt;二级域名DNS… 解析答案：&diams; 肯定答案：&diams; 否定答案：请求的条目不存在等原因导致无法返回结果&diams; 权威答案：&diams; 非权威答案： &hearts; 资源记录 区域解析库：由众多RR组成：&diams; 资源记录：Resource Record, RR&diams; 记录类型：A, AAAA, PTR, SOA, NS, CNAME, MX&diams; A：internet Address，作用，FQDN –&gt; IP&diams; AAAA: FQDN –&gt; IPv6&diams; PTR: PoinTeR，IP –&gt; FQDN&diams; NS: Name Server，专用于标明当前区域的DNS服务器&diams; CNAME：Canonical Name，别名记录&diams; MX: Mail eXchanger，邮件交换器 SOA记录&hearts; SOA记录 SOA：Start Of Authority，起始授权记录；一个区域解析库有且仅能有一个SOA记录，必须位于解析库的第一条记录 &hearts; 资源记录定义的格式： 语法：name [TTL] IN rr_type value&diams; name: 当前区域的名字，例如“xfanyi.top.”&diams; value: 有多部分组成&raquo; 当前区域的主DNS服务器的FQDN，也可以使用当前区域的名字；&raquo; 当前区域管理员的邮箱地址；但地址中不能使用@符号，一般用.替换&raquo; 例如：admin.xfanyi.com&raquo; 主从服务区域传输相关定义以及否定的答案的统一的TTL&raquo; 示例 12345678xfanyi.top. 86400 IN SOA ns.xfanyi.top. nsadmin.xfanyi.top. ( 2015042201 ;序列号 2H ;刷新时间 10M ;重试时间 1W ;过期时间 1D ;否定答案的TTL值 ) &diams; 注意&raquo; TTL可从全局继承&raquo; @可用于引用当前区域的名字&raquo; 同一个名字可以通过多条记录定义多个不同的值；此时DNS服务器会以轮询方式响应&raquo; 同一个值也可能有多个不同的定义名字；通过多个不同的名字指向同一个值进行定义；此仅表示通过多个不同的名字可以找到同一个主机 NS记录&hearts; NS记录 name: 当前区域的名字 value: 当前区域的某DNS服务器的名字，例如ns.xfanyi.top. 注意：一个区域可以有多个NS记录&diams; 示例12xfanyi.top. IN NS ns1.xfanyi.top. xfanyi.top. IN NS ns2.xfanyi.top. &diams; 注意&raquo; 相邻的两个资源记录的name相同时，后续的可省略&raquo; 对NS记录而言，任何一个ns记录后面的服务器名字，都应该在后续有一个A记录 MX记录&hearts; MX记录 name: 当前区域的名字 value: 当前区域的某邮件服务器(smtp服务器)的主机名 一个区域内，MX记录可有多个；但每个记录的value之前应该有一个数字(0-99)，表示此服务器的优先级；数字越小优先级越高&diams; 示例： 12xfanyi.top. IN MX 10 mx1.xfanyi.top. IN MX 20 mx2.xfanyi.top. &diams; 注意：对MX记录而言，任何一个MX记录后面的服务器名字，都应该在后续有一个A记录 A记录&hearts; A记录 name: 某主机的FQDN，例如www.xfanyi.top. value: 主机名对应主机的IP地址&diams; 示例： 1234567www.xfanyi.top. IN A 1.1.1.1 www.xfanyi.top. IN A 2.2.2.2 mx1.xfanyi.top. IN A 3.3.3.3 mx2.xfanyi.top. IN A 4.4.4.4 $GENERATE 1-254 HOST$ A 1.2.3.$ *.xfanyi.top. IN A 5.5.5.5 xfanyi.top. IN A 6.6.6.6 &diams; 避免用户写错名称时给错误答案，可通过泛域名解析进行解析至某特定地址 别名记录&hearts; 别名记录 CNAME：&diams; name: 别名的FQDN&diams; value: 真正名字的FQDN&diams; 示例1www.xfanyi.top. IN CNAME websrv.xfanyi.top. PTR:记录&hearts; PTR: name:IP，有特定格式，把IP地址反过来写，1.2.3.4，要写作4.3.2.1；而有特定后缀：in-addr.arpa.，所以完整写法为：4.3.2.1.in-addr.arpa.&diams; value: FQDN&diams; 示例 14.3.2.1.in-addr.arpa. IN PTR www.xfanyi.top. &diams; 注意：网络地址及后缀可省略；主机地址依然需要反着写 子域&hearts; 子域 子域授权：每个域的名称服务器，都是通过其上级名称服务器在解析库进行授权 类似根域授权tld：&diams; 示例 1234.top. IN NS ns1.top. .top. IN NS ns2.top. ns1.top. IN A 2.2.2.1 ns2.top. IN A 2.2.2.2 xfanyi.top. 在.top的名称服务器上，解析库中添加资源记录&diams; 示例 123456xfanyi.top. IN NS ns1.xfanyi.top. xfanyi.top. IN NS ns2.xfanyi.top. xfanyi.top. IN NS ns3.xfanyi.top. ns1.xfanyi.top. IN A 3.3.3.1 ns2.xfanyi.top. IN A 3.3.3.2 ns3.xfanyi.top. IN A 3.3.3.3 glue record：粘合记录，父域授权子域的记录 互联网域名&hearts; 互联网域名 域名注册：&diams; 代理商：万网, 新网, godaddy 注册完成以后，想自己用专用服务来解析&diams; 管理后台：把NS记录指向的服务器名称，和A记录指向的服务器地址 DNS实现BIND安装配置BIND介绍&hearts; BIND介绍 BIND（Berkeley Internet NameDomain）是现今互联网上最常使用的DNS服务器软件，使用BIND作为服务器软件的DNS服务器约占所有DNS服务器的九成。BIND现在由互联网系统协会（Internet Systems Consortium）负责开发与维护。 BIND包组成&hearts; BIND包组成 dns服务程序包:bind，unbound&diams; 程序名：named，unbound&diams; 程序包：yum list all bind*&raquo; bind：服务器&raquo; bind-libs：相关库&raquo; bind-utils:客户端&raquo; bind-chroot: /var/named/chroot/ BIND相关配置文件&hearts; BIND配置文件 服务脚本和名称：/etc/rc.d/init.d/named /usr/lib/systemd/system/named.service 主配置文件：/etc/named.conf, /etc/named.rfc1912.zones, /etc/rndc.key 解析库文件：/var/named/ZONE_NAME.ZONE&diams; 注意&raquo; 一台物理服务器可同时为多个区域提供解析&raquo; 必须要有根区域文件；named.ca&raquo; 应该有两个（如果包括ipv6的，应该更多）实现localhost和本地回环地址的解析库 rndc: remote name domain controller，&diams; 默认与bind安装在同一主机，且只能通过127.0.0.1连接named进程 提供辅助性的管理功能；953/tcp 主配置文件&diams; 全局配置：options {};&diams; 日志子系统配置：logging {};&diams; 区域定义：本机能够为哪些zone进行解析，就要定义哪些zone zone “ZONE_NAME” IN {};&diams; 注意&raquo; 任何服务程序如果期望其能够通过网络被其它主机访问，至少应该监听在一个能与外部主机通信的IP地址上&diams; 缓存名称服务器的配置：&raquo; 监听外部地址即可&raquo; dnssec: 建议关闭dnssec，设为no &hearts; BIND相关命令 rndc: remote name domain controller&diams; 默认与bind安装在同一主机，且只能通过127.0.0.1连接named进程提供辅助性的管理功能；953/tcp&diams; rndc COMMAND&raquo; reload: 重载主配置文件和区域解析库文件&raquo; reload zonename: 重载区域解析库文件&raquo; retransfer zonename: 手动启动区域传送，而不管序列号是否增加&raquo; notify zonename: 重新对区域传送发通知&raquo; reconfig: 重载主配置文件&raquo; querylog: 开启或关闭查询日志文件/var/log/message&raquo; trace: 递增debug一个级别&raquo; trace LEVEL: 指定使用的级别&raquo; notrace：将调试级别设置为 0&raquo; flush：清空DNS服务器的所有缓存记录 主DNS配置&hearts; 主DNS相关配置 在主配置文件中定义区域 1234zone "ZONE_NAME" IN &#123; type &#123;master|slave|hint|forward&#125;; file "ZONE_NAME.zone"; &#125;; 定义区域解析库文件&diams; 出现的内容&diams; 宏定义&diams; 资源记录 主配置文件语法检查：&diams; named-checkconf 解析库文件语法检查：&diams; named-checkzone “xfanyi.top” /var/named/xfanyi.top.zone rndc status|reload ;service named reload 主区域&hearts; 主区域示例 示例123456789101112131415161718192021222324252627$TTL 86400 #缓存时间$ORIGIN xfanyi.top. @ IN SOA ns1.xfanyi.top. admin.xfanyi.top ( 2015042201 1H 5M 7D 1D ) IN NS ns1 IN NS ns2 IN MX 10 mx1 IN MX 20 mx2 ns1 IN A 172.16.100.11 ns2 IN A 172.16.100.12 mx1 IN A 172.16.100.13 mx2 IN A 172.16.100.14 websrv IN A 172.16.100.11 websrv IN A 172.16.100.12 www IN CNAME websrv #valuse: #1：主DNS名称： ns1.xfanyi.top.#2：管理员邮箱： admin.xfanyi.top#3：数据库版本号：11#4：主从同步间隔：1h 1D#5：主从同步重试间隔 10M#6：从数据库过期时长#7：不存在记录的缓存时长 反向区域&hearts; 反区域示例 示例123456789101112131415$TTL 86400 $ORIGIN 100.16.172.in-addr.arpa. @ IN SOA ns1.xfanyi.top. admin.xfanyi.top. ( 2015042201 1H 5M 7D 1D ) IN NS ns1.xfanyi.top. IN NS ns2.xfanyi.top. 11 IN PTR ns1.xfanyi.top. 11 IN PTR www.xfanyi.top. 12 IN PTR mx1.xfanyi.top. 12 IN PTR www.xfanyi.top. 13 IN PTR mx2.xfanyi.top. 子域&hearts; 子域 子域授权：分布式数据库 正向解析区域子域方法 定义一个子区域：&diams; 示例 12345678ops.xfanyi.top. IN NS ns1.ops.xfanyi.top. ops.xfanyi.top. IN NS ns2.ops.xfanyi.top. ns1.ops.xfanyi.top. IN A 1.1.1.1 ns2.ops.xfanyi.top. IN A 1.1.1.2 fin.xfanyi.top. IN NS ns1.fin.xfanyi.top. fin.xfanyi.top. IN NS ns2.fin.xfanyi.top. ns1.fin.xfanyi.top. IN A 3.1.1.1 ns2.fin.xfanyi.top. IN A 3.1.1.2 &diams; 注意：关闭dnssec功能： &raquo; dnssec-enable no; &raquo; dnssec-validation no; 允许动态更新&hearts; 动态更新 指定的zone语句块中：Allow-update {any;}; chmod 770 /var/named setsebool -P named_write_master_zones on nsupdate&diams; &gt;server 127.0.0.1&diams; &gt;zone xfanyi.com&diams; &gt;update add ftp.xfanyi.com 88888 IN A 8.8.8.8&diams; &gt;send&diams; &gt;update delete www.xfanyi.com A&diams; &gt;send 测试：dig ftp.xfanyi.com @127.0.0.1&diams; ll /var/named/xfanyi.top.zone.jnl&diams; cat /var/named/xfanyi.top.zone 从DNS配置&hearts; 从服务器 应该为一台独立的名称服务器 主服务器的区域解析库文件中必须有一条NS记录指向从服务器 从服务器只需要定义区域，而无须提供解析库文件；解析库文件应该放置于/var/named/slaves/目录中 主服务器得允许从服务器作区域传送 主从服务器时间应该同步，可通过ntp进行； bind程序的版本应该保持一致；否则，应该从高，主低定义从区域的方法：&diams; 示例 12345678910111213141516 zone "ZONE_NAME" IN &#123; type slave; masters &#123; MASTER_IP; &#125;; file "slaves/ZONE_NAME.zone"; &#125;``` ##### 转发服务器 &amp;hearts; 转发服务器* 全局转发: 对非本机所负责解析区域的请求，全转发给指定的服务器 &amp;diams; 示例```bash Options &#123; forward first|only; forwarders &#123; ip;&#125;; &#125;; 特定区域转发：仅转发对特定的区域的请求，比全局转发优先级高&diams; 示例 12345zone "ZONE_NAME" IN &#123; type forward; forward first|only; forwarders &#123; ip;&#125;; &#125;; &diams; 注意：关闭dnssec功能： &raquo; dnssec-enable no; &raquo; dnssec-validation no; ACL&hearts; bind中ACL bind有四个内置的acl:&diams; none: 没有一个主机&diams; any: 任意主机&diams; localhost: 本机&diams; localnet: 本机的IP同掩码运算后得到的网络地址&raquo; 注意：只能先定义，后使用；因此一般定义在配置文件中，处于options的前面 bind中基础的安全相关的配置：&diams; acl: 把一个或多个地址归并为一个集合，并通过一个统一的名称调用&diams; 格式 12345acl acl_name &#123; ip; net/prelen; …… &#125;; &diams; 示例 1234acl mynet &#123; 172.16.0.0/16; 10.10.10.10; &#125;; 访问控制的指令&diams; allow-query {}： 允许查询的主机；白名单&diams; allow-transfer {}：允许区域传送的主机；白名单&diams; allow-recursion {}: 允许递归的主机,建议全局使用&diams; allow-update {}: 允许更新区域数据库中的内容 主从DNS实现主服务配置&hearts; 拓扑图 &hearts; centos6上bind实现 安装bind&diams; 示例 1yum -y insall bind 修改配置文件&diams; 示例 12345678910vim /etc/named.conf#修改下面两项，也可以选择直接注释#服务器监听端口的IPlisten-on port 53 &#123; localhost; &#125;;#允许查询的用户allow-query &#123; any; &#125;;#只允许指定服务器复制 安全设置allow-transfer &#123;192.168.11.98;&#125;;# 主配置文件语法检查named-checkconf 定义域&diams; 示例 12345678vim /etc/named.rfc1912.zones#在文件最后，增加自己域的相关内容zone "xfanyi.top" &#123;# 服务器属性，master为主服务，从服务器为slave type master;# 服务器对应数据解析库存放的位置，为文本文件 file "xfanyi.top.zone"; &#125;; 修改定义域配置&diams; 示例 1234567891011121314151617$TTL 1D@ IN SOA dns1.xfanyi.top. admin.xfanyi.top. ( 2018092528 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum@ NS dns1@ NS dns2dns1 A 192.168.11.97dns2 A 192.168.11.98web1 A 192.168.11.99www CNAME web1* CNAME web1@ MX 10 mailmail A 192.168.11.99 从服务器配置 修改配置文件&diams; 示例 123456789101112131415vim /etc/named.confvim /etc/named.conf// listen-on port 53 &#123; 127.0.0.1; &#125;;// allow-query &#123; localhost; &#125;;#从服务不允许其它主机拉取数据allow-transfer &#123;none;&#125;;#从服务器配置文件cat /etc/named.rfc1912.zones zone "xfanyi.top" &#123; type slave; masters &#123; 192.168.11.97;&#125;; file "slaves/xfanyi.top.zone";&#125;;#检测语法named-checkzone “xfanyi.top” /var/named/xfanyi.top.zone 测试&diams; 断开主服务，客户端测试是否能解析 相关测试命令&hearts; 相关测试命令介绍 dig [-t type] name [@SERVER] [query options]&diams; dig只用于测试dns系统，不会查询hosts文件进行解析&diams; 查询选项&raquo; +[no]trace：跟踪解析过程 : dig +trace xfanyi.com&raquo; +[no]recurse：进行递归解析&diams; 测试反向解析：&raquo; dig -x IP = dig –t ptr reverseip.in-addr.arpa&diams; 模拟区域传送：&raquo; dig -t axfr ZONE_NAME @SERVER&raquo; dig -t axfr xfanyi.com @10.10.10.11&raquo; dig –t axfr 100.1.10.in-addr.arpa @172.16.1.1&raquo; dig -t NS . @a.root-servers.net host [-t type] name [SERVER]&diams; host –t NS xfanyiu.com 172.16.0.1&diams; host –t soa xfanyiu.com&diams; host –t mx xfanyiu.com&diams; host –t axfr xfanyiu.com&diams; host 1.2.3.4 nslookup命令： nslookup [-option] [name | -] [server]&diams; 交互式模式：&raquo; server IP: 指明使用哪个DNS server进行查询&raquo; set q=RR_TYPE: 指明查询的资源记录类型&raquo; NAME: 要查询的名称 互联网DNS实现 (局域网模拟)&hearts; 拓扑图 配置主从DNS、步骤如上 配置二级域服务器及 .top.&diams; 示图 123456789101112131415161718192021vim /etc/named.conf// listen-on port 53 &#123; 127.0.0.1; &#125;;// allow-query &#123; localhost; &#125;;cat /etc/named.rfc1912.zones zone "top" &#123; type master; file "top.zone";&#125;;cat /var/named/com.zone $TTL 1D@ IN SOA dnsserver admin ( 1 1D 1H 1W 3H ) NS dnsserverxfanyi NS dnsserver2xfanyi NS dnsserver3dnsserver A 192.168.11.101dnsserver2 A 192.168.11.102dnsserver3 A 192.168.11.103dig www.xfanyi.top @192.168.11.101 正常则下一步 配置根DNS&diams; 示图 1234567891011121314151617181920212223vim /etc/named.conf// listen-on port 53 &#123; 127.0.0.1; &#125;;// allow-query &#123; localhost; &#125;;#zone "." IN &#123;# type hint;# file "named.ca";#&#125;;cat /etc/named.rfc1912.zoneszone "." &#123; type master; file "root.zone";&#125;;cat /var/named/root.zone$TTL 1D@ IN SOA dnsserver admin ( 1 1D 1H 1W 3H ) NS dnsservertop NS dnsserver2dnsserver A 192.168.11.100dnsserver2 A 192.168.11.101dig www.xfanyi.top @192.168.11.100 正常则下一步 配置运营商DNS&diams; 示图 12345678910vim /etc/named.conf// listen-on port 53 &#123; 127.0.0.1; &#125;;// allow-query &#123; localhost; &#125;;dnssec-enable no;dnssec-validation no;#把不需要根都注释掉cat /var/named/named.ca . 518400 IN NS a.root-servers.net.a.root-servers.net. 3600000 IN A 192.168.11.100 客户端DNS指向运营商IP、测试 总结&hearts; 实验前，关闭selinux,iptables,每一级，用dig命令测试正常之后在下一步。]]></content>
      <categories>
        <category>linuxapp</category>
      </categories>
      <tags>
        <tag>linuxapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix]]></title>
    <url>%2F2018%2F09%2F25%2Fzabbix%2F</url>
    <content type="text"></content>
      <categories>
        <category>monitor</category>
      </categories>
      <tags>
        <tag>monitor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系型数据库之mysql]]></title>
    <url>%2F2018%2F09%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[数据库管理系统数据库发展史及相关对比&hearts; 数据库发展史 萌芽阶段：文件系统&diams; 使用磁盘文件来存储数据 初级阶段：第一代数据库&diams; 出现了网状模型、层次模型的数据库 中级阶段：第二代数据库&diams; 关系型数据库和结构化查询语言 高级阶段：新一代数据库&diams; “关系-对象”型数据库 &hearts; 文件管理系统的缺点 编写应用程序不方便 数据冗余不可避免 应用程序依赖性 不支持对文件的并发访问 数据间联系弱 难以按用户视图表示数据 无安全控制功能 &hearts; 数据库管理系统的优点 相互关联的数据的集合 较少的数据冗余 程序与数据相互独立 保证数据的安全、可靠 最大限度地保证数据的正确性 数据可以并发使用并能同时保证一致性 数据库管理系统数据库管理系统介绍&hearts; 数据库管理系统介绍 数据库是数据的汇集，它以一定的组织形式存于存储介质上 DBMS是管理数据库的系统软件，它实现数据库系统的各种功能。是数据库系统的核心 相关概念&diams; DBA：负责数据库的规划、设计、协调、维护和管理等工作&diams; 应用程序指以数据库为基础的应用程序 &hearts; 数据库管理系统基本功能 数据定义 数据处理 数据安全 数据备份 数据库管理系统分类网状数据库&hearts; 网状数据库 最早出现的是网状DBMS，1964年通用电气公司的Charles Bachman成功地开发出世界上第一个网状IDS，也是第一个数据库管理系统，IDS 具有数据模式和日志的特征，只能在GE主机运行 层次数据库&hearts; 层次数据库 以树型结构表示实体及其之间的联系。关系只支持一对多，代理数据库IMB IMS。 关系型数据库介绍&hearts; 关系型数据库介绍 关系 ：关系就是二维表。并满足如下性质：ssss&diams; 表中的行、列次序并不重要 行row：表中的每一行，又称为一条记录 列column：表中的每一列，称为属性，字段 主键（Primary key）：用于惟一确定一个记录的字段 域domain：属性的取值范围，如，性别只能是‘男’和‘女’两个值 产品&hearts; 常见关系型数据库管理系统产品 MySQL: MySQL, MariaDB, Percona Server&diams; MySQL是一个开放源代码的关系数据库管理系统，原开发者为瑞典的MySQL AB公司，该公司于2008年被昇阳微系统（Sun Microsystems）收购。2009年，甲骨文公司（Oracle）收购昇阳微系统公司，MySQL成为Oracle旗下产品。&diams; MySQL 默认端口号为：3306/tcp PostgreSQL: 简称为pgsql，EnterpriseDB&diams; PostgreSQL是自由的对象-关系型数据库服务器（数据库管理系统），在灵活的BSD风格许可证下发行。它在其他开放源代码数据库系统（比如MySQL和Firebird），和专有系统（比如Oracle、Sybase、IBM的DB2和Microsoft SQL Server）之外，为用户又提供了一种选择。&diams; PostgreSQL默认端口号为：5423/tcp Oracle&diams; Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。&diams; oracle 默认端口号为：1521/tcp MSSQL&diams; MSSQL是指微软的SQLServer数据库服务器，它是一个数据库平台，提供数据库的从服务器到终端的完整的解决方案，其中数据库服务器部分，是一个数据库管理系统，用于建立、使用和维护数据库。&diams; mssql的默认端口是:1433/tcp DB2&diams; IBM DB2企业服务器版本，是美国IBM公司发展的一套关系型数据库管理系统。它主要的运行环境为UNIX（包括IBM自家的AIX）、Linux、IBM i（旧称OS/400）、Z/OS，以及Windows服务器版本。&diams; DB2监听的端口为：50000/tcp 相关排名&diams; https://db-engines.com/en/ranking 相关概念&hearts; 相关概念 数据模型&diams; 数据抽象：&raquo; 物理层：数据存储格式，即RDBMS在磁盘上如何组织文件&raquo; 逻辑层：DBA角度，描述存储什么数据，以及数据间存在什么样的关系&raquo; 视图层：用户角度，描述DB中的部分数据 &diams; 关系模型的分类： &raquo; 关系模型 &raquo; 基于对象的关系模型 &raquo; 半结构化的关系模型：XML数据 实体-联系模型E-R&diams; 实体Entity：客观存在并可以相互区分的客观事物或抽象事件称为实体&raquo; 在E-R图中用矩形框表示实体，把实体名写在框内&diams; 属性：实体所具有的特征或性质&diams; 联系：联系是数据之间的关联集合，是客观存在的应用语义链&raquo; 实体内部的联系：指组成实体的各属性之间的联系。如职工实体中，职工号和部门经理号之间有一种关联关系&raquo; 实体之间的联系：指不同实体之间联系。例：学生选课实体和学生基本信息实体之间&raquo; 实体之间的联系用菱形框表示 联系类型&diams; 一对一联系(1:1)&diams; 一对多联系(1:n)&diams; 多对多联系(m:n) 数据的操作：&diams; 数据提取：在数据集合中提取感兴趣的内容。SELECT&diams; 数据更新：变更数据库中的数据。INSERT、DELETE、UPDATE 约束&diams; 约束：constraint，表中的数据要遵守的限制&raquo; 主键：一个或多个字段的组合，填入的数据必须能在本表中唯一标识本行；必须提供数据，即NOT NULL，一个表只能有一个&raquo; 惟一键：一个或多个字段的组合，填入的数据必须能在本表中唯一标识本行；允许为NULL，一个表可以存在多个&raquo; 外键：一个表中的某字段可填入的数据取决于另一个表的主键或唯一键已有的数据&raquo; 检查：字段值在一定范围内 &diams; 数据的约束条件 ：是一组完整性规则的集合&raquo; 实体（行）完整性 Entity integrity&raquo; 域（列）完整性 Domain Integrity&raquo; 参考完整性 Referential Integrity 索引&diams; 将表中的一个或多个字段中的数据复制一份另存，并且按特定次序排序存储 关系运算&diams; 选择：挑选出符合条件的行&diams; 投影：挑选出需要的字段&diams; 连接：表间字段的关联 简易数据规划流程&diams; 第一阶段：收集数据，得到字段&raquo; 收集必要且完整的数据项&raquo; 转换成数据表的字段 &diams; 第二阶段：把字段分类，归入表，建立表的关联 &raquo; 关联：表和表间的关系 &raquo; 分割数据表并建立关联的优点 &raquo; 节省空间 &raquo; 减少输入错误 &raquo; 方便数据修改 &diams; 第三阶段： &raquo; 规范化数据库 数据库的正规化分析&diams; RDMBS设计范式基础概念&raquo; 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同范式，各种范式呈递次规范，越高的范式数据库冗余越小 &diams; 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴德斯科范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般数据库只需满足第三范式(3NF）即可 &raquo; 1NF：无重复的列，每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。除去同类型的字段，就是无重复的列 &raquo; 2NF：属性完全依赖于主键，第二范式必须先满足第一范式，要求表中的每个行必须可以被唯一地区分。通常为表加上一个列，以存储各个实例的唯一标识PK，非PK的字段需要与整个PK有直接相关性 &raquo; 3NF：属性不依赖于其它非主属性，满足第三范式必须先满足第二范式。第三范式要求一个数据库表中不包含已在其它表中已包含的非主关键字信息，非PK的字段间不能有从属关系 SQL概念&hearts; SQL介绍 SQL: Structure Query Language&diams; 结构化查询语言&diams; SQL解释器：&diams; 数据存储协议：应用层协议，C/S S：server, 监听于套接字，接收并处理客户端的应用请求 C：Client &diams; 客户端程序接口&raquo; CLI&raquo; GUI &diams; 应用编程接口&raquo; ODBC：Open Database Connectivity&raquo; JDBC：Java Data Base Connectivity mysql数据库安装配置mysql发展史及版本对比&hearts; 发展史 1979年：TcX公司 Monty Widenius，Unireg 1996年：发布MySQL1.0，Solaris版本，Linux版本 1999年：MySQL AB公司，瑞典 2003年：MySQL 5.0版本，提供视图、存储过程等功能 2008年：Sun 收购 2009年：Oracle收购sun 2009年：Monty成立MariaDB &hearts; mysql相关内容 官方网址：&diams; https://www.mysql.com/&diams; http://mariadb.org/ 官方文档&diams; https://dev.mysql.com/doc/&diams; https://mariadb.com/kb/en/ 版本演变：&diams; MySQL：5.1 –&gt; 5.5 –&gt; 5.6 –&gt; 5.7 –&gt;8.0&diams; MariaDB：5.5 –&gt;10.0–&gt; 10.1 –&gt; 10.2 –&gt; 10.3 MYSQL的特性&hearts; MYSQL的特性 插件式存储引擎：也称为“表类型”，存储管理器有多种实现版本，功能和特性可能均略有差别；用户可根据需要灵活选择,Mysql5.5.5开始innoDB引擎是MYSQL默认引擎&diams; MyISAM ==&gt; Aria&diams; InnoDB ==&gt; XtraDB 单进程，多线程 诸多扩展和新特性 提供了较多测试组件 开源 Mysql客户端服务端介绍&hearts; 客户端程序： mysql: 交互式的CLI工具 mysql两种使用模式： &diams; 交互式模式：&raquo; 客户端命令： 1234\h, help \u，use \s，status \!，system &raquo; 服务器端命令： SQL, 需要语句结束符； &diams; 脚本模式：&raquo; mysql –uUSERNAME -pPASSWORD &lt; /path/somefile.sql&raquo; mysql&gt; source /path/from/somefile.sql mysqldump：备份工具，基于mysql协议向mysqld发起查询请求，并将查得的所有数据转换成insert等写操作语句保存文本文件中 mysqladmin：基于mysql协议管理mysqld mysqlimport：数据导入工具 &hearts; 用户账号 mysql用户账号由两部分组成：&diams; ‘USERNAME‘@’HOST‘&diams; 说明：&raquo; HOST限制此用户可通过哪些远程主机连接mysql服务器&raquo; 支持使用通配符：&raquo; % 匹配任意长度的任意字符&raquo; 172.16.0.0/255.255.0.0 或 172.16.%.%&raquo; _ 匹配任意单个字符 mysql客户端可用选项：&diams; -A, –no-auto-rehash 禁止补全&diams; -u, –user= 用户名,默认为root&diams; -h, –host= 服务器主机,默认为localhost&diams; -p, –passowrd= 用户密码,建议使用-p,默认为空密码&diams; -P, –port= 服务器端口&diams; -S, –socket= 指定连接socket文件路径&diams; -D, –database= 指定默认数据库&diams; -C, –compress 启用压缩&diams; -e “SQL“ 执行SQL命令&diams; -V, –version 显示版本&diams; -v –verbose 显示详细信息&diams; –print-defaults 获取程序默认使用的配置 mysql执行命令&diams; 运行mysql命令：默认空密码登录&raquo; mysql&gt;use mysql&raquo; mysql&gt;select user();查看当前用户&raquo; mysql&gt;SELECT User,Host,Password FROM user; &diams; 登录系统：mysql –uroot –p &diams; 客户端命令：本地执行 &raquo; mysql&gt; help &raquo; 每个命令都完整形式和简写格式 &raquo; mysql&gt; status 或 \s &diams; 服务端命令：通过mysql协议发往服务器执行并取回结果 每个命令末尾都必须使用命令结束符号，默认为分号 &raquo; 示例：SELECT VERSION(); &hearts; 服务器端程序 mysqld_safe mysqld mysqld_multi 多实例 ，示例：mysqld_multi –example &hearts; socket地址 服务器监听的两种socket地址：&diams; ip socket: 监听在tcp的3306端口，支持远程通信&diams; unix sock: 监听在sock文件上，仅支持本机通信&raquo; 如：/var/lib/mysql/mysql.sock)&diams; 说明：host为localhost,127.0.0.1时自动使用unix sock mysql安装方法RPM方法&hearts; RPM包安装MySQL RPM包安装&diams; CentOS 7：安装光盘直接提供&raquo; mariadb-server 服务器包&raquo; mariadb 客户端工具包 注意事项：提高安全性&diams; mysql_secure_installation&raquo; 设置数据库管理员root口令&raquo; 禁止root远程登录&raquo; 删除anonymous用户帐号&raquo; 删除test数据库 通用二进制格式安装&hearts; 二进制包安装MySQL 准备用户&diams; useradd -r -u 306 mysql 准备数据目录&diams; mkdir -pv /mydata/data&diams; chown -R mysql:mysql /mydata/data&diams; 数据存放目录最好放在逻辑卷上配置raid使用 准备二进制程序&diams; tar xf mariadb-VERSION-linux-x86_64.tar.gz -C /usr/local&diams; cd /usr/local;ln -sv mariadb-VERSION mysql&diams; chown -R root:mysql /usr/local/mysql/ 准备配置文件&diams; mkdir /etc/mysql&diams; cp /usr/local/mysql/support-files/my-large.cnf /etc/mysql/my.cnf&diams; 修改配置文件：示图如下 12345vim /etc/mysql/my.cnf[mysqld]datadir = /mydata/datainnodb_file_per_table = on skip_name_resolve = on 禁止主机名解析，建议使用 初始化脚本&diams; cd /usr/local/mysql/&diams; ./scripts/mysql_install_db –datadir=/mydata/data –user=mysql 准备服务脚本，并启动服务&diams; cp ./support-files/mysql.server /etc/rc.d/init.d/mysqld&diams; chkconfig –add mysqld&diams; service mysqld start 安全初始化&diams; /user/local/mysql/bin/mysql_secure_installation 源码编译安装&hearts; 源码编译安装mariadb 安装所依赖的软件包&diams; yum install bison bison-devel zlib-devel libcurl-devel libarchive-devel boost-devel gcc gcc-c++ cmake ncurses-devel gnutls-devel libxml2-devel openssl-devel libevent-devel libaio-devel 做准备用户和数据目录&diams; useradd -r -u 306 mysql&diams; mkdir /data/mysql&diams; chown -R mysql:mysql /data/mysql&diams; tar xvf mariadb-10.2.15.tar.gz cmake 编译安装：&diams; cmake介绍:cmake的重要特性之一是其独立于源码(out-of-source)的编译功能，即编译工作可以在另一个指定的目录中而非源码目录中进行，这可以保证源码目录不受任何一次编译的影响，因此在同一个源码树上可以进行多次不同的编译，如针对于不同平台编译&diams; 编译参数如下: 123456789101112131415161718192021cd mariadb-10.2.15/ cmake . \-DCMAKE_INSTALL_PREFIX=/app/mysqldb \-DMYSQL_DATADIR=/data/mysql/ \-DSYSCONFDIR=/etc \-DMYSQL_USER=mysql \-DWITH_INNOBASE_STORAGE_ENGINE=1 \-DWITH_ARCHIVE_STORAGE_ENGINE=1 \-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \-DWITH_PARTITION_STORAGE_ENGINE=1 \-DWITHOUT_MROONGA_STORAGE_ENGINE=1 \-DWITH_DEBUG=0 \-DWITH_READLINE=1 \-DWITH_SSL=system \-DWITH_ZLIB=system \-DWITH_LIBWRAP=0 \-DENABLED_LOCAL_INFILE=1 \-DMYSQL_UNIX_ADDR=/app/mysqldb/mysql.sock \-DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_general_ci make &amp;&amp; make install 准备环境变量&diams; echo ‘PATH=/app/mysqldb/bin:$PATH’ &gt; /etc/profile.d/mysql.sh&diams; source /etc/profile.d/mysql.sh 生成数据库文件&diams; cd /app/mysqldb/&diams; chown -R root:mysql ./*&diams; scripts/mysql_install_db –datadir=/data/mysql/ –user=mysql 准备配置文件&diams; cp /app/mysql/support-files/my-huge.cnf /etc/my.cnf&diams; 修改配置文件：示图如下 12345vim /etc/my.cnf[mysqld]datadir = /data/mysqlinnodb_file_per_table = on skip_name_resolve = on 禁止主机名解析，建议使用 准备启动脚本&diams; p /app/mysqldb/support-files/mysql.server /etc/init.d/mysqld 启动服务&diams; chkconfig –add mysqld ;service mysqld start mysql多实例实现&hearts; 操作步骤 第一步：创建对应的目录&diams; mkdir -pv /mydata/mysql/{3306,3307,3308}/{etc,log,data,pid,bin,socket} 1234567891011121314151617181920212223/mydata/└── mysql ├── 3306 │ ├── bin │ ├── data │ ├── etc │ ├── log │ ├── pid │ └── socket ├── 3307 │ ├── bin │ ├── data │ ├── etc │ ├── log │ ├── pid │ └── socket └── 3308 ├── bin ├── data ├── etc ├── log ├── pid └── socket &diams; useradd -r mysql ; chown -R mysql:mysql /mydata/mysql/ 第二步：初始化mysql 12345tar -xvf mysql-5.5.59-linux-glibc2.12-x86_64.tar.gz -C /usr/local/cd /usr/local/ ; ln -sv mysql-5.5.59-linux-glibc2.12-x86_64 mysql ; cd mysqlscripts/mysql_install_db --datadir=/mydata/mysql/3306/data/ --user=mysql ; echo $?scripts/mysql_install_db --datadir=/mydata/mysql/3306/data/ --user=mysql ; echo $?scripts/mysql_install_db --datadir=/mydata/mysql/3306/data/ --user=mysql ; echo $? 第三步：准备配置文件 123cp /etc/my.cnf /mydata/mysql/3306/etc/my.cnf cp /etc/my.cnf /mydata/mysql/3307/etc/my.cnf cp /etc/my.cnf /mydata/mysql/3308/etc/my.cnf 第四步：修改对应的配置文件&diams; 示图 123456789101112vim /mydata/mysql/3306/etc/my.cnf[mysqld]port=3306datadir=/mydata/mysql/3306/datasocket=/mydata/mysql/3306/socket/mysql.sockuser=mysql# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0[mysqld_safe]log-error=/mydata/mysql/3306/log/mysqld.logpid-file=/mydata/mysql/3306/pid/mysqld.pid 准备启动脚本&diams; 脚本如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/bin/bashport=3306mysql_user="root"mysql_pwd=""cmd_path="/usr/local/mysql/bin"mysql_basedir="/mydata/mysql"mysql_sock="$&#123;mysql_basedir&#125;/$&#123;port&#125;/socket/mysql.sock"function_start_mysql()&#123; if [ ! -e "$mysql_sock" ];then printf "Starting MySQL...\n" $&#123;cmd_path&#125;/mysqld_safe --defaults-file=$&#123;mysql_basedir&#125;/$&#123;port&#125;/etc/my.cnf &amp;&gt; /dev/null &amp; #信息前台输出，如果端口没有启来，可以根具输出信息做出判断 #$&#123;cmd_path&#125;/mysqld_safe --defaults-file=$&#123;mysql_basedir&#125;/$&#123;port&#125;/etc/my.cnf &amp; else printf "MySQL is running...\n" exit fi&#125;function_stop_mysql()&#123; if [ ! -e "$mysql_sock" ];then printf "MySQL is stopped...\n" exit else printf "Stoping MySQL...\n" $&#123;cmd_path&#125;/mysqladmin -u $&#123;mysql_user&#125; -p$&#123;mysql_pwd&#125; -S $&#123;mysql_sock&#125; shutdown fi&#125;function_restart_mysql()&#123; printf "Restarting MySQL...\n" function_stop_mysql sleep 2 function_start_mysql&#125;case $1 instart) function_start_mysql;;stop) function_stop_mysql;;restart) function_restart_mysql;;*) printf "Usage: $&#123;mysql_basedir&#125;/$&#123;port&#125;/bin/mysqld &#123;start|stop|restart&#125;\n"esac &diams; 脚本链接：https://pan.baidu.com/s/1uR7BXKCQWU9CB0Mko6LNew 第五步：修改密码、并登陆对应的事例&diams; 操作如下12/usr/local/mysql/bin/mysqladmin -uroot -s /mydata/mysql/3306/socket/mysql.sock password "centos"/usr/local/mysql/bin/mysql -uroot -pcentos -S /mydata/mysql/3306/socket/mysql.sock -e "show variables like 'port' " 数据类型数据类型介绍&hearts; 数据类型相关介绍 数据类型&diams; 数据长什么样？&diams; 数据需要多少空间来存放？ 系统内置数据类型和用户定义数据类型 MySql支持多种列类型：&diams; 数值类型&diams; 日期/时间类型&diams; 字符串(字符)类型&diams; https://dev.mysql.com/doc/refman/5.5/en/data-types.html 选择正确的数据类型对于获得高性能至关重要，三大原则：&diams; 更小的通常更好，尽量使用可正确存储数据的最小数据类型&diams; 简单就好，简单数据类型的操作通常需要更少的CPU周期&diams; 尽量避免NULL，包含为NULL的列，对MySQL更难优化 数据类型整型&hearts; 整型 tinyint(m) 1个字节 范围(-128~127) smallint(m) 2个字节 范围(-32768~32767) mediumint(m) 3个字节 范围(-8388608~83sssssss88607) int(m) 4个字节 范围(-2147483648~2147483647) bigint(m) 8个字节 范围(+-9.22*10的18次方) BOOL，BOOLEAN：布尔型，是TINYINT(1)的同义词。zero值被视为假，非zero值视为真&diams; 加了unsigned，则最大值翻倍，如：tinyint unsigned的取值范围为(0~255) int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，规定了MySQL的一些交互工具（例如MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，Int(1)和Int(20)是相同的 浮点型&hearts; 浮点型(float和double)，近似值 float(m,d) 单精度浮点型 8位精度(4字节) m总个数，d小数位 double(m,d) 双精度浮点型16位精度(8字节) m总个数，d小数位 设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位 定点数&hearts; 定点数 在数据库中存放的是精确值,存为十进制 decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 d &lt; m 是小数位 MySQL5.0和更高版本将数字打包保存到一个二进制字符串中（每4个字节存9个数字）。例如，decimal(18,9)小数点两边将各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点本身占1个字节 浮点类型在存储同样范围的值时，通常比decimal使用更少的空间。float使用4个字节存储。double占用8个字节 因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用decimal——例如存储财务数据。但在数据量比较大的时候，可以考虑使用bigint代替decimal 字符串&hearts; 字符串(char,varchar,_text) char(n) 固定长度，最多255个字符 varchar(n) 可变长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 BINARY(M) 固定长度，可存二进制或字符，长度为0-M字节 VARBINARY(M) 可变长度，可存二进制或字符，允许长度为0-M字节 内建类型：ENUM枚举, SET集合 &hearts; char和varchar比较 char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。 char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt; n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。 char类型的字符串检索速度要比varchar类型的快 &hearts; varchar和text： archar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt; n&gt;255)，text是实际字符数+2个字节。 text类型不能有默认值 varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text 二进制数据&hearts; 二进制数据：BLOB BLOB和text存储方式不同，TEXT以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写 BLOB存储的数据只能整体读出 TEXT可以指定字符集，BLOB不用指定字符集 日期时间类型&hearts; 日期时间类型 date 日期 ‘2008-12-2’ time 时间 ‘12:25:36’ datetime 日期时间 ‘2008-12-2 22:06:44’ timestamp 自动存储记录修改时间 YEAR(2), YEAR(4)：年份 timestamp字段里的时间数据会随其他字段修改的时候自动刷新，这个数据类型的字段可以存放这条记录最后被修改的时间 修饰符&hearts; 修饰符所有类型 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 UNIQUE KEY 唯一键 CHARACTER SET name 指定一个字符集 数值型&diams; AUTO_INCREMENT 自动递增，适用于整数类型&diams; UNSIGNED 无符号 示例 示例1 1234CREATE TABLE students (id int UNSIGNED NOT NULL PRIMARY KEY,name VARCHAR（20）NOT NULL,age tinyint UNSIGNED); 示例2 12345CREATE TABLE students2 (id int UNSIGNED NOT NULL ,name VARCHAR(20) NOT NULL,age tinyint UNSIGNED,PRIMARY KEY(id,name)); SQL语句DDLDDL介绍&hearts; DDL DDL: Data Defination Language 数据定义语言&diams; CREATE&diams; DROP&diams; ALTER 创建数据库&hearts; 创建数据库 CREATE DATABASE|SCHEMA [IF NOT EXISTS] ‘DB_NAME’; CHARACTER SET ‘character set name’&diams; 查看支持所有字符集：SHOW CHARACTER SET;&diams; 查看支持所有排序规则：SHOW COLLATION; COLLATE ‘collate name’&diams; 示例 1CREATE DATABASE zabbix CHARACTER SET utf8; 获取命令使用帮助：&diams; mysql&gt; HELP KEYWORD; 查看数据库列表：&diams; mysql&gt; SHOW DATABASES; 删除数据库&hearts; 删除数据库 DROP DATABASE|SCHEMA [IF EXISTS] ‘DB_NAME’;&diams; 示例1DROP DATABASE zabbix; 创建表表介绍&hearts; 表介绍 表：二维关系 设计表：遵循规范 定义：字段，索引&diams; 字段：字段名，字段数据类型，修饰符&diams; 约束，索引：应该创建在经常用作查询条件的字段上 直接创建&diams; 直接创建 CREATE TABLE [IF NOT EXISTS] ‘tbl_name’ (col1 type1 修饰符, col2 type2 修饰符, …) 字段信息&diams; col type1&diams; PRIMARY KEY(col1,…)&diams; INDEX(col1, …)&diams; UNIQUE KEY(col1, …) 表选项：&diams; ENGINE [=] engine_name&diams; SHOW ENGINES;查看支持的engine类型&diams; ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}&diams; 获取帮助：mysql&gt; HELP CREATE TABLE; 表相关操作&diams; 查看所有的引擎：SHOW ENGINES&diams; 查看表：SHOW TABLES [FROM db_name]&diams; 查看表结构：DESC [db_name.]tb_name&diams; 删除表：DROP TABLE [IF EXISTS] tb_name&diams; 查看表创建命令：SHOW CREATE TABLE tbl_name&diams; 查看表状态：SHOW TABLE STATUS LIKE ‘tbl_name’&diams; 查看库中所有表状态：SHOW TABLE STATUS FROM db_name 查询现存表创建&hearts; 通过查询现存表创建；新表会被直接插入查询而来的数据 CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,…)] [table_options] [partition_options] select_statement 复制现存表构创建&hearts; 通过复制现存的表的表结构创建，但不复制数据 CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name { LIKE old_tbl_name | (LIKE old_tbl_name) } 删除表&hearts; 删除表 DROP TABLE [IF EXISTS] ‘tbl_name’; 修改表&hearts; 修改表 ALTER TABLE ‘tbl_name’ 字段&diams; 添加字段：add&diams; ADD col1 data_type [FIRST|AFTER col_name]&diams; 删除字段：drop&diams; 修改字段：&diams; alter（默认值）, change（字段名）, modify（字段属性） 索引&diams; 添加索引：add index&diams; 删除索引：drop index&diams; 查看表上的索引：SHOW INDEXES FROM [db_name.]tbl_name;&diams; 查看帮助：Help ALTER TABLE 修改表示例&hearts; 修改表示例 ALTER TABLE students RENAME s1; ALTER TABLE s1 ADD phone varchar(11) AFTER name; ALTER TABLE s1 MODIFY phone int; ALTER TABLE s1 CHANGE COLUMN phone mobile char(11); ALTER TABLE s1 DROP COLUMN mobile; Help ALTER TABLE 查看帮助 ALTER TABLE students ADD gender ENUM(‘m’,’f’) ALETR TABLE students CHANGE id sid int UNSIGNED NOT NULL PRIMARY KEY; ALTER TABLE students ADD UNIQUE KEY(name); ALTER TABLE students ADD INDEX(age); SHOW INDEXES FROM students; ALTER TABLE students DROP age; DMLDML介绍&hearts; DML介绍 DML: Data Manipulation Language 数据操纵语言 DML: INSERT, UPDATE ,DELETE&diams; INSERT&diams; UPDATE&diams; DELETE INSERT&hearts; INSERT 一次插入一行或多行数据 INSERT [L OW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE][INTO] tbl_name [(col_name,…)]{VALUES | VALUE} ({expr | DEFAULT},…),(…),…[ ON DUPLICATE KEY UPDATE 如果重复更新之col_name=expr[, col_name=expr] … ] INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE][INTO] tbl_nameSET col_name={expr | DEFAULT}, …[ ON DUPLICATE KEY UPDATEcol_name=expr[, col_name=expr] … ] INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE][INTO] tbl_name [(col_name,…)]SELECT …[ ON DUPLICATE KEY UPDATEcol_name=expr[, col_name=expr] … ] 简化写法：&diams; INSERT tbl_name [(col1,…)] VALUES (val1,…), (val21,…) UPDATE&hearts; UPDATE UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] … [WHERE where_condition] [ORDER BY …] [LIMIT row_count] 注意：一定要有限制条件，否则将修改所有行的指定字段 限制条件：&diams; WHERE&diams; LIMIT Mysql 选项：-U|–safe-updates| –i-am-a-dummy DELETE&hearts; DELETE DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name [WHERE where_condition] [ORDER BY …] [LIMIT row_count]&diams; 可先排序再指定删除的行数 注意：一定要有限制条件，否则将清空表中的所有数据&diams; WHERE&diams; LIMIT&diams; TRUNCATE TABLE tbl_name; 清空表 DCL&hearts; DCL DCL：Data Control Language 数据控制语言&diams; GRANT&diams; REVOKE&diams; COMMIT&diams; ROLLBACK DQL&hearts; DQL DQL：Data Query Language 数据查询语言 SELECT&hearts; SELECT 字段显示可以使用别名：&diams; col1 AS alias1, col2 AS alias2, … SELECT常见组合WHERE&hearts; WHERE用法 WHERE子句：指明过滤条件以实现“选择”的功能：&diams; 过滤条件：布尔型表达式&diams; 算术操作符：+, -, *, /, %&diams; 比较操作符：=,&lt;=&gt;（相等或都为空）, &lt;&gt;, !=(非标准SQL), &gt;, &gt;=, &lt;, &lt;=&diams; BETWEEN min_num AND max_num&diams; IN (element1, element2, …)&diams; IS NULL&diams; IS NOT NULL DISTINCT&hearts; DISTINCT用法 DISTINCT 去除重复列&diams; SELECT DISTINCT gender FROM students; LIKE&hearts; LIKE用法 LIKE:&diams; %: 任意长度的任意字符&diams; _：任意单个字符 RLIKE&hearts; RLIKE用法 RLIKE: 正则表达式，索引失效，不建议使用 REGEXP&hearts; REGEXP用法 REGEXP：匹配字符串可用正则表达式书写模式，同上 逻辑操作符&hearts; 逻辑操作符用法 逻辑操作符：&diams; NOT&diams; AND&diams; OR&diams; XOR GROUP&hearts; GROUP用法 GROUP&diams; 根据指定的条件把查询结果进行“分组”以用于做“聚合”运算 avg(), max(), min(), count(), sum()&diams; HAVING: 对分组聚合运算后的结果指定过滤条件 ORDER BY&hearts; ORDER BY用法 根据指定的字段对查询结果进行排序&diams; 升序：ASC&diams; 降序：DESC LIMIT&hearts; LIMIT用法 对查询的结果进行输出行数数量限制 锁&hearts; 锁机制 FOR UPDATE: 写锁，独占或排它锁，只有一个读和写 LOCK IN SHARE MODE: 读锁，共享锁，同时多个读 常用示例 常见组合&diams; 示例12345678910111213DESC students; INSERT INTO students VALUES(1,'tom'，'m'),(2,'alice','f'); INSERT INTO students(id,name) VALUES(3,'jack'),(4,'allen'); SELECT * FROM students WHERE id &lt; 3; SELECT * FROM students WHERE gender='m'; SELECT * FROM students WHERE gender IS NULL; SELECT * FROM students WHERE gender IS NOT NULL; SELECT * FROM students ORDER BY name DESC LIMIT 2; SELECT * FROM students ORDER BY name DESC LIMIT 1,2; SELECT * FROM students WHERE id &gt;=2 and id &lt;=4 SELECT * FROM students WHERE name LIKE ‘t%’ SELECT * FROM students WHERE name RLIKE '.*[lo].*'; SELECT id stuid,name as stuname FROM students 多表查询交叉连接&hearts; 交叉连接 笛卡尔乘积 内链接&hearts; 内链接 等值连接：让表之间的字段以“等值”建立连接关系； 不等值连接 自然连接:去掉重复列的等值连接 自连接 外链接&hearts; 外链接 左外连接：&diams; FROM tb1 LEFT JOIN tb2 ON tb1.col=tb2.col 右外连接&diams; FROM tb1 RIGHT JOIN tb2 ON tb1.col=tb2.col 子查询&hearts; 子查询 在查询语句嵌套着查询语句，性能较差 基于某语句的查询结果再次进行的查询&diams; 示例 123select * from students where age &gt;(select avg(age) from students); 用在WHERE子句中的子查询：&diams; 用于比较表达式中的子查询；子查询仅能返回单个值&raquo; SELECT Name,Age FROM students WHERE Age&gt;(SELECT avg(Age) FROM students);&diams; 用于IN中的子查询：子查询应该单键查询并返回一个或多个值从构成列表&raquo; SELECT Name,Age FROM students WHERE Age IN (SELECT Age FROM teachers);&diams; 用于EXISTS 用于FROM子句中的子查询&diams; 使用格式：SELECT tb_alias.col1,… FROM (SELECT clause) AS tb_alias WHERE Clause;&diams; SELECT s.aage,s.ClassID FROM (SELECT avg(Age) AS aage,ClassID FROM students WHERE ClassID IS NOT NULL GROUP BY ClassID) AS s WHERE s.aage&gt;30; 联合查询：UNION&diams; SELECT Name,Age FROM students UNION SELECT Name,Age FROM teachers;&diams; 纵向合并，字段类型要相当。 示图 inner join 示图 inner join 示例12345#取交集select * from students as s inner join teachers as t on s.teacherid = t.tid; left join 示图 示例1 12345#左链接select * from students as s left join teachers as t on s.teacherid=t.tid; 示图 示例2 12345select * from students as s left join teachers as t on s.teacherid=t.tidwhere t.tid is null; 示图 示例3 12345678select s.stuid,s.name as student_name,t.name from students as s left join teachers as t on s.teacherid=t.tid union select s.stuid,s.name as student_name,t.name from students as s right join teachers as t on s.teacherid=t.tid; 示图 示例41234567select * from ( select s.stuid,s.name student_name,t.name teacher_name,s.teacherid from students s left join teachers t on s.teacherid=t.tid union select s.stuid,s.name student_name,t.name teacher_name,s.teacherid from students s right join teachers t on s.teacherid=t.tid ) as a where a.teacherid is null or a.stuid is null; 练习&hearts; hellodb.sql链接 https://pan.baidu.com/s/1gnBingbPQB3hDXvSsH042A &hearts; 导入hellodb.sql生成数据库 在students表中，查询年龄大于25岁，且为男性的同学的名字和年龄 1select Name,Age from students where age &gt; 25 and Gender="M"; 以ClassID为分组依据，显示每组的平均年龄 1select avg(age) from students group by classid; 显示第2题中平均年龄大于30的分组及平均年龄 1select s.aage,s.aclass from (select avg(age) as aage,classid as aclass from students group by classid) as s where s.aage&gt;30; 显示以L开头的名字的同学的信息 1select * from students where name rlike '^L'; 显示TeacherID非空的同学的相关信息 1select * from students where TeacherID is not NULL; 以年龄排序后，显示年龄最大的前10位同学的信息 1select * from students order by age desc limit 10; 查询年龄大于等于20岁，小于等于25岁的同学的信息 1select * from students where age &gt; 20 and age &lt; 25; &hearts; 导入hellodb.sql，以下操作在students表上执行 以ClassID分组，显示每班的同学的人数 1select count(stuid),classid from students group by classid; 以Gender分组，显示其年龄之和 1select sum(age),gender from students group by gender; 以ClassID分组，显示其平均年龄大于25的班级 1select s.age,s.class from(select avg(age)as age,classid as class from students group by classid)as s where s.age&gt;25; 以Gender分组，显示各组中年龄大于25的学员的年龄之和 1select sum(age),count(age) as totle from students where age &gt; 25 group by gender; 显示前5位同学的姓名、课程及成绩 123456789select new.name,co.course,new.score from(select st.name,sc.courseid,sc.score from(select * from students limit 5)as st inner join scores as sc on st.stuid=sc.stuid)as new inner join courses as co on new.courseid=co.courseid; 显示其成绩高于80的同学的名称及课程 123456789select new.name,co.course,new.score from(select sc.stuid,sc.courseid,st.name,sc.score from(select * from scores where score &gt;80)as sc inner join students as st on sc.stuid=st.stuid)as new inner join courses as co on new.courseid=co.courseid; 求前8位同学每位同学自己两门课的平均成绩，并按降序排列 1234567select * from(select name,avg(score) as score from(select st.name,sc.score from(select * from students limit 8)as st inner join scores as sc on st.stuid=sc.stuid)as new group by name)as nn order by score desc; 显示每门课程课程名称及学习了这门课的同学的个数 123456select new.course,count(id) as sum from(select sc.id,co.course from scores as sc inner join courses as co n sc.courseid=co.courseid)as new group by course; 显示其年龄大于平均年龄的同学的名字 1select name from students where age&gt;(select avg(age) from students); 显示其学习的课程为第1、2，4或第7门课的同学的名字 123456789select ss.name,nn.course from (select new.course,sc.stuid from(select * from courses where courseid=1 or courseid=2 or courseid=4 or courseid=7)as new inner join scores as sc on new.courseid=sc.courseid)as nn inner join students as ss on nn.stuid=ss.stuid; 显示其成员数最少为3个的班级的同学中年龄大于同班同学平均年龄的同学 1234567select * from(select ss.classid,ss.name,ss.age,nn.avgage from(select classid,count(*)as sum,avg(age)as avgage from students group by classid having sum&gt;=3)as nn inner join students as ss on nn.classid=ss.classid)as oo where oo.age &gt; oo.avgage; 统计各班级中年龄大于全校同学平均年龄的同学个数 123select classid,count(*)as sum from (select * from students where age&gt;(select avg(age) from students))as new group by classid; MySQL用户和权限管理MySQL用户管理相关概念&hearts; 元数据数据库：mysql 系统授权表&diams; db, host, user&diams; columns_priv, tables_priv, procs_priv, proxies_priv &hearts; 用户账号 ‘USERNAME‘@’HOST’： @’HOST’:&diams; 主机名&diams; IP地址或Network&diams; 通配符：&diams; %, _: 172.16.%.% 创建用户&hearts; CREATE USER CREATE USER ‘USERNAME‘@’HOST’ [IDENTIFIED BY ‘password’]；&diams; 默认权限：USAGE 用户重命名&hearts; RENAME USER RENAME USER old_user_name TO new_user_name 删除用户&hearts; DROP USER DROP USER ‘USERNAME‘@’HOST‘ 示例&diams; DROP USER ‘‘@’localhost’;&diams; DROP USER ‘zabbix‘@’127.0.0.1’; 修改密码&hearts; Change pasword SET PASSWORD FOR ‘user‘@’host’ = PASSWORD(‘password’); UPDATE mysql.user SET password=PASSWORD(‘password’) WHERE clause;&diams; 示例 1UPDATE mysql.user SET password=PASSWORD('fang') WHERE user='fang'; 此方法需要执行下面指令才能生效：&diams; FLUSH PRIVILEGES; 管理员密码破解&hearts; 忘记管理员密码 启动mysqld进程时，为其使用如下选项： (可加在配置文件中)&diams; –skip-grant-tables 跳过授权表&diams; –skip-networking 只允许本机登陆 使用UPDATE命令修改管理员密码&diams; 示例 1UPDATE mysql.user SET password=PASSWORD('123') WHERE user='root'; 关闭mysqld进程，移除上述两个选项，重启mysqld MySQL权限管理权限类别管理类&hearts; 管理类权限 CREATE TEMPORARY TABLES CREATE USER FILE SUPER SHOW DATABASES RELOAD SHUTDOWN REPLICATION SLAVE REPLICATION CLIENT LOCK TABLES PROCESS 程序类&hearts; 程序类权限 FUNCTION、PROCEDURE、TRIGGER CREATE ALTER DROP EXCUTE 库和表级别&hearts; 库和表级别权限 DATABASE、TABLE&diams; ALTER&diams; CREATE&diams; CREATE VIEW&diams; DROP&diams; INDEX&diams; SHOW VIEW&diams; GRANT OPTION：能将自己获得的权限转赠给其他用户 数据库操作&hearts; 数据库操作权限 SELECT INSERT DELETE UPDATE 字段级别&hearts; 字段级别操作权限 SELECT(col1,col2,…) UPDATE(col1,col2,…) INSERT(col1,col2,…) 所有权限&hearts; 所有权限 ALL PRIVILEGES 或 ALL 用户授权&hearts; 用户授权 参考：https://dev.mysql.com/doc/refman/5.7/en/grant.html GRANT priv_type [(column_list)],… ON [object_type] priv_level TO ‘user‘@’host’ [IDENTIFIED BY ‘password’] [WITH GRANT OPTION];&diams; 示例123GRANT SELECT (col1), INSERT (col1,col2) ON mydb.mytbl TO 'someuser'@'somehost‘; GRANT ALL ON zabbix.* to 'zabbix'@'127.0.0.1' identified by 'zabbix';GRANT ALL ON zabbix.* to 'zabbix'@'localhost' identified by 'zabbix'; 回收授权&hearts; 回收授权 REVOKE priv_type [(column_list)] [, priv_type [(column_list)]] … ON [object_type] priv_level FROM user [, user] …&diams; 示例123REVOKE DELETE ON testdb.* FROM 'testuser'@'%‘ REVOKE DELETE ON zabbix.* FROM 'zabbix'@'127.0.0.1';REVOKE DELETE ON zabbix.* FROM 'zabbix'@'localhost'; 查看授权&hearts; 查看指定用户获得的授权 Help SHOW GRANTS SHOW GRANTS FOR ‘user‘@’host’; SHOW GRANTS FOR ‘zabbix‘@’localhost’; SHOW GRANTS FOR CURRENT_USER[()]; 注意&diams; MariaDB服务进程启动时会读取mysql库中所有授权表至内存&diams; GRANT或REVOKE等执行权限操作会保存于系统表中，MariaDB的服务进程通常会自动重读授权表，使之生效&diams; 对于不能够或不能及时重读授权表的命令，可手动让MariaDB的服务进程重读授权表：mysql&gt; FLUSH PRIVILEGES; MySql存储引擎MySql存储引擎介绍&hearts; MySql存储引擎介绍 数据库存储引擎是数据流底层软件组件，数据库管理系统（DBMS）使用数据库引擎进行创建、查询，更新和删除数据库操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL 的核心就是存储引擎。 MySql各存储引擎对比&diams; &diams; InnoDB support for FULLTEXT indexes is available in MySQL 5.6.4 and later. 存储引擎比较：https://docs.oracle.com/cd/E17952_01/mysql-5.5-en/storage-engines.html MyISAM引擎&hearts; MyISAM引擎特点： 不支持事务 表级锁定 读写相互阻塞，写入不能读，读时不能写 只缓存索引 不支持外键约束 不支持聚簇索引 读取数据较快，占用资源较少 不支持MVCC（多版本并发控制机制）高并发&diams; 第个事务都有对应的事务编号,新事务比旧事务的ID要大&diams; 默认表字段：insert,delete&diams; select 查到记录的insert事务编号比当前事务的小（早）, delete 事务编号比当前事务大（晚）&diams; 同一时间操作：操作前的数据&diams; 脏数据：事务过程中的数据 崩溃恢复性较差 MySQL5.5.5前默认的数据库引擎 &hearts; 适用场景 只读（或者写较少）、表较小（可以接受长时间进行修复操作） MyISAM引擎文件：&diams; tbl_name.frm: 表格式定义&diams; tbl_name.MYD: 数据文件&diams; tbl_name.MYI: 索引文件 InnoDB引擎&hearts; InnoDB引擎特点 行级锁 支持事务，适合处理大量短期事务&diams; 事务：完整的多个操作的集合。 读写阻塞与事务隔离级别相关 可缓存数据和索引 支持聚簇索引 崩溃恢复性更好 支持MVCC高并发 从MySQL5.5后支持全文索引 从MySQL5.5.5开始为默认的数据库引擎 &hearts; InnoDB数据库文件 所有InnoDB表的数据和索引放置于同一个表空间中&diams; 表空间文件：datadir定义的目录下&diams; 数据文件：ibddata1, ibddata2, … 每个表单独使用一个表空间存储表的数据和索引&diams; 启用：innodb_file_per_table=ON&diams; 参看：&diams; https://mariadb.com/kb/en/library/xtradbinnodb-server-system-variables/#innodb_file_per_table ON (&gt;= MariaDB 5.5) 两类文件放在数据库独立目录中&diams; 数据文件(存储数据和索引)：tb_name.ibd&diams; 表格式定义：tb_name.frm 其它存储引擎&hearts; 其它存储引擎 Performance_Schema:Performance_Schema数据库 Memory ：将所有数据存储在RAM中，以便在需要快速查找参考和其他类似数据的环境中进行快速访问。适用存放临时数据。引擎以前被称为HEAP引擎 MRG_MyISAM：使MySQL DBA或开发人员能够对一系列相同的MyISAM表进行逻辑分组，并将它们作为一个对象引用。适用于VLDB(Very Large Data Base)环境，如数据仓库 Archive ：为存储和检索大量很少参考的存档或安全审核信息，只支持SELECT和INSERT操作；支持行级锁和专用缓存区 Federated联合：用于访问其它远程MySQL服务器一个代理，它通过创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，而后完成数据存取，提供链接单独MySQL服务器的能力，以便从多个物理服务器创建一个逻辑数据库。非常适合分布式或数据集市环境 BDB：可替代InnoDB的事务引擎，支持COMMIT、ROLLBACK和其他事务特性 Cluster/NDB：MySQL的簇式数据库引擎，尤其适合于具有高性能查找要求的应用程序，这类查找需求还要求具有最高的正常工作时间和可用性 CSV：CSV存储引擎使用逗号分隔值格式将数据存储在文本文件中。可以使用CSV引擎以CSV格式导入和导出其他软件和应用程序之间的数据交换 BLACKHOLE ：黑洞存储引擎接受但不存储数据，检索总是返回一个空集。该功能可用于分布式数据库设计，数据自动复制，但不是本地存储 example：“stub”引擎，它什么都不做。可以使用此引擎创建表，但不能将数据存储在其中或从中检索。目的是作为例子来说明如何开始编写新的存储引擎 MariaDB支持的其它存储引擎：&diams; OQGraph&diams; SphinxSE&diams; TokuDB&diams; Cassandra&diams; CONNECT&diams; SQUENCE 管理存储引擎&hearts; 管理存储引擎 查看mysql支持的存储引擎:&diams; show engines; 查看当前默认的存储引擎:&diams; show variables like ‘%storage_engine%’; 设置默认的存储引擎：&diams; vim /etc/my.conf&diams; [mysqld]&diams; default_storage_engine= InnoDB; 查看库中所有表使用的存储引擎&diams; Show table status from db_name; 查看库中指定表的存储引擎&diams; show table status like ‘ tb_name ‘;&diams; show create table tb_name; 设置表的存储引擎：&diams; CREATE TABLE tb_name(… ) ENGINE=InnoDB;&diams; ALTER TABLE tb_name ENGINE=InnoDB; 查询缓存介绍&hearts; 查询缓存介绍 查询缓存（ Query Cache ）原理：&diams; 缓存SELECT操作或预处理查询的结果集和SQL语句，当有新的SELECT语句或预处理查询语句请求，先去查询缓存，判断是否存在可用的记录集，判断标准：与缓存的SQL语句，是否完全一样，区分大小写 优缺点&diams; 不需要对SQL语句做任何解析和执行，当然语法解析必须通过在先，直接从Query Cache中获得查询结果，提高查询性能&diams; 查询缓存的判断规则，不够智能，也即提高了查询缓存的使用门槛，降低其效率；&diams; 查询缓存的使用，会增加检查和清理Query Cache中记录集的开销 不会被缓存的查询&hearts; 不会被缓存的查询 查询语句中加了SQL_NO_CACHE参数 查询语句中含有获得值的函数，包含自定义函数，如：NOW() CURDATE()、GET_LOCK()、RAND()、CONVERT_TZ()等 对系统数据库的查询：mysql、information_schema 查询语句中使用SESSION级别变量或存储过程中的局部变量 查询语句中使用了LOCK IN SHARE MODE、FOR UPDATE的语句，查询语句中类似SELECT …INTO 导出数据的语句 对临时表的查询操作；存在警告信息的查询语句；不涉及任何表或视图的查询语句；某用户只有列级别权限的查询语句 事务隔离级别为Serializable时，所有查询语句都不能缓存 相关变量服务器变量&hearts; 查询缓存相关的服务器变量 query_cache_min_res_unit: 查询缓存中内存块的最小分配单位，默认4k，较小值会减少浪费，但会导致更频繁的内存分配操作，较大值会带来浪费，会导致碎片过多，内存不足 query_cache_limit：单个查询结果能缓存的最大值，默认为1M，对于查询结果过大而无法缓存的语句，建议使用SQL_NO_CACHE query_cache_size：查询缓存总共可用的内存空间；单位字节，必须是1024的整数倍，最小值40KB，低于此值有警报 query_cache_wlock_invalidate：如果某表被其它的会话锁定，是否仍然可以从查询缓存中返回结果，默认值为OFF，表示可以在表被其它会话锁定的场景中继续从缓存返回数据；ON则表示不允许 query_cache_type: 是否开启缓存功能，取值为ON, OFF, DEMAND SELECT语句的缓存控制&diams; SQL_CACHE: 显式指定存储查询结果于缓存之中&diams; SQL_NO_CACHE: 显式查询结果不予缓存 query_cache_type参数变量：&diams; query_cache_type的值为OFF或0时，查询缓存功能关闭&diams; query_cache_type的值为ON或1时，查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定SQL_NO_CACHE，不予缓存，此为默认值&diams; query_cache_type的值为DEMAND或2时，查询缓存功能按需进行，显式指定SQL_CACHE的SELECT语句才会缓存；其它均不予缓存&diams; 参看：&diams; https://dev.mysql.com/doc/refman/5.7/en/query-cache-configuration.html&diams; https://mariadb.com/kb/en/library/server-system-variables/&diams; #query_cache_type 状态变量&hearts; 查询缓存相关的状态变量 SHOW GLOBAL STATUS LIKE ‘Qcache%’; Qcache_free_blocks：处于空闲状态 Query Cache中内存 Block 数 Qcache_total_blocks：Query Cache 中总Block ，当Qcache_free_blocks相对此值较大时，可能用内存碎片，执行FLUSH QUERY CACHE清理碎片 Qcache_free_memory：处于空闲状态的 Query Cache 内存总量 Qcache_hits：Query Cache 命中次数 Qcache_inserts：向 Query Cache 中插入新的 Query Cache 的次数，即没有命中的次数 Qcache_lowmem_prunes：0记录有多少条查询因为内存不足而被移除出查询缓存 Qcache_not_cached：没有被 Cache 的 SQL 数，包括无法被 Cache 的 SQL 以及由于 query_cache_type 设置的不会被 Cache 的 SQL语句 Qcache_queries_in_cache：在 Query Cache 中的 SQL 数量 命中率估算&hearts; 命中率和内存使用率估算 查询缓存中内存块的最小分配单位query_cache_min_res_unit ：(query_cache_size - Qcache_free_memory) / Qcache_queries_in_cache 查询缓存命中率 ：Qcache_hits / ( Qcache_hits + Qcache_inserts ) * 100% 查询缓存内存使用率：(query_cache_size – qcache_free_memory) / query_cache_size * 100% InnoDB缓冲池&hearts; InnoDB存储引擎的缓冲池: 通常InnoDB存储引擎缓冲池的命中不应该小于99% 查看相关状态变量： show global status like ‘innodb%read%’\G&diams; Innodb_buffer_pool_reads: 表示从物理磁盘读取页的次数&diams; Innodb_buffer_pool_read_ahead: 预读的次数&diams; Innodb_buffer_pool_read_ahead_evicted: 预读页，但是没有读取就从缓冲池中被替换的页数量，一般用来判断预读的效率&diams; Innodb_buffer_pool_read_requests: 从缓冲池中读取页次数&diams; Innodb_data_read: 总共读入的字节数&diams; Innodb_data_reads: 发起读取请求的次数，每次读取可能需要读取多个页 Innodb缓冲池命中率计算：&diams; 示图 平均每次读取的字节数：&diams; 示图 索引索引介绍&hearts; 索引介绍 索引是特殊数据结构：定义在查找时作为查找条件的字段 索引实现在存储引擎 优点：&diams; 索引可以降低服务需要扫描的数据量，减少了IO次数&diams; 索引可以帮助服务器避免排序和使用临时表&diams; 索引可以帮助将随机I/O转为顺序I/O 缺点：&diams; 占用额外空间，影响插入速度 索引类型索引类型介绍&hearts; 索引类型介绍 B+ TREE、HASH、R TREE 聚簇（集）索引、非聚簇索引：数据和索引是否存储在一起 主键索引、二级（辅助）索引 稠密索引、稀疏索引：是否索引了每一个数据项 简单索引、组合索引&diams; 左前缀索引：取前面的字符做索引&diams; 覆盖索引：从索引中即可取出要查询的数据，性能高 B+TREE索引&hearts; B+TREE索引： B+Tree索引：顺序存储，每一个叶子节点到根结点的距离是相同的；左前缀索引，适合查询范围类的数据 可以使用B+TREE索引的查询类型：&diams; 全值匹配：精确所有索引列，如：姓wang，名xiaochun，年龄30&diams; 匹配最左前缀：即只使用索引的第一列，如：姓wang&diams; 匹配列前缀：只匹配一列值开头部分，如：姓以w开头的&diams; 匹配范围值：如：姓ma和姓wang之间&diams; 精确匹配某一列并范围匹配另一列：如：姓wang,名以x开头的&diams; 只访问索引的查询 B+Tree索引的限制：&diams; 如果不从最左列开始，则无法使用索引：如：查找名为xiaochun，或姓为g结尾&diams; 不能跳过索引中的列：如：查找姓wang，年龄30的，只能使用索引第一列&diams; 如果查询中某个列是为范围查询，那么其右侧的列都无法再使用索引：如：姓wang,名x%,年龄30，只能利用姓和名上面的索引 特别提示&diams; 索引列的顺序和查询语句的写法应相匹配，才能更好的利用索引&diams; 为优化性能，可能需要针对相同的列但顺序不同创建不同的索引来满足不同类型的查询需求&diams; 示图1&diams; 示图2 B+Tree与B-tree区别&hearts; B+Tree与B-tree区别 根节点、分支节点、叶子节点&diams; B-tree根节点、分支节点存放数据&diams; B+Tree根节点、分支节点不存放数据，叶子节点存放数据 &diams; B-tree 元数n、分支n+1 &diams; B+Tree 元数个数等于分支个数 &diams; B-tree 各表之间没有链接关系 &diams; B+Tree 各表之间有链接关系 &diams; B-tree 查询效率不稳定 &diams; B+tree 查询效率稳定 Hash索引&hearts; Hash索引介绍 Hash索引：基于哈希表实现，只有精确匹配索引中的所有列的查询才有效，索引自身只存储索引列对应的哈希值和数据指针，索引结构紧凑，查询性能好 Memory存储引擎支持显式hash索引，InnoDB和MyISAM存储引擎不支持 适用场景：只支持等值比较查询，包括=, &lt;=&gt;, IN() 不适合使用hash索引的场景：&diams; 不适用于顺序查询：索引存储顺序的不是值的顺序&diams; 不支持模糊匹配&diams; 不支持范围查询&diams; 不支持部分索引列匹配查找：如A，B列索引，只查询A列索引无效 地理空间索引&hearts; 地理空间索引 地理空间索引（ Geospatial indexing ）：&diams; MyISAM支持地理空间索引，可以使用任意维度组合查询，使用特有的函数访问，常用于做地理数据存储，使用不多&diams; InnoDB从MySQL5.7之后也开始支持 全文索引&hearts; 全文索引 全文索引(FULLTEXT)：&diams; 在文本中查找关键词，而不是直接比较索引中的值，类似搜索引擎&diams; InnoDB从MySQL 5.6之后也开始支持 聚簇和非聚簇索引&hearts; 聚簇和非聚簇索引 示图1 示图2 冗余和重复索引&hearts; 冗余和重复索引介绍 冗余和重复索引：&diams; 冗余索引：（A），（A，B）&diams; 重复索引：已经有索引，再次建立索引 索引优化策略：&diams; 独立地使用列：尽量避免其参与运算，独立的列指索引列不能是表达式的一部分，也不能是函数的参数，在where条件中，始终将索引列单独放在比较符号的一侧&diams; 左前缀索引：构建指定索引字段的左侧的字符数，要通过索引选择性来评估 索引选择性：不重复的索引值和数据表的记录总数的比值&diams; 多列索引：AND操作时更适合使用多列索引，而非为每个列创建单独的索引&diams; 选择合适的索引列顺序：无排序和分组时，将选择性最高放左侧 索引优化建议&hearts; 索引优化建议 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引 尽量使用短索引，如果可以，应该制定一个前缀长度 对于经常在where子句使用的列，最好设置索引 对于有多个列where或者order by子句，应该建立复合索引 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引 尽量不要在列上进行运算（函数操作和表达式操作） 尽量不要使用not in和&lt;&gt;操作 事务并发控制&hearts; 并发控制 死锁&diams; 两个或多个事务在同一资源相互占用，并请求锁定对方占用的资源的状态 事务日志&diams; 事务日志的写入类型为“追加”，因此其操作为“顺序IO”；通常也被称为：预写式日志 write ahead logging&diams; 日志文件： ib_logfile0， ib_logfile1 mysql日志日志类型&hearts; MySql日志类型 事务日志： transaction log 中继日志： reley log 错误日志： error log 通用日志： general log 慢查询日志： slow query log 二进制日志： binary log 事务日志&hearts; 事务日志：transaction log 事务型存储引擎自行管理和使用，建议和数据文件分开存放&diams; redo log&diams; undo log Innodb事务日志相关配置&diams; show variables like ‘%innodb_log%’;&diams; innodb_log_file_size 5242880 每个日志文件大小&diams; innodb_log_files_in_group 2 日志组成员个数&diams; innodb_log_group_home_dir ./ 事务文件路径 日志文件位置&diams; /mydata/data/ib_logfile0&diams; /mydata/data/ib_logfile1 删除表里大量数据但空间不释放忧化&diams; optimize table table; 事务日志和数据文件分开放实现步骤&diams; mkdir -pv /data/mysqllogs ; chown -R mysql.mysql /data/mysqllogs&diams; vim /etc/my.cnf&diams; innodb_log_group_home_dir=/data/mysqllogs 错误日志&hearts; 错误日志 mysqld启动和关闭过程中输出的事件信息 mysqld运行中产生的错误信息 event scheduler运行一个event时产生的日志信息 在主从复制架构中的从服务器上启动从服务器线程时产生的信息 &hearts; 错误日志相关配置 SHOW GLOBAL VARIABLES LIKE ‘log_error’ 错误文件路径：&diams; log_error=/PATH/TO/LOG_ERROR_FILE 是否记录警告信息至错误日志文件&diams; log_warnings=1|0 默认值1 通用日志&hearts; 通用日志 通用日志：记录对数据库的通用操作，包括错误的SQL语句&diams; 文件：file，默认值&diams; 表：table 通用日志相关设置&diams; general_log=ON|OFF&diams; general_log_file=HOSTNAME.log&diams; log_output=TABLE|FILE|NONE 通用日志查看及开启&diams; show variables like ‘general_log’;&diams; set general_log=on; 通用日志更改日志记录位置&diams; show variables like ‘log_output’;&diams; set log_output=”table”; 慢查询日志&hearts; 慢查询日志 慢查询日志：记录执行查询时长超出指定时长的操作&diams; slow_query_log=ON|OFF 开启或关闭慢查询&diams; long_query_time=N 慢查询的阀值，单位秒&diams; slow_query_log_file=HOSTNAME-slow.log 慢查询日志文件&diams; log_slow_filter = admin,filesort,filesort_on_disk,full_join,&diams; full_scan,query_cache,query_cache_miss,tmp_table,tmp_table_on_disk&diams; 上述查询类型且查询时长超过long_query_time，则记录日志&diams; log_queries_not_using_indexes=ON 不使用索引或使用全索引扫描，不论是否达到慢查询阀值的语句是否记录日志，默认OFF，即不记录&diams; log_slow_rate_limit = 1 多少次查询才记录，mariadb特有&diams; log_slow_verbosity= Query_plan,explain 记录内容&diams; log_slow_queries = OFF 同slow_query_log 新版已废弃 慢查询日志：查看与设置&diams; show variables like ‘%slow_query%’;&diams; set global slow_query_log=ON;&diams; vim /etc/my.cnf&diams; slow_query_log=ON 慢查询时间设置&diams; show global like ‘long_query%’;&diams; set global long_query_time=5;&diams; vim /etc/my.cnf&diams; long_query_time=N 慢查询日志存储位置&diams; show global variables like ‘slow_query_log_file’; log_queries_not_using_indexes=ON&diams; 没有利用索引、也记录日志，根具日志、性能优化&diams; show variables like ‘log_queries_not_using_indexes’;&diams; explain sql语句 (判断)&diams; create index idx_age on testlog(age); (创建索引) profiling&diams; 判断语句那个阶段慢&diams; show variables like ‘profiling’&diams; set profiling=on&diams; show profiles;&diams; show profile for query 3; 二进制日志二进制日志介绍&hearts; 二进制日志介绍 记录导致数据改变或潜在导致数据改变的SQL语句 记录已提交的日志 不依赖于存储引擎类型 功能：通过“重放”日志文件中的事件来生成数据副本 详细完整的记录整个过程 注意：建议二进制日志和数据文件分开存放 二进制日志格式&hearts; 二进制日志格式 二进制日志记录三种格式&diams; 基于“语句”记录：statement，记录语句，默认模式&raquo; update students set age=25;&raquo; 基于语句，记录的是一条 &diams; 基于“行”记录：row，记录数据，日志量较大&raquo; update students set age=25;&raquo; 基于行，记录的是所有 &diams; 混合模式：mixed, 让系统自行判定该基于哪种方式进行 格式配置&diams; show variables like ‘binlog_format’;&diams; vim /etc/my.cnf&diams; binlog_format=mixed; 二进制日志服务器变量&hearts; 二进制日志相关的服务器变量： sql_log_bin=ON|OFF：是否记录二进制日志，默认ON log_bin=/PATH/BIN_LOG_FILE：指定文件位置；默认OFF，表示不启用二进制日志功能，上述两项都开启才可 binlog_format=STATEMENT|ROW|MIXED：二进制日志记录的格式，默认STATEMENT max_binlog_size=1073741824：单个二进制日志文件的最大体积，到达最大值会自动滚动，默认为1G sync_binlog=1|0：设定是否启动二进制日志即时同步磁盘功能，默认0，由操作系统负责同步日志到磁盘 expire_logs_days=N：二进制日志可以自动删除的天数。 默认为0，即不自动删除 二进制日志实现&hearts; 二进制日志配置 show variables like ‘sql_log_bin’;&diams; 不用重启服务&diams; set sql_log_bin=OFF; show variables like ‘log_bin’;&diams; 二进制文件名，需重启服务&diams; vim /etc/my.cnf&diams; log-bin=文件名&raquo; log-bin=/data/mysqlbin/mysql-bin&diams; mysql-bin.index 有效的二进制文件名&diams; 初始的大小245字节 二进制日志相关配置&hearts; 二进制日志相关配置 查看mariadb自行管理使用中的二进制日志文件列表，及大小&diams; SHOW {BINARY | MASTER} LOGS 查看使用中的二进制日志文件&diams; SHOW MASTER STATUS 查看二进制文件中的指定内容&diams; SHOW BINLOG EVENTS [IN ‘log_name’] [FROM pos] [LIMIT[offset,] row_count]&diams; show binlog events in ‘mysql-bin.000001’ from 6516 limit 2,3 mysqlbinlog&hearts; mysqlbinlog：二进制日志的客户端命令工具 命令格式： mysqlbinlog [OPTIONS] log_file…&diams; –start-position=# 指定开始位置&diams; –stop-position=#&diams; –start-datetime=&diams; –stop-datetime=&diams; 时间格式：YYYY-MM-DD hh:mm:ss&diams; –base64-output[=name]&diams; 示例123mysqlbinlog --start-position=6787 --stop-position=7527 /var/lib/mysql/mariadb-bin.000003mysqlbinlog --start-datetime="2018-01-30 20:30:10" --stop-datetime="2018-01-30 20:35:22" mariadb-bin.000003mysqlbinlog /data/mysqlbin/mysql-bin.000002 -v &hearts; 二进制日志事件的格式： &hearts; 清除指定二进制日志 PURGE { BINARY | MASTER } LOGS{ TO ‘log_name’ | BEFORE datetime_expr } 示例&diams; PURGE BINARY LOGS TO ‘mariadb-bin.000003’;删除3之前的日志&diams; PURGE BINARY LOGS BEFORE ‘2017-01-23’;&diams; PURGE BINARY LOGS BEFORE ‘2017-03-22 09:25:30’; 删除所有二进制日志，index文件重新记数&diams; RESET MASTER [TO #]; 日志文件从#开始记数，默认从1开始，一般是&diams; master第一次启动时执行，MariaDB10.1.6开始支持TO #&diams; RESET MASTER 切换日志文件&diams; FLUSH LOGS; 事务日志与二进制日志的区别&hearts; 两种类型日志的区别 区别一&diams; 二进制日志不依赖存储引擎&diams; 事务日志依赖存储引擎 区别二&diams; 二进制不覆盖之前的日志&diams; 事务日志覆盖之前的日志 区别三&diams; 二进制日志是完整的事务&diams; 事务日志有不完全的事务 备份和恢复备份和恢复介绍&hearts; 备份和恢复相关内容 为什么要备份&diams; 灾难恢复：硬件故障、软件故障、自然灾害、黑客攻击、误操作测试等数据丢失场景 备份注意要点&diams; 能容忍最多丢失多少数据&diams; 恢复数据需要在多长时间内完成&diams; 需要恢复哪些数据 还原要点&diams; 做还原测试，用于测试备份的可用性&diams; 还原演练 备份时需要考虑的因素&diams; 温备的持锁多久&diams; 备份产生的负载&diams; 备份过程的时长&diams; 恢复过程的时长 备份什么&diams; 数据&diams; 二进制日志、InnoDB的事务日志&diams; 程序代码（存储过程、函数、触发器、事件调度器）&diams; 服务器的配置文件 备份方式cp、tar&hearts; cp, tar cp, tar等复制归档工具：物理备份工具，适用所有存储引擎；只支持冷备；完全和部分备份 第一步： 停掉数据库&diams; /etc/init.d/mysqld stop 第二步： 备份数据&diams; tar -jcvf /mydata/“data_`date +%y%m%d`“.tar.bz2 ./data/ /etc/my.cnf&diams; 备份的时候记得带上配置文件 第三步： 测试 LVM备份&hearts; LVM的快照 LVM的快照：先加锁，做快照后解锁，几乎热备；借助文件系统工具进行备份 数据文件和二进制日志分离 第一步： 锁定表并记录日志位置&diams; mysql -e ‘flush tables with read lock’&diams; mysql -e “show master logs” &gt; /mydata/bin.log 第二步： 创建快照&diams; lvcreate -p r -s -n snap_mysql -L 1G /dev/ 第三步： 释放锁&diams; mysql -e “unlock tables” 第四步： 挂载快照&diams; mount -o nouuid,norecovery /dev/snap_mysql /mnt 第五步： 导出快照里的数据&diams; cp -av /mnt/* /mydat/data 第六步： 卸载并删除快照&diams; umount /mnt&diams; lvremove /dev/vg_date/snap_mysql 第七步： 重新插入新的数据 第八步： 删除数据测试 第九步： 禁止访问，通过二进制更新最新数据&diams; 先禁止数据访问 no-network&diams; 查看备份时的bin_log位置 cat /mydata/bin.log&diams; mysqlbinlog –start-position=位置 mysql-bin.0000* &gt; /root/binlog.sql 第十步： 恢复前先关闭二进制日志&diams; show vaiables like ‘%log_bin%’;&diams; set sql_log_bin=OFF&diams; 当前会话导入数据 source /root/binlog.sql&diams; set sql_log_bin=ON mysqldump介绍&hearts; 逻辑备份工具介绍 逻辑备份工具：mysqldump, mydumper, phpMyAdmin Schema和数据存储在一起、巨大的SQL语句、单个巨大的备份文件 mysqldump工具：客户端命令，通过mysql协议连接至mysql服务器进行备份&diams; mysqldump [OPTIONS] database [tables]&diams; mysqldump [OPTIONS] –B DB1 [DB2 DB3…]&diams; mysqldump [OPTIONS] –A [OPTIONS]&diams; mysqldump参考：&raquo; https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html 常见选项&hearts; mysqldump常见选项 -A， –all-databases 备份所有数据库，含create database -B , –databases db_name… 指定备份的数据库，包括create database语句 -E, –events：备份相关的所有event scheduler -R, –routines：备份所有存储过程和自定义函数 –triggers：备份表相关触发器，默认启用,用–skip-triggers，不备份触发器 –default-character-set=utf8 指定字符集 –compact 去掉注释，适合调试，生产不使用 -d, –no-data 只备份表结构 -t, –no-create-info 只备份数据,不备份create table -n,–no-create-db 不备份create database，可被-A或-B覆盖 –flush-privileges 备份mysql或相关时需要使用 -f, –force 忽略SQL错误，继续执行 –hex-blob 使用十六进制符号转储二进制列（例如，“abc”变为0x616263），受影响的数据类型包括BINARY， VARBINARY，BLOB，BIT -q, –quick 不缓存查询，直接输出，加快备份速度 –master-data[=#]： 此选项须启用二进制日志 (实用)&diams; 所备份的数据之前加一条记录为CHANGE MASTER TO语句，非注释，不指定#，默认为1&diams; 记录为注释的CHANGE MASTER TO语句此选项会自动关闭–lock-tables功能，自动打开-x |–lock-all-tables功能（除非开启–single-transaction） &diams; 示例 &diams; mysqldump -A –master-data=1 &gt; all.sql &diams; mysqldump -A –master-data=2 &gt; all.sql -F, –flush-logs ：备份前滚动日志，锁定表完成后，执行flush logs命令,生成新的二进制日志文件，配合-A 或 -B 选项时，会导致刷新多次数据库。建议在同一时刻执行转储和日志刷新，可通过和–single-transaction或-x，–master-data 一起使用实现，此时只刷新一次日志&diams; mysqldump -F -B hi hellodb2 &gt; all_b.sql&diams; 有几个库刷新几次 方式一 备份不创建库&diams; mysqldump hellodb2 &gt; /data/hellodb2bak.sql&diams; 这种方式还原的时候需要手动创建库 &diams; 还原 &diams; create database hi; &diams; mysql hi &lt; /data/hellodb2bak.sql 注意：这种方式需手动创建库，很多属性会跟之前的库不一致，备份不全面,不推荐使用。 方式二 备份所有数据库&diams; mysqldump -A &gt; /data/mysqlbak.sql 方式三 备份指定数据库&diams; mysqldump -B hellodb2 &gt; /data/hellodb2bak.sql &diams; 还原指定数据库 &diams; mysql &lt; /data/hellodb2bak.sql 方式四 备份加压缩&diams; 备份&diams; mysqldump -B hellodb2 | gzip &gt; /data/hellodb2.sql.gz&diams; mysqldump -B hellodb2 | bzip &gt; /data/hellodb2.sql.bz2&diams; mysqldump -B hellodb2 | xz &gt; /data/hellodb2.sql.xz &diams; 还原 &diams; dz -d /data/hellodb2.sql.xz &diams; mysql &lt; /data/hellodb2.sql 备份脚本MyISAM&hearts; MyISAM备份选项 支持温备；不支持热备，所以必须先锁定要备份的库，而后启动备份操作锁定方法如下：&diams; -x,–lock-all-tables：加全局读锁，锁定所有库的所有表，同时加–single-transaction或–lock-tables选项会关闭此选项功能&diams; 注意：数据量大时，可能会导致长时间无法并发访问数据库&diams; -l,–lock-tables：对于需要备份的每个数据库，在启动备份之前分别锁定其所有表，默认为on,–skip-lock-tables选项可禁用,对备份MyISAM的多个库,可能会造成数据不一致&diams; 注：以上选项对InnoDB表一样生效，实现温备，但不推荐使用 MyISAM建议备份策略12mysqldump –uroot –A –F –E –R –x --master-data=1 --flush-privileges --triggers --default-character-set=utf8 --hex-blob&gt;$ BACKUP /fullbak_$BACKUP_TIME.sql InnoDB&hearts; InnoDB备份选项 支持热备，可用温备但不建议用&diams; –single-transaction&diams; 此选项Innodb中推荐使用，不适用MyISAM，此选项会开始备份前，先执行START TRANSACTION指令开启事务&diams; 此选项通过在单个事务中转储所有表来创建一致的快照。 仅适用于存储在支持多版本控制的存储引擎中的表（目前只有InnoDB可以）; 转储不保证与其他存储引擎保持一致。 在进行单事务转储时，要确保有效的转储文件（正确的表内容和二进制日志位置），没有其他连接应该使用以下语句：ALTER TABLE，DROP TABLE，RENAME TABLE，TRUNCATE TABLE&diams; 此选项和–lock-tables（此选项隐含提交挂起的事务）选项是相互排斥&diams; 备份大型表时，建议将–single-transaction选项和–quick结合一起使用 InnoDB建议备份策略 12mysqldump –uroot –A –F –E –R --single-transaction --master-data=1 --flush-privileges --triggers --default-character-set=utf8 --hex-blob&gt;$ BACKUP /fullbak_$BACKUP_TIME.sql 可实际操作 123mysqldump -uroot -A -F --single-transaction --master-data=2 --hexo-blob | gzip &gt; $BACKUP/fullbak_$BACKUP_TIME.sql.gz# 如果是大表 可以加 --quick -f# 热备过程中如果有DDL操作，会导致备份结果有问题 备份实例完全备份&hearts; 完全备份，恢复至最新状态 数据文件跟二进制日志应在不同的设备上 第一步&diams; 完全备份 1mysqldump -A -F --single-transaction --master-data=2 | gzip &gt; /data/all.sql.gz &diams; 二进制可以加 –hex-blob&diams; 备份之后在增加新的数据 第二步&diams; 模拟破坏&diams; systemctl stop mariadb&diams; rm -rf /var/lib/mysql/* 第三步&diams; bzip -d all.sql.gz&diams; 还原时禁止用户访问数据&diams; systemctl start mariadb&diams; set sql_log_bin=off;&diams; source /data/all.sql 第四步&diams; 还原至最新状态&diams; grep “CHANGE MASTER” /data/all.sql&diams; cd /data/&diams; mysqlbin –start-position=245 mysql-bin.000002 &gt; /data/incr.sql&diams; mysqlbin mysql-bin.000003 &gt; /data/incr.sql&diams; mysqlbin mysql-bin.000004 &gt; /data/incr.sql &diams; mysql&diams; set sql_log_bin=off;&diams; source /data/incr.sql;&diams; set sql_log_bin=on; 第五步&diams; 开放用户访问数据库 误删故障xtrabackup介绍&hearts; xtrabackup介绍 Percona&diams; 官网：www.percona.com&diams; percona-server&diams; InnoDB –&gt; XtraDB Xtrabackup&diams; percona提供的mysql数据库备份工具，惟一开源的能够对innodb和xtradb数据库进行热备的工具&diams; 手册：&diams; https://www.percona.com/doc/percona-xtrabackup/LATEST/index.html 特点：&diams; 备份还原过程快速、可靠&diams; 备份过程不会打断正在执行的事务&diams; 能够基于压缩等功能节约磁盘空间和流量&diams; 自动实现备份检验&diams; 开源，免费 Xtrabackup2.2版之前包括4个可执行文件：&diams; innobackupex: Perl 脚本&diams; xtrabackup: C/C++ 编译的二进制&diams; xbcrypt: 加解密&diams; xbstream: 支持并发写的流文件格式 xtrabackup 是用来备份 InnoDB 表的，不能备份非 InnoDB 表，和 MySQLServer 没有交互 innobackupex 脚本用来备份非 InnoDB 表，同时会调用 xtrabackup 命令来备份 InnoDB 表，还会和 MySQL Server 发送命令进行交互，如加全局读锁（FTWRL）、获取位点（SHOW SLAVE STATUS）等。即innobackupex是在xtrabackup 之上做了一层封装实现的 虽然目前一般不用 MyISAM 表，只是 MySQL 库下的系统表是 MyISAM 的，因此备份基本都通过 innobackupex 命令进行 xtrabackup版本升级到2.4后，相比之前的2.1有了比较大的变化：innobackupex 功能全部集成到 xtrabackup 里面，只有一个 binary程序，另外为了兼容考虑，innobackupex作为 xtrabackup 的软链接，即xtrabackup现在支持非Innodb表备份，并且Innobackupex在下一版本中移除，建议通过xtrabackup替换innobackupex xtrabackup安装：&diams; yum install percona-xtrabackup 在EPEL源中&diams; 最新版本下载安装：&diams; https://www.percona.com/downloads/XtraBackup/LATEST/ 使用&hearts; Xtrabackup用法 备份：innobackupex [option] BACKUP-ROOT-DIR 选项说明&diams; –user：该选项表示备份账号&diams; –password：该选项表示备份的密码&diams; –host：该选项表示备份数据库的地址&diams; –databases：该选项接受的参数为数据库名，如果要指定多个数据库，彼此间需要以空格隔开；如：”xtra_test dba_test”，同时，在指定某数据库时，也可以只指定其中的某张表。如：”mydatabase.mytable”。该选项对innodb引擎表无效，还是会备份所有innodb表&diams; –defaults-file：该选项指定从哪个文件读取MySQL配置，必须放在命令行第一个选项位置&diams; –incremental：该选项表示创建一个增量备份，需要指定–incremental-basedir&diams; –incremental-basedir：该选项指定为前一次全备份或增量备份的目录，与–incremental同时使用&diams; –incremental-dir：该选项表示还原时增量备份的目录&diams; –include=name：指定表名，格式：databasename.tablename&diams; https://www.percona.com/doc/percona-xtrabackup/LATEST/genindex.html Prepare：innobackupex –apply-log [option] BACKUP-DIR&diams; –apply-log：一般情况下,在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或已经提交但尚未同步至数据文件中的事务。因此，此时数据文件仍处理不一致状态。此选项作用是通过回滚未提交的事务及同步已经提交的事务至数据文件使数据文件处于一致性状态&diams; –use-memory：和–apply-log选项一起使用，当prepare 备份时，做crashrecovery分配的内存大小，单位字节，也可1MB,1M,1G,1GB等，推荐1G&diams; –export：表示开启可导出单独的表之后再导入其他Mysql中&diams; –redo-only：此选项在prepare base full backup，往其中合并增量备份时候使用，但不包括对最后一个增量备份的合并 还原：innobackupex –copy-back [选项] BACKUP-DIR&diams; innobackupex –move-back [选项] [–defaults-group=GROUP-NAME]BACKUP-DIR&diams; 选项说明：&diams; –copy-back：做数据恢复时将备份数据文件拷贝到MySQL服务器的datadir&diams; –move-back：这个选项与–copy-back相似，唯一的区别是它不拷贝文件，而是移动文件到目的地。这个选项移除backup文件，用时候必须小心。使用场景：没有足够的磁盘空间同事保留数据文件和Backup副本 还原注意事项&diams; datadir目录必须为空。除非指定innobackupex –force-non-empty-directorires选项指定，否则–copy-backup选项不会覆盖&diams; 在restore之前,必须shutdown MySQL实例，不能将一个运行中的实例restore到datadir目录中&diams; 由于文件属性会被保留，大部分情况下需要在启动实例之前将文件的属主改为mysql，这些文件将属于创建备份的用户chown -R mysql:mysql /data/mysql以上需要在用户调用innobackupex之前完成–force-non-empty-directories：指定该参数时候，使得innobackupex –copy-back或–move-back选项转移文件到非空目录，已存在的文件不会被覆盖。如果–copy-back和–move-back文件需要从备份目录拷贝一个在datadir已经存在的文件，会报错失败 使用innobakupex备份时，其会调用xtrabackup备份所有的InnoDB表，复制所有关于表结构定义的相关文件(.frm)、以及MyISAM、MERGE、CSV和ARCHIVE表的相关文件，同时还会备份触发器和数据库配置信息相关的文件。这些文件会被保存至一个以时间命名的目录中,在备份时，innobackupex还会在备份目录中创建如下文件&diams; xtrabackup_info：innobackupex工具执行时的相关信息，包括版本，备份选项，备份时长，备份LSN(log sequence number日志序列号)，BINLOG的位置&diams; xtrabackup_checkpoints：备份类型（如完全或增量）、备份状态（如是否已经为prepared状态）和LSN范围信息,每个InnoDB页(通常为16k大小)都会包含一个日志序列号，即LSN。LSN是整个数据库系统的系统版本号，每个页面相关的LSN能够表明此页面最近是如何发生改变的&diams; xtrabackup_binlog_info：MySQL服务器当前正在使用的二进制日志文件及至备份这一刻为止二进制日志事件的位置，可利用实现基于binlog的恢复&diams; backup-my.cnf：备份命令用到的配置选项信息&diams; xtrabackup_logfile：备份生成的日志文件 完全备份&hearts; Xtrabackup实现完全备份 热备份 完全备份&diams; xtrabackup –backup –target-dir=/backups 还原&diams; 空的数据库&diams; xtrabackup –prepare –target-dir=/backups&diams; xtrabackup –copy-back –target-dir=/backups 新版完全&hearts; 新版Xtrabackup完全备份及还原 第一步 在原主机上 在原主机做完全备份到/data/backups&diams; 示例12xtrabackup --backup --target-dir=/backups/scp -r /backups/* 目标主机:/backups 第二步 在目标主机上 预准备：确保数据一致，提交完成的事务，回滚未完成的事务&diams; 示例 1xtrabackup --prepare --target-dir=/backups/ 复制到数据库目录&diams; 注意：数据库目录必须为空，MySQL服务不能启动&diams; 示例 1xtrabackup --copy-back --target-dir=/backups/ 还原属性&diams; 示例 1chown -R mysql:mysql /var/lib/mysql 启动服务&diams; 示例1systemctl start mariadb 旧版完全&hearts; 旧版Xtrabackup完全备份及还原 第一步 &diams; 在原主机 12innobackupex --user=root /backupsscp -r /backups/2018-02-23_11-55-57/ 目标主机:/data/ 第二步 &diams; 在目标主机 123456innobackupex --apply-log /data/2018-02-23_11-55-57/systemctl stop mariadbrm -rf /var/lib/mysql/*innobackupex --copy-back /data/2018-02-23_11-55-57/chown -R mysql.mysql /var/lib/mysql/systemctl start mariadb 增量备份&hearts; Xtrabackup实现增量备份 热备份 备份过程&diams; 完全备份：xtrabackup –backup –target-dir=/backups/base &diams; 第一次修改数据 &diams; 第一次增量备份 &diams; 示例 1xtrabackup --backup --target-dir=/backups/inc1 --incremental-basedir=/backups/base &diams; 第二次修改数据 &diams; 第二次增量 &diams; 示例 1xtrabackup --backup --target-dir=/backups/inc2 --incremental-basedir=/backups/inc1 &diams; scp -r /backups/* 目标主机:/backups/ &diams; 备份过程生成三个备份目录 &diams; /backups/{base，inc1，inc2} 还原过程&diams; 第一步: xtrabackup -prepare –apply-log-only –target-dir=/backups/base &diams; 第二步：xtrabackup -prepare –apply-log-only –target-dir=/backups/base –incremental-dir=/backups/inc1 &diams; 第三步：xtrabackup -prepare –target-dir=/backups/base –incremental-dir=/backups/inc2 &diams; –apply-log-only 参数除了最后一次，其余的都必须加 执行恢复&diams; xtrabackup –copy-back –target-dir=/data/backups/base 单表备份&hearts; xtrabackup 实现单表备份 第一步： 单表备份 1innobackupex --include='hellodb.students' /backups 第二步： 备份表结构 1mysql -e 'show create table hellodb.students' &gt; student.sql 第三步： 删除表 1mysql -e 'drop table hellodb.students‘ 第四步： 导出表 1innobackupex --apply-log --export /backups/2018-02-23_15-03-23/ 第五步：创建表&diams; 另一台机器 123456789mysql&gt;CREATE TABLE `students` (`StuID` int(10) unsigned NOT NULL AUTO_INCREMENT,`Name` varchar(50) NOT NULL,`Age` tinyint(3) unsigned NOT NULL,`Gender` enum('F','M') NOT NULL,`ClassID` tinyint(3) unsigned DEFAULT NULL,`TeacherID` int(10) unsigned DEFAULT NULL,PRIMARY KEY (`StuID`)) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8 第六步：删除表空间 1alter table students discard tablespace; 第七步：复制表 1cp /backups/2018-02-23_15-03-23/hellodb/students.&#123;cfg,exp,ibd&#125;/var/lib/mysql/hellodb/ 第八步： 赋予权限 1chown -R mysql.mysql /var/lib/mysql/hellodb/ 第九步： 更新表 1mysql&gt;alter table students import tablespace; mysql集群相关概念&hearts; 相关概念 扩展方式：&diams; Scale Up (提升服务器性能)&diams; Scale Out （集群） MySQL的扩展&diams; 读写分离&diams; 复制：每个节点都有相同的数据集&diams; 向外扩展&diams; 二进制日志&diams; 单向 复制的功用&diams; 数据分布&diams; 负载均衡读&diams; 备份&diams; 高可用和故障切换&diams; MySQL升级测试 读写分离应用 mysql-proxy：Oracle&diams; https://downloads.mysql.com/archives/proxy/ Atlas：Qihoo&diams; https://github.com/Qihoo360/Atlas/blob/master/README_ZH.md dbproxy：美团&diams; https://github.com/Meituan-Dianping/DBProxy Cetus：网易乐得&diams; https://github.com/Lede-Inc/cetus Amoeba：&diams; https://sourceforge.net/projects/amoeba/ mysql复制模型一主一从&hearts; 一主一从模型 示图 一主多从&hearts; 一主多从模型 示图 主从复制原理&hearts; 主从复制原理 示图 垂直分区&hearts; MySQL垂直分区 示图 水平分片&hearts; MySQL水平分片（Sharding） 示图 &hearts; 对应shard中查询相关数据 示图 主从复制实现相关介绍&hearts; 相关介绍 主从复制线程&diams; 主节点&diams; dump Thread：为每个Slave的I/O Thread启动一个dump线程，用于向其发送binary log events &diams; 从节点 &diams; I/O Thread：向Master请求二进制日志事件，并保存于中继日志中 &diams; SQL Thread：从中继日志中读取日志事件，在本地完成重放 跟复制功能相关的文件&diams; master.info：用于保存slave连接至master时的相关信息，例如账号、密码、服务器地址等&diams; relay-log.info：保存在当前slave节点上已经复制的当前二进制日志和本地replay log日志的对应关系 主从复制特点&diams; 异步复制 (服务器单方面确认、返回结果)&diams; 主从数据不一致比较常见 复制架构&diams; Master/Slave, Master/Master, 环状复制&diams; 一主多从&diams; 从服务器还可以再有从服务器&diams; 一从多主:适用于多个不同数据库&diams; 示图 复制需要考虑二进制日志事件记录格式&diams; STATEMENT（5.0之前）&diams; ROW（5.1之后，推荐）&diams; MIXED 主从复制配置&hearts; 主从复制配置 主从配置过程：可参看官网&diams; https://mariadb.com/kb/en/library/setting-up-replication/&diams; https://dev.mysql.com/doc/refman/5.5/en/replication-configuration.html 主节点&hearts; 主节点配置 第一步&diams; 启用二进制日志&diams; [mysqld]&diams; log_bin 第二步&diams; 为当前节点设置一个全局惟一的ID号&diams; [mysqld]&diams; server_id=#&diams; log-basename=master 可选项，设置datadir中日志名称，确保不依赖主机名 第三步&diams; 创建有复制权限的用户账号&diams; GRANT REPLICATION SLAVE ON *.* TO ‘repluser‘@’HOST’ IDENTIFIED BY’replpass’; 从节点&hearts; 从节点配置 第一步&diams; 启动中继日志&diams; [mysqld]&diams; server_id=#&diams; relay_log=relay-log relay log的文件路径，默认值hostname-relay-bin&diams; relay_log_index=relay-log.index 默认值 hostname -relay-bin.index&diams; read_only=ON 第二步&diams; 使用有复制权限的用户账号连接至主服务器，并启动复制线程&diams; mysql&gt; CHANGE MASTER TO MASTER_HOST=’host’,MASTER_USER=’repluser’, MASTER_PASSWORD=’replpass’,MASTER_LOG_FILE=’mysql-bin.xxxxx’, MASTER_LOG_POS=#; &diams; mysql&gt; START SLAVE [IO_THREAD|SQL_THREAD]; 提升从节点&hearts; 主节点宏机、提升节点 查看同步的信息、挑选节点&diams; cat master.info 第一步：&diams; stop slave; 第二步：&diams; reset slave all; 第三步：&diams; vim /etc/my.cnf&diams; #read_only&diams; log_bin(开启) 第四步：&diams; 重启数据库，检查二进制日志是否开启 第五步：&diams; select user,host,password from mysql.user;&diams; 创建用户 第六步：&diams; 为从节点指定新的主服务器&diams; stop slave;&diams; reset all slave;&diams; change master to 新主数据 级联复制&hearts; master –&gt; slave1 –&gt; slave2,slave3 第一步：&diams; slave1 启动二进制日志&diams; log_slave_updates=ON; 中间服务器关键选项 第二步：&diams; slave2上&diams; stop slave;&diams; reset all slave;&diams; change master to slave1&diams; start slave; 综合&diams; 中间服务器错误，会导致后续复制失败&diams; stop slave;&diams; set global sql_slave_skip_counter=1;&diams; 找出报错根源 相关总结&hearts; 相关内容总结 如果主节点已经运行了一段时间，且有大量数据时，如何配置并启动slave节点&diams; 通过备份恢复数据至从服务器&diams; 复制起始位置为备份时，二进制日志文件及其POS 如果要启用级联复制,需要在从服务器启用以下配置&diams; [mysqld]&diams; log_bin&diams; log_slave_updates 复制架构中应该注意的问题： 第一：&diams; 限制从服务器为只读&diams; 在从服务器上设置read_only=ON&diams; 注意：此限制对拥有SUPER权限的用户均无效&diams; 阻止所有用户, 包括主服务器复制的更新&diams; mysql&gt; FLUSH TABLES WITH READ LOCK; 第二：&diams; 在从服务器清除master.info ，relay-log.info, relay log ，开始新的relaylog ,注意：需要先STOP SLAVE&diams; RESET SLAVE ALL 清除所有从服务器上设置的主服务器同步信息如：PORT, HOST, USER和 PASSWORD 等 第三：&diams; sql_slave_skip_counter = N 从服务器忽略几个主服务器的复制事件，global变量 第四：&diams; 保证主从复制的事务安全&diams; 参看https://mariadb.com/kb/en/library/server-system-variables/&diams; 在master节点启用参数：&diams; sync_binlog=1 每次写后立即同步二进制日志到磁盘，性能差&diams; 如果用到的为InnoDB存储引擎：&diams; innodb_flush_log_at_trx_commit=1 每次事务提交立即同步日志写磁盘&diams; innodb_support_xa=ON 默认值，分布式事务MariaDB10.3.0废除&diams; sync_master_info=# #次事件后master.info同步到磁盘 &diams; 在slave节点启用服务器选项： &diams; 在slave节点启用参数： &diams; sync_relay_log=# #次写后同步relay log到磁盘 &diams; sync_relay_log_info=# #次事务后同步relay-log.info到磁盘 &diams; skip_slave_start=ON 不自动动slave 主主复制&hearts; 主主复制：互为主从 容易产生的问题：数据不一致；因此慎用 考虑要点：自动增长id 配置一个节点使用奇数id&diams; auto_increment_offset=1 开始点&diams; auto_increment_increment=2 增长幅度 另一个节点使用偶数id&diams; auto_increment_offset=2&diams; auto_increment_increment=2 主主复制的配置步骤：&diams; 各节点使用一个惟一server_id&diams; 都启动binary log和relay log&diams; 创建拥有复制权限的用户账号&diams; 定义自动增长id字段的数值范围各为奇偶&diams; 均把对方指定为主节点，并启动复制线程 半同步复制半同步复制介绍&hearts; 半同步复制介绍 默认情况下，MySQL的复制功能是异步的，异步复制可以提供最佳的性能，主库把binlog日志发送给从库即结束，并不验证从库是否接收完毕。这意味着当主服务器或从服务器端发生故障时，有可能从服务器没有接收到主服务器发送过来的binlog日志，这就会造成主服务器和从服务器的数据不一致，甚至在恢复时造成数据的丢失 从服务器同步成功，返回用户 同步超时，返回用户 半同步复制实现&hearts; 半同步复制实现 主服务器配置: 123456789#安装插件mysql&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME'semisync_master.so';#开启插件、配置文件也需修改mysql&gt; SET GLOBAL rpl_semi_sync_master_enabled=1;#设置超时时长mysql&gt; SET GLOBAL rpl_semi_sync_master_timeout = 1000;超时长为1s #查看相关变量mysql&gt; SHOW GLOBAL VARIABLES LIKE '%semi%';mysql&gt; SHOW GLOBAL STATUS LIKE '%semi%‘; 从服务器配置: 1234567mysql&gt; INSTALL PLUGIN rpl_semi_sync_slave SONAME'semisync_slave.so';mysql&gt; SET GLOBAL rpl_semi_sync_slave_enabled=1;#查看状态mysql&gt; SHOW GLOBAL STATUS LIKE '%semi%';#如果为offmysql&gt; stop slave;mysql&gt; start slave; 复制过滤器&hearts; 复制过滤器 让从节点仅复制指定的数据库，或指定数据库的指定表 两种实现方式：&diams; 服务器选项：主服务器仅向二进制日志中记录与特定数据库相关的事件注意：此项和binlog_format相关参看：https://mariadb.com/kb/en/library/mysqld-options/#-binlog-ignore-dbbinlog_do_db = 数据库白名单列表，多个数据库需多行实现binlog_do_db = hellodbbinlog_ignore_db = 数据库黑名单列表问题：基于二进制还原将无法实现；不建议使用 &diams; 从服务器SQL_THREAD在replay中继日志中的事件时，仅读取与特定数据库(特定表)相关的事件并应用于本地问题：会造成网络及磁盘IO浪费 从服务器上的复制过滤器相关变量&diams; replicate_do_db= 指定复制库的白名单&diams; set global replicate_do_db=”hellodb”; &diams; replicate_ignore_db= 指定复制库黑名单 &diams; replicate_do_table= 指定复制表的白名单 &diams; replicate_ignore_table= 指定复制表的黑名单 &diams; replicate_wild_do_table= foo%.bar% 支持通配符 &diams; replicate_wild_ignore_table= 注意主服务器要切换到对应的库里修改表 MySQL复制加密加密码介绍&hearts; MySQL复制加密 基于SSL复制：&diams; 在默认的主从复制过程或远程连接到MySQL/MariaDB所有的链接通信中的数据都是明文的，外网里访问数据或则复制，存在安全隐患。通过SSL/TLS加密的方式进行复制的方法，来进一步提高数据的安全性 配置介绍：&diams; 主服务器开启SSL：[mysqld] 加一行ssl&diams; 主服务器配置证书和私钥；并且创建一个要求必须使用SSL连接的复制账号&diams; 从服务器使用CHANGER MASTER TO 命令时指明ssl相关选项&diams; 参看：&diams; https://mariadb.com/kb/en/library/replication-with-secure-connections/ 加密实现&hearts; MySQL复制加密实现 Master服务器配置 123456789[mysqld]log-binserver_id=1sslssl-ca=/etc/my.cnf.d/ssl/cacert.pemssl-cert=/etc/my.cnf.d/ssl/master.crtssl-key=/etc/my.cnf.d/ssl/master.keygrant replicate slave on *.* to user@'192.168.11.%' identified by 'centos' require ssl; Slave服务器配置 1234567891011121314mysql --ssl-ca=/etc/my.cnf.d/ssl/cacert.pem --ssl-cert=/etc/my.cnf.d/ssl/slave.crt --ssl-key=/etc/my.cnf.d/ssl/slave.key -uuser -pcentos -h 192.168.11.10mysql&gt;CHANGE MASTER TOMASTER_HOST='MASTERIP',MASTER_USER='rep',MASTER_PASSWORD='centos',MASTER_LOG_FILE='mariadb-bin.000001',MASTER_LOG_POS=245,MASTER_SSL=1,MASTER_SSL_CA = '/etc/my.cnf.d/ssl/cacert.pem',MASTER_SSL_CERT = '/etc/my.cnf.d/ssl/slave.crt',MASTER_SSL_KEY = '/etc/my.cnf.d/ssl/slave.key'; 复制的监控和维护&hearts; 复制的监控和维护 清理日志&diams; PURGE { BINARY | MASTER } LOGS { TO ‘log_name’ | BEFORE datetime_expr }&diams; RESET MASTER&diams; RESET SLAVE 复制监控&diams; SHOW MASTER STATUS&diams; SHOW BINLOG EVENTS&diams; SHOW BINARY LOGS&diams; SHOW SLAVE STATUS&diams; SHOW PROCESSLIST 从服务器是否落后于主服务&diams; Seconds_Behind_Master: 0 如何确定主从节点数据是否一致&diams; percona-tools 数据不一致如何修复&diams; 删除从数据库，重新复制 MySQL高可用产品高可用产品类型&hearts; MySQL高可用介绍 MMM: Multi-Master Replication Manager for MySQL，Mysql主主复制管理器是一套灵活的脚本程序，基于perl实现，用来对mysql replication进行监控和故障迁移，并能管理mysql Master-Master复制的配置(同一时间只有一个节点是可写的)官网： http://www.mysql-mmm.orghttps://code.google.com/archive/p/mysql-master-master/downloads MHA： Master High Availability，对主节点进行监控，可实现自动故障转移至其它从节点；通过提升某一从节点为新的主节点，基于主从复制实现，还需要客户端配合实现，目前MHA主要支持一主多从的架构，要搭建MHA,要求一个复制集群中必须最少有三台数据库服务器，一主二从，即一台充当master，一台充当备用master，另外一台充当从库，出于机器成本的考虑，淘宝进行了改造，目前淘宝TMHA已经支持一主一从官网:https://code.google.com/archive/p/mysql-master-ha/ Galera Cluster：wsrep(MySQL extended with the Write Set Replication)通过wsrep协议在全局实现复制；任何一节点都可读写，不需要主从复制，实现多主读写 MHA集群架构工作原理&hearts; MHA工作原理 从宕机崩溃的master保存二进制日志事件（binlog events） 识别含有最新更新的slave 应用差异的中继日志（relay log）到其他的slave 应用从master保存的二进制日志事件（binlog events） 提升一个slave为新的master 使其他的slave连接新的master进行复制 安装&hearts; MHA安装 MHA软件由两部分组成，Manager工具包和Node工具包 Manager工具包主要包括以下几个工具：&diams; masterha_check_ssh 检查MHA的SSH配置状况&diams; masterha_check_repl 检查MySQL复制状况&diams; masterha_manger 启动MHA&diams; masterha_check_status 检测当前MHA运行状态&diams; masterha_master_monitor 检测master是否宕机&diams; masterha_master_switch 故障转移（自动或手动）&diams; masterha_conf_host 添加或删除配置的server信息 Node工具包：这些工具通常由MHA Manager的脚本触发，无需人为操作）主要包括以下几个工具：&diams; save_binary_logs 保存和复制master的二进制日志&diams; apply_diff_relay_logs 识别差异的中继日志事件并将其差异的事件应用于其他的slave&diams; filter_mysqlbinlog 去除不必要的ROLLBACK事件（MHA已不再使用此工具）&diams; purge_relay_logs 清除中继日志（不会阻塞SQL线程）&diams; 注意：为了尽可能的减少主库硬件损坏宕机造成的数据丢失，因此在配置MHA的同时建议配置成MySQL 5.5的半同步复制 自定义扩展：&diams; secondary_check_script： 通过多条网络路由检测master的可用性&diams; master_ip_ailover_script： 更新Application使用的masterip&diams; shutdown_script： 强制关闭master节点&diams; report_script： 发送报告&diams; init_conf_load_script： 加载初始配置参数&diams; master_ip_online_change_script：更新master节点ip地址 配置文件：&diams; global配置，为各application提供默认配置&diams; application配置：为每个主从复制集群 实现MHA&hearts; 虚拟机实现MHA 规划&diams; 4台 centos7虚拟机&diams; 1台管理机&diams; 1台master&diams; 2台slave&diams; 关闭防火墙、selinux 第一步：&diams; 免密钥登陆 123ssh-keygen -t rsa ssh-keycop -i 本机ssh -r /root/.ssh/ 到目标主机 第二步：&diams; 在管理节点上安装两个包：&diams; mha4mysql-manager&diams; mha4mysql-node &diams; 在被管理节点安装： &diams; mha4mysql-node 第三步：&diams; 在管理节点建立配置文件 1234567891011121314151617181920vim /etc/mastermha/app1.cnf[server default]user=mhauserpassword=fang#自动生成manager_workdir=/data/mastermha/app1/manager_log=/data/mastermha/app1/manager.logremote_workdir=/data/mastermha/app1/ssh_user=rootrepl_user=repluserrepl_password=fangping_interval=1[server1]hostname=192.168.8.17candidate_master=1[server2]hostname=192.168.8.27candidate_master=1[server3]hostname=192.168.8.37 第四步：&diams; 实现Master 123456789vim /etc/my.cnf[mysqld]log-binserver_id=1skip_name_resolve=1mysql&gt;show master logsmysql&gt;grant replication slave on *.* to repluser@'192.168.8.%' identifiedby ‘magedu';mysql&gt;grant all on *.* to mhauser@'192.168.8.%’identified by ‘fang'; 第五步：&diams; 实现slave 12345678910vim /etc/my.cnf[mysqld]server_id=2 #不同节点此值各不相同log-binread_onlyrelay_log_purge=0skip_name_resolve=1mysql&gt;CHANGE MASTER TO MASTER_HOST=‘MASTER_IP',MASTER_USER='repluser', MASTER_PASSWORD=‘fang',MASTER_LOG_FILE='mariadb-bin.000001', MASTER_LOG_POS=245; 第六步&diams; 检查&diams; 在所有节点实现相互之间ssh key验证&diams; Mha验证和启动 &diams; 检测ssh &diams; masterha_check_ssh –conf=/etc/mastermha/app1.cnf &diams; 检测账号 &diams; masterha_check_repl –conf=/etc/mastermha/app1.cnf &diams; 启用MHA &diams; masterha_manager –conf=/etc/mastermha/app1.cnf &diams; 前台执行、需守护进程 &diams; 排错日志： &diams; /data/mastermha/app1/manager.log 第七步&diams; 模拟测试&diams; 大量写过程中&diams; pkill mysqld&diams; 查看日志&diams; 去掉新主服务器的read_only选项 Galera Cluster介绍&hearts; Galera Cluster介绍 Galera Cluster：集成了Galera插件的MySQL集群，是一种新型的，数据不共享的，高度冗余的高可用方案，目前Galera Cluster有两个版本，分别是Percona Xtradb Cluster及MariaDB Cluster，Galera本身是具有多主特性的，即采用multi-master的集群架构，是一个既稳健，又在数据一致性、完整性及高性能方面有出色表现的高可用解决方案 多主架构：真正的多点读写的集群，在任何时候读写数据，都是最新的 同步复制：集群不同节点之间数据同步，没有延迟，在数据库挂掉之后，数据不会丢失 并发复制：从节点APPLY数据时，支持并行执行，更好的性能 故障切换：在出现数据库故障时，因支持多点写入，切换容易 热插拔：在服务期间，如果数据库挂了，只要监控程序发现的够快，不可服务时间就会非常少。在节点故障期间，节点本身对集群的影响非常小 自动节点克隆：在新增节点，或者停机维护时，增量数据或者基础数据不需要人工手动备份提供，Galera Cluster会自动拉取在线节点数据，最终集群会变为一致 对应用透明：集群的维护，对应用程序是透明的 Galera Cluster包括两个组件&diams; Galera replication library (galera-3)&diams; WSREP：MySQL extended with the Write Set Replication WSREP复制实现：&diams; percona-cluster&diams; MariaDB-Cluster Galera Cluster官方文档：&diams; 地址http://galeracluster.com/documentation-webpages/galera-documentation.pdfhttp://galeracluster.com/documentation-webpages/index.htmlhttps://mariadb.com/kb/en/mariadb/getting-started-with-mariadb-galera-cluster/ 注意：都至少需要三个节点，不能安装mariadb-server 实现&hearts; MariaDB-Cluster实现 第一步&diams; 配置epel源&diams; yum install MariaDB-Galera-server 第二步&diams; 修改配置文件&diams; vim /etc/my.cnf.d/server.cnf 1234567891011wsrep_provider = /usr/lib64/galera/libgalera_smm.sowsrep_cluster_address="gcomm://192.168.8.7,192.168.8.17,192.168.8.27"binlog_format=rowdefault_storage_engine=InnoDBinnodb_autoinc_lock_mode=2bind-address=0.0.0.0#下面配置可选项wsrep_cluster_name = ‘mycluster‘默认my_wsrep_clusterwsrep_node_name = 'node1'wsrep_node_address = ‘192.168.8.7' &diams; 复制配置文件到对应的节点 第三步&diams; 首次启动时，需要初始化集群，在其中一个节点上执行命令&diams; /etc/init.d/mysql start –wsrep-new-cluster 第四步&diams; 而后正常启动其它节点&diams; service mysql start 第五步&diams; 查看集群中相关系统变量和状态变量&diams; SHOW VARIABLES LIKE ‘wsrep_%‘;&diams; SHOW STATUS LIKE ‘wsrep_%‘;&diams; SHOW STATUS LIKE ‘wsrep_cluster_size‘; 性能衡量指标mysqlslap&hearts; mysqlslap介绍 Mysqlslap：来自于mariadb包，测试的过程默认生成一个mysqlslap的schema,生成测试表t1，查询和插入测试数据，mysqlslap库自动生成，如果已经存在则先删除。用–only-print来打印实际的测试过程，整个测试完成后不会在数据库中留下痕迹 使用格式：mysqlslap [options] 常用参数 [options] 说明：&diams; –auto-generate-sql, -a 自动生成测试表和数据，表示用mysqlslap工具自己生成的SQL脚本来测试并发压力&diams; –auto-generate-sql-load-type=type 测试语句的类型。代表要测试的环境是读操作还是写操作还是两者混合的。取值包括：read，key，write，update和mixed(默认)&diams; –auto-generate-sql-add-auto-increment 代表对生成的表自动添加auto_increment列，从5.1.18版本开始支持&diams; –number-char-cols=N, -x N 自动生成的测试表中包含多少个字符类型的列，默认1&diams; –number-int-cols=N, -y N 自动生成的测试表中包含多少个数字类型的列，默认1&diams; –number-of-queries=N 总的测试查询次数(并发客户数×每客户查询次数)&diams; –query=name,-q 使用自定义脚本执行测试，例如可以调用自定义的存储过程或者sql语句来执行测试&diams; –create-schema 代表自定义的测试库名称，测试的schema&diams; –commint=N 多少条DML后提交一次 mysqlslap实例 测试同时不同的存储引擎的性能进行对比&diams; mysqlslap -a –concurrency=50,100 –number-of-queries 1000 –iterations=5 –engine=myisam,innodb –debug-info -uroot -pcentos 执行一次测试，分别50和100个并发，执行1000次总查询&diams; mysqlslap -a –concurrency=50,100 –number-of-queries 1000 –debug-info -uroot -pcentos]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运维自动化之ansible]]></title>
    <url>%2F2018%2F09%2F20%2F%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B9%8BANSIBLE%2F</url>
    <content type="text"><![CDATA[自动化运维工具自动化运维工具分类&hearts; 不同规模的自动化运维工具 Ansible：python,Agentless,中小型应用环境 Saltstack：python，一般需部署agent，执行效率更高 Puppet：ruby, 功能强大,配置复杂，重型,适合大型环境 Fabric：python，agentless Chef: ruby,国内应用少 Cfengine func ansible介绍&hearts; ansible介绍 ansible自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。 创始人，Michael DeHaan（ Cobbler 与 Func 的作者） &hearts; ansible架构&hearts; ansible工作原理 &hearts; ansible特性 模块化：调用特定的模块，完成特定任务 有Paramiko，PyYAML，Jinja2（模板语言）三个关键模块 支持自定义模块 基于Python语言实现 部署简单，基于python和SSH(默认已安装)，agentless 安全，基于OpenSSH 支持playbook编排任务 幂等性：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况 无需代理不依赖PKI（无需ssl） 可使用任何编程语言写模块 YAML格式，编排任务，支持丰富的数据结构 较强大的多层解决方案 &hearts; ansible主要组成部分 ansible playbooks：任务剧本（任务集），编排定义Ansible任务集的配置文件，由Ansible顺序依次执行，通常是JSON格式的YML文件 inventory：Ansible管理主机的清单/etc/anaible/hosts modules：Ansible执行命令的功能模块，多数为内置核心模块，也可自定义 plugins：模块功能的补充，如连接类型插件、循环插件、变量插件、过滤插件等，该功能不常用 API：供第三方程序调用的应用程序编程接口 ansible：组合inventory、api、modules、plugins的绿框，可以理解为是ansible命令工具，其为核心执行工具 &hearts; Ansible命令执行来源： user，普通用户，即system administrator cmdb（配置管理数据库） api 调用 public/private cloud api调用 user-&gt; ansible playbook -&gt; ansibile &hearts; 利用ansible实现管理的方式： Ad-Hoc 即ansible命令，主要用于临时命令使用场景 Ansible-playbook 主要用于长期规划好的，大型项目的场景，需要有前提的规划&diams; 将已有编排好的任务集写入Ansible-Playbook&diams; 通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行 Ansible主要操作对象：&diams; HOSTS主机&diams; NETWORKING网络设备 注意事项&diams; 执行ansible的主机一般称为主控端，中控，master或堡垒机&diams; 主控端Python版本需要2.6或以上&diams; 被控端Python版本小于2.4需要安装python-simplejson&diams; 被控端如开启SELinux需要安装libselinux-python&diams; windows不能做为主控端 ansbile安装配置&hearts; ansible安装方式 rpm包安装: EPEL源&diams; yum install ansible 编译安装: 1234567891011121314yum -y install python-jinja2 PyYAML python-paramiko python-babel python-crypto tar xf ansible-1.5.4.tar.gz cd ansible-1.5.4 python setup.py build python setup.py install mkdir /etc/ansible cp -r examples/* /etc/ansible``` * Git方式: ```bashgit clone git://github.com/ansible/ansible.git --recursive cd ./ansible source ./hacking/env-setup pip安装： pip是安装Python包的管理器，类似yum 1234yum install python-pip python-devel yum install gcc glibc-devel zibl-devel rpm-bulid openssl-devel pip install --upgrade pip pip install ansible --upgrade 确认安装：&diams; ansible –version ansible配置&hearts; 相关配置文件 /etc/ansible/ansible.cfg 主配置文件，配置ansible工作特性 123456789101112defaults] inventory = /etc/ansible/hosts # 主机列表配置文件library = /usr/share/my_modules/ # 库文件存放目录remote_tmp = $HOME/.ansible/tmp #临时py命令文件存放在远程主机目录local_tmp = $HOME/.ansible/tmp # 本机的临时命令执行目录forks = 5 # 默认并发数 sudo_user = root # 默认sudo 用户 ask_sudo_pass = True #每次执行ansible命令是否询问ssh密码ask_pass = True remote_port = 22 host_key_checking = False # 检查对应服务器的hostlog_path=/var/log/ansible.log #日志文件 /etc/ansible/hosts 主机清单&diams; inventory文件遵循INI文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；此外，当如若目标主机使用了非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来标明&diams; 示例 12345678[webservers] www1.xfanyi.com:2222 www2.xfanyi.com [dbservers] db1.xfanyi.com db2.xfanyi.com db3.xfanyi.com &diams; 如果主机名称遵循相似的命名模式，还可以使用列表的方式标识各主机 &diams; 示例12345[websrvs] www[01:100].example.com[dbsrvs] db-[a:f].example.com /etc/ansible/roles/ 存放角色的目录 &hearts; 相关程序 /usr/bin/ansible 主程序，临时命令执行工具 /usr/bin/ansible-doc 查看配置文档，模块功能查看工具 /usr/bin/ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台 /usr/bin/ansible-playbook 定制自动化任务，编排剧本工具/usr/bin/ansible-pull 远程执行命令的工具 /usr/bin/ansible-vault 文件加密工具 /usr/bin/ansible-console 基于Console界面与用户交互的执行工具 ansible应用ansible命令&hearts; ansible管理主机方式 ansible通过ssh实现配置管理、应用部署、任务执行等功能，建议配置ansible端能基于密钥认证的方式联系各被管理节点 &hearts; ansible匹配主机方式 所有的被管理主机，需定义在/etc/ansible/hosts文件中 All ：表示所有Inventory中的所有主机&diams; ansible all –m ping * :通配符&diams; ansible “*” -m ping&diams; ansible 192.168.1.* -m ping&diams; ansible “*srvs” -m ping 或关系&diams; ansible “websrvs:appsrvs” -m ping&diams; ansible “192.168.1.10:192.168.1.20” -m ping 逻辑与&diams; ansible “websrvs:&amp;dbsrvs” –m ping&diams; 在websrvs组并且在dbsrvs组中的主机 逻辑非&diams; ansible ‘websrvs:!dbsrvs’ –m ping&diams; 在websrvs组，但不在dbsrvs组中的主机&diams; 注意：此处为单引号 综合逻辑&diams; ansible ‘websrvs:dbsrvs:&amp;appsrvs:!ftpsrvs’ –m ping 正则表达式&diams; ansible “websrvs:&amp;dbsrvs” –m ping&diams; ansible “~ (web|db).*.xfanyi\.com” –m ping &hearts; ansible命令执行过程 ansible命令执行过程&diams; 加载自己的配置文件 默认/etc/ansible/ansible.cfg&diams; 加载自己对应的模块文件，如command&diams; 通过ansible将模块或命令生成对应的临时py文件，并将该 文件传输至远程服务器的对应执行用户$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件&diams; 给文件+x执行&diams; 执行并返回结果&diams; 删除临时py文件，sleep 0退出 执行状态：&diams; 绿色：执行成功并且不需要做改变的操作&diams; 黄色：执行成功并且对目标主机做变更&diams; 红色：执行失败 示例123456789#以fang用户执行ping存活检测 ansible all -m ping -u fang -k #以fang sudo至root执行ping存活检测 ansible all -m ping -u fang –b -k #以yi sudo至fang用户执行ping存活检测 ansible all -m ping -u yi –b -k --become-user fang #以fang sudo至root用户执行ls ansible all -m command -u fang --become-user=root -a 'ls /root' -b –k -K &hearts; ansible系列命令 ansible-galaxy&diams; 连接 https://galaxy.ansible.com 下载相应的roles&diams; 列出所有已安装的galaxy&raquo; ansible-galaxy list&diams; 安装galaxy&raquo; ansible-galaxy install geerlingguy.redis&diams; 删除galaxy&raquo; ansible-galaxy remove geerlingguy.redis ansible-pull&diams; 推送命令至远程，效率无限提升，对运维要求较高 Ansible-vault&diams; 功能：管理加密解密yml文件&diams; ansible-vault [create|decrypt|edit|encrypt|rekey|view]&diams; ansible-vault encrypt hello.yml 加密&diams; ansible-vault decrypt hello.yml 解密&diams; ansible-vault view hello.yml 查看&diams; ansible-vault edit hello.yml 编辑加密文件&diams; ansible-vault rekey hello.yml 修改口令&diams; ansible-vault create new.yml 创建新文件 Ansible-console&diams; 2.0+新增，可交互执行命令，支持tab&raquo; root@test (2)[f:10] $&diams; 执行用户@当前操作的主机组 (当前组的主机数量)[f:并发数]$&raquo; 设置并发数： forks n 例如： forks 10&raquo; 切换组： cd 主机组 例如： cd web&raquo; 列出当前组主机列表： list&raquo; 列出所有的内置命令： ?或help&diams; 示例 12345root@all (2)[f:5]$ list root@all (2)[f:5]$ cd appsrvs root@appsrvs (2)[f:5]$ list root@appsrvs (2)[f:5]$ yum name=httpd state=present root@appsrvs (2)[f:5]$ service name=httpd state=started ansible常用模块&hearts; 查看模块与获取帮助 ansible-doc [options] [module…]&diams; -a 显示所有模块的文档&diams; -l, –list 列出可用模块&diams; -s, –snippet显示指定模块的playbook片段&diams; 示例&raquo; ansible-doc –l 列出所有模块&raquo; ansible-doc ping 查看指定模块帮助用法&raquo; ansible-doc –s ping 查看指定模块帮助用法 Command&hearts; 模块：Command 命令模块默认&diams; ansible srvs -m command -a ‘service vsftpd start’&diams; ansible srvs -m command -a ‘echo fang |passwd –stdin fang’ 不成功&diams; 此命令不支持 $VARNAME &lt; &gt; | ; &amp; 等，用shell模块实现 12#ansible默认使用的是command模板，如果觉得功能不够用，可以把其换成shellb#module_name = command Shell&hearts; 模块：Shell shell功能&diams; 和command相似，用shell执行命令&diams; ansible srv -m shell -a ‘echo 123 |passwd –stdin fang’&diams; 调用bash执行命令 类似 cat /tmp/stanley.md | awk -F‘|’ ‘{print $1,$2}’ &amp;&gt;/tmp/example.txt 这些复杂命令，即使使用shell也可能会失败，解决办法：写到脚本时，copy到远程，执行，再把需要的结果拉回执行命令的机器 Script&hearts; 模块：Script 脚本模块&diams; -a “/PATH/TO/SCRIPT_FILE“&diams; snsible websrvs -m script -a f1.sh&diams; 脚本要在当前主机 Copy&hearts; 模块：Copy 文件复制&diams; 从服务器复制文件到客户端&diams; 如目标存在，默认覆盖，此处指定先备份&raquo; ansible srv -m copy -a “src=/root/f1.sh dest=/tmp/f2.sh owner=fang mode=600 backup=yes”&diams; 利用内容，直接生成目标文件&raquo; ansible srv -m copy -a “content=‘test content\n’ dest=/tmp/f1.txt” Fetch:从客户端取文件至服务器端，copy相反，目录可先tar&diams; ansible srv -m fetch -a ‘src=/root/a.sh dest=/data/scripts’ File：设置文件属性&diams; ansible srv -m file -a “path=/root/a.sh owner=fang mode=755“&diams; ansible web -m file -a ‘src=/app/testfile dest=/app/testfile-link state=link Hostname&hearts; 模块：Hostname 管理主机名&diams; ansible node1 -m hostname -a “name=websrv” Cron&hearts; 模块：Cron 计划任务&diams; 支持时间：minute，hour，day，month，weekday&raquo; ansible srv -m cron -a “minute=*/5 job=‘/usr/sbin/ntpdate172.16.0.1 &amp;&gt;/dev/null’ name=Synctime” 创建任务&raquo; ansible srv -m cron -a ‘state=absent name=Synctime’ 删除任务 Yum&hearts; 模块：Yum 软件安装、卸载&diams; ansible srv -m yum -a ‘name=httpd state=latest’ 安装&diams; ansible srv -m yum -a ‘name=httpd state=absent’ 删除 Service&hearts; 模块：Service 管理服务&diams; ansible srv -m service -a ‘name=httpd state=stopped’&diams; ansible srv -m service -a ‘name=httpd state=started’&diams; ansible srv –m service –a ‘name=httpd state=reloaded’&diams; ansible srv -m service -a ‘name=httpd state=restarted’ User&hearts; 模块：User 管理用户&diams; ansible srv -m user -a ‘name=user1 comment=“test user” uid=2048 home=/app/user1 group=root‘&diams; ansible srv -m user -a ‘name=sysuser1 system=yes home=/app/sysuser1 ’&diams; ansible srv -m user -a ‘name=user1 state=absent remove=yes‘ 删除用户及家目录等数据 Group&hearts; 模块：Group 管理组&diams; ansible srv -m group -a “name=testgroup system=yes“&diams; ansible srv -m group -a “name=testgroup state=absent” playbookplaybook介绍&hearts; playbook介绍 playbook是由一个或多个“play”组成的列表 play的主要功能在于将事先归并为一组的主机装扮成事先通过ansible中的task定义好的角色。从根本上来讲，所谓task无非是调用ansible的一个module。将多个play组织在一个playbook中，即可以让它们联同起来按事先编排的机制同唱一台大戏 Playbook采用YAML语言编写 YAML介绍&hearts; YAML介绍 YAML是一个可读性高的用来表达资料序列的格式。YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822等。Clark Evans在2001年在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者 YAML Ain’t Markup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：”Yet Another Markup Language”（仍是一种标记语言） 特性&diams; YAML的可读性好&diams; YAML和脚本语言的交互性好&diams; YAML使用实现语言的数据类型&diams; YAML有一个一致的信息模型&diams; YAML易于实现&diams; YAML可以基于流来处理&diams; YAML表达能力强，扩展性好 YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用”-“来代表，Map里的键值对用”:”分隔&diams; 示例 1234567891011121314name: John Smith age: 41 gender: Male spouse: name: Jane Smith age: 37 gender: Female children: - name: Jimmy Smith age: 17 gender: Male - name: Jenny Smith age 13 gender: Female 更多内容参考 http://www.yaml.org YAML语法简介&hearts; YAML语法简介 在单一档案中，可用连续三个连字号(——)区分多个档案。另外，还有选择性的连续三个点号( … )用来表示档案结尾 次行开始正常写Playbook的内容，一般建议写明该Playbook的功能 使用#号注释代码 缩进必须是统一的，不能空格和tab混用 缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结合换行来实现的 YAML文件内容和Linux系统大小写判断方式保持一致，是区别大小写的，k/v的值均需大小写敏感 k/v的值可同行写也可换行写。同行使用:分隔 v可是个字符串，也可是另一个列表 一个完整的代码块功能需最少元素需包括 name: task 一个name只能包括一个task YAML文件扩展名通常为yml或yaml &hearts; list List：列表，其所有元素均使用“-”打头 示例&diams; # A list of tasty fruits&diams; - Apple&diams; - Orange&diams; - Strawberry&diams; - Mango &hearts; Dictionary Dictionary：字典，通常由多个key与value构成 示例&diams; # An employee record&diams; name: Example Developer&diams; job: Developer&diams; skill: Elite 也可以将key:value放置于{}中进行表示，用,分隔多个key:value 示例&diams; # An employee record&diams; {name: Example Developer, job: Developer, skill: Elite} Playbook元素及组件&hearts; Playbook核心元素 Hosts 执行的远程主机列表 Tasks 任务集 Varniables 内置变量或自定义变量在playbook中调用 Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件 Handlers 和notity结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行 tags 标签 指定某条任务执行，用于选择运行playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断&diams; 示例ansible-playbook –t tagsname useradd.yml &hearts; playbook基础组件 remote_user: 可用于Host和task中。也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户&diams; 示例 12345678- hosts: websrvs remote_user: root tasks: - name: test connection ping: remote_user: yi sudo: yes 默认sudo为root sudo_user:fang sudo为fang task列表和action&diams; play的主体部分是task list。task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后，再开始第二个任务&diams; task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致&diams; 每个task都应该有其name，用于playbook的执行结果输出，建议其内容尽可能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出&diams; 某任务的状态在运行后为changed时，可通过“notify”通知给相应的handlers&diams; 任务可以通过”tags“打标签，而后可在ansible-playbook命令上使用-t指定进行调用&diams; 如果命令或脚本的退出码不为零，可以使用如下方式替代&diams; tasks:&raquo; - name: run this command and ignore the result&raquo; shell: /usr/bin/somecommand || /bin/true&diams; 或者使用ignore_errors来忽略错误信息：&raquo; tasks:&raquo; - name: run this command and ignore the result&raquo; shell: /usr/bin/somecommand&raquo; ignore_errors: True &diams; tasks：任务列表&diams; action: module arguments&diams; module: arguments 建议使用&raquo; 注意：shell和command模块后面跟命令，而非key=value 运行playbook&hearts; 运行playbook的方式 ansible-playbook &lt;filename.yml&gt; … [options] 常见选项&diams; –check 只检测可能会发生的改变，但不真正执行操作&diams; –list-hosts 列出运行任务的主机&diams; –limit 主机列表 只针对主机列表中的主机执行&diams; -v 显示过程 -vv -vvv 更详细 示例&diams; ansible-playbook file.yml –check 只检测&diams; ansible-playbook file.yml&diams; ansible-playbook file.yml –limit websrvs 综合示例&diams; 示例.1 123456789101112--- - hosts: all tasks: - name: "安装Apache" yum: name=httpd - name: "复制配置文件" copy: src=/tmp/httpd.conf dest=/etc/httpd/conf/ - name: "复制配置文件" copy: src=/tmp/vhosts.conf dest=/etc/httpd/conf.cd/ - name: "启动Apache，并设置开机启动" service: name=httpd state=started enabled=yes &diams; 示例.2 12345678910--- - hosts: all remote_user: root tasks: - name: create mysql user user: name=mysql system=yes uid=36 - name: create a group group: name=httpd system=yes &diams; 示例.3 123456789101112- hosts: websrvs remote_user: root tasks: - name: Install httpd yum: name=httpd state=present - name: Install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ - name: start service service: name=httpd state=started enabled=yes &diams; 示例.4 notify结合handler 12345678910111213- hosts: websrvs remote_user: root tasks: - name: Install httpd yum: name=httpd state=present - name: Install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ notify: restart httpd - name: ensure apache is running service: name=httpd state=started enabled=yes handlers: - name: restart httpd service: name=httpd status=restarted &diams; 示例.5 tags使用 123456789101112131415- hosts: websrvs remote_user: root tasks: - name: Install httpd yum: name=httpd state=present - name: Install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ tags: conf - name: start httpd service tags: service service: name=httpd state=started enabled=yes ansible-playbook –t conf httpd.yml Playbook中变量使用&hearts; 变量命名及使用 变量名：仅能由字母、数字和下划线组成，且只能以字母开头 变量定义&diams; key=value&diams; http_port=80 变量调用方式：&diams; 通过 调用变量，且变量名前后必须有空格，有时用“”才生效&diams; ansible-playbook –e 选项指定&raquo; ansible-playbook test.yml -e “hosts=www user=fang” &hearts; 变量来源： ansible setup facts 远程主机的所有变量都可直接调用&diams; ansible_distribution_major_version 当前主机的系统主版本号&diams; ansible_fqdn 当前主机的主机名&diams; ansible_processor_vcpus 当前主机的CPU核心数 在/etc/ansible/hosts中定义&diams; 普通变量：主机组中主机单独定义，优先级高于公共变量&diams; 公共（组）变量：针对主机组中所有主机定义统一变量 通过命令行指定变量，优先级最高&diams; ansible-playbook –e varname=value 在playbook中定义&diams; vars:&raquo; - var1: value1&raquo; - var2: value2 在独立的变量YAML文件中定义 在role中定义 &hearts; 普通变量 普通变量&diams; 示例： 123[websrvs] 192.168.99.101 http_port=8080 hname=www1 192.168.99.102 http_port=80 hname=www2 公共变量&diams; 示例： 1234567[websvrs:vars] http_port=808 mark=“_” [websrvs] 192.168.99.101 http_port=8080 hname=www1 192.168.99.102 http_port=80 hname=www2 ansible websvrs –m hostname –a ‘name=&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; http_port &#125;&#125;’ 指定变量&diams; 示例： 1ansible websvrs –e http_port=8000 –m hostname –a 'name=&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; http_port &#125;&#125;' &hearts; setup变量 setup变量 &diams; 示例.1 12345678- hosts: websrvs remote_user: root tasks: - name: create log file file: name=/var/log/ &#123;&#123; ansible_fqdn &#125;&#125; state=touch ansible-playbook var.ym &diams; 示例.2 123456789- hosts: websrvs remote_user: root tasks: - name: install package yum: name=&#123;&#123; pkname &#125;&#125; state=present ansible-playbook –e pkname=httpd var.yml &hearts; 主机变量 可以在inventory中定义主机时为其添加主机变量以便于在playbook中使用&diams; 示例123[websrvs] www1.xfanyi.com http_port=80 maxRequestsPerChild=808 www2.xfanyi.com http_port=8080 maxRequestsPerChild=909 &hearts; 组变量 组变量是指赋予给指定组内所有主机上的在playbook中可用的变量&diams; 示例1234567[websrvs] www1.xfanyi.com www2.xfanyi.com [websrvs:vars] ntp_server=ntp.xfanyi.com nfs_server=nfs.xfanyi.com &hearts; 变量文件 变量文件&diams; 示例12345678910111213cat vars.yml var1: httpd var2: nginx- hosts: web remote_user: root vars_files: - vars.yml tasks: - name: create httpd log file: name=/app/&#123;&#123; var1 &#125;&#125;.log state=touch - name: create nginx log file: name=/app/&#123;&#123; var2 &#125;&#125;.log state=touch 模板templates&hearts; templates介绍 文本文件，嵌套有脚本（使用模板编程语言编写） Jinja2语言，使用字面量，有下面形式&diams; 字符串：使用单引号或双引号&diams; 数字：整数，浮点数&diams; 列表：[item1, item2, …]&diams; 元组：(item1, item2, …)&diams; 字典：{key1:value1, key2:value2, …}&diams; 布尔型：true/false 算术运算：+, -, *, /, //, %, ** 比较操作：==, !=, &gt;, &gt;=, &lt;, &lt;= 逻辑运算：and, or, not 流表达式：For If When &hearts; 功能及示例 templates功能：根据模块文件动态生成对应的配置文件&diams; templates文件必须存放于templates目录下，且命名为 .j2 结尾&diams; yaml/yml 文件需和templates目录平级，目录结构如下： 1234./ ├── temnginx.yml └── templates └── nginx.conf.j2 示例&diams; 利用templates 同步nginx配置文件&raquo; 准备templates/nginx.conf.j2文件 123456789101112vim temnginx.yml - hosts: websrvs remote_user: root tasks: - name: template config to remote hosts template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf ansible-playbook temnginx.yml 修改文件nginx.conf.j2 下面行为&diams; worker_processes ; &hearts; template算术运算 算法运算： 示例123vim nginx.conf.j2 worker_processes &#123;&#123; ansible_processor_vcpus**2 &#125;&#125;; worker_processes &#123;&#123; ansible_processor_vcpus+2 &#125;&#125;; when&hearts; when介绍 条件测试:如果需要根据变量、facts或此前任务的执行结果来做为某task执行与否的前提时要用到条件测试,通过when语句实现，在task中使用，jinja2的语法格式 在task后添加when子句即可使用条件测试；when语句支持Jinja2表达式语法&diams; 示例.1 1234tasks: - name: "shutdown RedHat flavored systems" command: /sbin/shutdown -h now when: ansible_os_family == "RedHat" &diams; 示例.2 1234567891011121314- hosts: websrvs remote_user: root tasks: - name: add group nginx tags: user user: name=nginx state=present - name: add user nginx user: name=nginx state=present group=nginx - name: Install Nginx yum: name=nginx state=present - name: restart Nginx service: name=nginx state=restarted when: ansible_distribution_major_version == "6" &diams; 示例.3 1234567tasks: - name: install conf file to centos7 template: src=nginx.conf.c7.j2 when: ansible_distribution_major_version == "7" - name: install conf file to centos6 template: src=nginx.conf.c6.j2 when: ansible_distribution_major_version == "6" with_items&diams; 迭代：with_items 迭代：当有需要重复性执行的任务时，可以使用迭代机制&diams; 对迭代项的引用，固定变量名为”item“&diams; 要在task中使用with_items给定要迭代的元素列表&diams; 列表格式：&raquo; 字符串&raquo; 字典 &diams; 示例.1 1234567891011- name: add several users user: name=&#123;&#123; item &#125;&#125; state=present groups=wheel with_items: - testuser1 - testuser2#上面语句的功能等同于下面的语句：- name: add user testuser1 user: name=testuser1 state=present groups=wheel - name: add user testuser2 user: name=testuser2 state=present groups=wheel &diams; 示例.2 123456789- hosts: testsrv remote_user: root tasks - name: Create rsyncd config copy: src=&#123;&#123; item &#125;&#125; dest=/etc/&#123;&#123; item &#125;&#125; with_items: - rsyncd.secrets - rsyncd.conf &diams; 示例.3 12345678910111213141516- hosts: websrvs remote_user: root tasks: - name: copy file copy: src=&#123;&#123; item &#125;&#125; dest=/tmp/&#123;&#123; item &#125;&#125; with_items: - file1 - file2 - file3 - name: yum install httpd yum: name=&#123;&#123; item &#125;&#125; state=present with_items: - apr - apr-util - httpd &diams; 示例.4 12345678910- hosts：websrvs remote_user: root tasks - name: install some packages yum: name=&#123;&#123; item &#125;&#125; state=present with_items: - nginx - memcached - php-fpm &diams; 示例.5 12345678910111213tasks: - name: add some groups group: name=&#123;&#123; item &#125;&#125; state=present with_items: - group1 - group2 - group3 - name: add some users user: name=&#123;&#123; item.name &#125;&#125; group=&#123;&#123; item.group &#125;&#125; state=present with_items: - &#123; name: 'user1', group: 'group1' &#125; - &#123; name: 'user2', group: 'group2' &#125; - &#123; name: 'user3', group: 'group3' &#125; for if 示例&diams; 示例.1 123456789101112131415&#123;% for vhost in nginx_vhosts %&#125; server &#123; listen &#123;&#123; vhost.listen | default('80 default_server') &#125;&#125;; &#123;% if vhost.server_name is defined %&#125; server_name &#123;&#123; vhost.server_name &#125;&#125;; &#123;% endif %&#125; &#123;% if vhost.root is defined %&#125; root &#123;&#123; vhost.root &#125;&#125;; &#123;% endif %&#125; &diams; 示例.2 1234567891011121314151617181920212223242526// temnginx.yml --- - hosts: testweb remote_user: root vars: nginx_vhosts: - listen: 8080 //templates/nginx.conf.j2 &#123;% for vhost in nginx_vhosts %&#125; server &#123; listen &#123;&#123; vhost.listen &#125;&#125; &#125; &#123;% endfor %&#125; 生成的结果 server &#123; listen 8080 &#125; &diams; 示例.3 1234567891011121314151617181920212223242526272829303132333435// temnginx.yml --- - hosts: mageduweb remote_user: root vars: nginx_vhosts: - web1 - web2 - web3 tasks: - name: template config template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf// templates/nginx.conf.j2 &#123;% for vhost in nginx_vhosts %&#125; server &#123; listen &#123;&#123; vhost &#125;&#125; &#125; &#123;% endfor %&#125; 生成的结果： server &#123; listen web1 &#125; server &#123; listen web2 &#125; server &#123; listen web3 &#125; &diams; 示例.4 123456789101112131415161718192021222324252627282930313233343536373839404142434445// temnginx.yml - hosts: mageduweb remote_user: root vars: nginx_vhosts: - web1: listen: 8080 server_name: "web1.magedu.com" root: "/var/www/nginx/web1/" - web2: listen: 8080 server_name: "web2.magedu.com" root: "/var/www/nginx/web2/" - web3: listen: 8080 server_name: "web3.magedu.com" root: "/var/www/nginx/web3/“ tasks: - name: template config template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf // templates/nginx.conf.j2 &#123;% for vhost in nginx_vhosts %&#125; server &#123; listen &#123;&#123; vhost.listen &#125;&#125; server_name &#123;&#123; vhost.server_name &#125;&#125; root &#123;&#123; vhost.root &#125;&#125; &#125; &#123;% endfor %&#125; 生成结果： server &#123; listen 8080 server_name web1.magedu.com root /var/www/nginx/web1/ &#125; server &#123; listen 8080 server_name web2.magedu.com root /var/www/nginx/web2/ &#125; server &#123; listen 8080 server_name web3.magedu.com root /var/www/nginx/web3/ &#125; &diams; 示例.5 123456789101112131415161718192021222324252627282930313233343536373839404142434445// temnginx.yml - hosts: mageduweb remote_user: root vars: nginx_vhosts: - web1: listen: 8080 root: "/var/www/nginx/web1/" - web2: listen: 8080 server_name: "web2.magedu.com" root: "/var/www/nginx/web2/" - web3: listen: 8080 server_name: "web3.magedu.com" root: "/var/www/nginx/web3/" tasks: - name: template config to template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf // templates/nginx.conf.j2 &#123;% for vhost in nginx_vhosts %&#125; server &#123; listen &#123;&#123; vhost.listen &#125;&#125; &#123;% if vhost.server_name is defined %&#125; server_name &#123;&#123; vhost.server_name &#125;&#125; &#123;% endif %&#125; root &#123;&#123; vhost.root &#125;&#125; &#125; &#123;% endfor %&#125; 生成的结果 server &#123; listen 8080 root /var/www/nginx/web1/ &#125; server &#123; listen 8080 server_name web2.magedu.com root /var/www/nginx/web2/ &#125; server &#123; listen 8080 server_name web3.magedu.com root /var/www/nginx/web3/ &#125; roles&hearts; roles介绍 ansilbe自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中 复杂场景：建议使用roles，代码复用度高&diams; 变更指定主机或主机组&diams; 如命名不规范维护和传承成本大&diams; 某些功能需多个Playbook，通过Includes即可实现 角色(roles)：角色集合 &hearts; roles目录结构 每个角色，以特定的层级目录结构进行组织 12345678910├── roles│ └── project│ ├── default│ ├── files│ ├── handlers│ ├── meta│ ├── tasks│ ├── templates│ └── vars└── site.yml 各目录详解&diams; files/ ：存放由copy或script模块等调用的文件&diams; templates/：template模块查找所需要模板文件的目录&diams; tasks/：定义task,role的基本元素，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含&diams; handlers/：至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含&diams; vars/：定义变量，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含&diams; meta/：定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，其它文件需在此文件中通过include进行包含&diams; default/：设定默认变量时使用此目录中的main.yml文件&diams; 示图 &hearts; 创建role步骤 创建以roles命名的目录 在roles目录中分别创建以各角色名称命名的目录，如webservers等 在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录；用不到的目录可以创建为空目录，也可以不创建 在playbook文件中，调用各角色&diams; 示图 12345678910111213nginx-role.yml roles/ └── nginx ├── files │ └── main.yml ├── tasks │ ├── groupadd.yml │ ├── install.yml │ ├── main.yml │ ├── restart.yml │ └── useradd.yml └── vars └── main.yml &hearts; 调用role 方法1&diams; 示图 123456- hosts: websrvs remote_user: root roles: - mysql - memcached - nginx 方法2&diams; 示图 12345- hosts: remote_user: roles: - mysql - &#123; role: nginx, username: nginx &#125;]]></content>
      <categories>
        <category>puppet</category>
      </categories>
      <tags>
        <tag>puppet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运维自动化之系统部署]]></title>
    <url>%2F2018%2F09%2F19%2F%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B9%8B%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[自动化之系统部署介绍系统安装过程&hearts; 系统启动流程： bootloader–&gt;kernel(initramfs)–&gt;rootfs–&gt;/sbin/init &hearts; 要进入安装步骤，需要先有一个引导程序引导启动一个特殊的Linux安装环境系统 引导有多种方式：&diams; 基于网络方式的小型引导镜像，需要提供小型的引导镜像；&diams; U盘引导，通过可引导存储介质中的小型引导镜像启动安装过程；&diams; 基于PXE的网络安装方式，要提供PXE的完整安装环境；&diams; 其他bootloder引导（如GRUB） &hearts; linux系统光盘中isolinux目录列表介绍 solinux.bin：光盘引导程序，在mkisofs的选项中需要明确给出文件路径，这个文件属于SYSLINUX项目 isolinux.cfg：isolinux.bin的配置文件，当光盘启动后（即运行isolinux.bin），会自动去找isolinux.cfg文件 vesamenu.c32：是光盘启动后的安装图形界面，也属于SYSLINUX项目，menu.c32版本是纯文本的菜单 Memtest：内存检测，这是一个独立的程序 splash.jgp：光盘启动界面的背景图 vmlinuz是内核映像 initrd.img是ramfs (先cpio，再gzip压缩) &hearts; linux系统安装过程 MBR：isolinux/boot.cat stage2: isolinux/isolinux.bin 配置文件：isolinux/isolinux.cfg&diams; 每个对应的菜单选项：&raquo; 加载内核：isolinuz/vmlinuz&raquo; 向内核传递参数：append initrd=initrd.img … 装载根文件系统，并启动anaconda&diams; 默认启动GUI接口&diams; 若是显式指定使用TUI接口：向内核传递text参数即可&raquo; 按tab键,在后面增加text&raquo; 按ESC键：boot: linux text anaconda介绍&hearts; anaconda简介 Anaconda是Red Hat、CentOS、Fedora等Linux的安装管理程序。它可以提供文本、图形等安装管理方式，并支持Kickstart等脚本提供自动安装的功能。此外，其还支持许多启动参数，熟悉这些参数可为安装带来很多方便。该程序是把位于光盘或其他源上的数据包，根据设置安装到主机上的一个程序；为实现该定制安装，其提供一个定制界面，可以实现交互式界面供用户选择配置（如选择语言，键盘，时区等信息）；&diams; gui：图形窗口 (及安装系统提示输入语言，国家的那个界面)&diams; tui: 基于图形库curses的文本窗口 &hearts; Anaconda安装系统分成三个阶段： 安装前配置阶段&diams; 安装过程使用的语言&diams; 键盘类型&diams; 安装目标存储设备&raquo; Basic Storage：本地磁盘&raquo; 特殊设备：iSCSI&diams; 设定主机名&diams; 配置网络接口&diams; 时区&diams; 管理员密码&diams; 设定分区方式及MBR的安装位置&diams; 创建一个普通用户&diams; 选定要安装的程序包 安装阶段&diams; 在目标磁盘创建分区，执行格式化操作等&diams; 将选定的程序包安装至目标位置&diams; 安装bootloader和initramfs 图形模式首次启动&diams; iptables&diams; selinux&diams; core dump &hearts; anaconda的配置方式： 交互式配置方式 (选择语言、输入国家、分区等) 通过读取事先给定的配置文件自动完成配置&diams; 按特定语法给出的配置选项&diams; kickstart文件 kickstart介绍&hearts; kickstart简介 kickstart是一个利用Anconda工具实现服务器自动化安装的方法；通过生成的kickstart配置文件ks.cfg，服务器安装可以实现从裸机到全功能服务的的非交互式（无人值守式）安装配置；&diams; ks.cfg是一个简单的文本文件，文件包含Anconda在安装系统及安装后配置服务时所需要获取的一些必要配置信息（如键盘设置，语言设置，分区设置等）；Anconda直接从该文件中读取必要的配置，只要该文件信息配置正确无误且满足所有系统需求，就不再需要同用户进行交互获取信息，从而实现安装的自动化；但是配置中如果忽略任何必需的项目，安装程序会提示用户输入相关的项目的选择，就象用户在典型的安装过程中所遇到的一样。一旦用户进行了选择，安装会以非交互的方式（unattended）继续。 &hearts; kickstart文件的格式 命令段：指明各种安装前配置，如键盘类型等 程序包段：指明要安装的程序包组或程序包，不安装的程序包等 1234567891011121314151617181920212223242526272829 %packages @group_name package -package %end %postrm -rf /etc/yum.repos.d/*cat &gt;&gt;/etc/yum.repos.d/base.repo&lt;&lt;EFO[media]name=mediabaseurl=http://192.168.11.100/os/6gpgcheck=0[epel]name=epelbaseurl= https://mirrors.aliyun.com/epel/6/x86_64/gpgcheck=0EFOyum -y install vimcat &gt;&gt; /root/.ssh/authorized_keys &lt;&lt;EFOssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAzlR9Sq14Q34cjBBhRZkaWyIu8g01GQP+1WTMFJ8uAw1R4VjrZKuKsr9pt5rHJG5HFv+RswfFRUGFM0/3EIaWHnJnHb39uveu6NAM+DqxCt7R+1OkXkcCeqbR20Lyurb8X4B8ZQEQ3rV7vnr6LGQV2mn7oosFPVTBYn03f0pdVHteK5pWoVAruZz6Y3eLz00Ma3wKOMnjSYezeTcRlEEKDEm9a5EiRbwtmPX0pnG4LWdWdc1xeDCeq4Sw6uicOpF1cPDGUpGgfD8tcMwb374avAgKfClEP4Ph8IM/ZQvWoDeGjNXVPKLBfoqZVbusEcz3YzJ8PpCcNxbQvDv0TBcG8w== root@localhost.localdomainEFO%end%packages@core%end 脚本段：&diams; %pre: 安装前脚本&raquo; 运行环境：运行于安装介质上的微型Linux环境&diams; %post: 安装后脚本&raquo; 运行环境：安装完成的系统 命令段中的必备命令：&diams; authconfig: 认证方式配置&raquo; authconfig –useshadow –passalgo=sha512&diams; bootloader：bootloader的安装位置及相关配置&raquo; bootloader –location=mbr –driveorder=sda – append=”crashkernel=auto rhgb quiet”&diams; keyboard: 设定键盘类型&diams; lang: 语言类型&diams; part: 创建分区&diams; rootpw: 指明root的密码&diams; timezone: 时区 可选命令&diams; install OR upgrade&diams; text: 文本安装界面&diams; network&diams; firewall&diams; selinux&diams; halt&diams; poweroff&diams; reboot&diams; repo&diams; user：安装完成后为系统创建新用户&diams; url: 指明安装源&diams; key –skip 跳过安装号码,适用于rhel版本 &hearts; kickstart文件创建方式 直接手动编辑&diams; 依据某模板修改 可使用创建工具：system-config-kickstart&diams; 依据某模板修改并生成新配置 /root/anaconda-ks.cfg&diams; 建议，用虚拟机最小化安装，引用anaconda-ks.cfg文件，在把文件放到图形下，编辑修改 检查ks文件的语法错误：ksvalidator&diams; ksvalidator /PATH/TO/KICKSTART_FILE DHCP协议DHCP协议简介&hearts; DHCP协议 动态主机设置协议是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：&diams; 用于内部网络或网络服务供应商自动分配IP地址给用户&diams; 用于内部网络管理员作为对所有计算机作中央管理的手段 DHCP统一使用两个IANA分配的端口作为BOOTP：服务器端使用67/udp，客户端使用68/udp。 &hearts; DHCP报文 DHCP DISCOVER：客户端到服务器 DHCP OFFER ：服务器到客户端 DHCP REQUEST：客户端到服务器 DHCP ACK ：服务器到客户端 DHCP NAK：服务器到客户端,通知用户无法分配合适的IP地址 DHCP DECLINE ：客户端到服务器，指示地址已被使用 DHCP RELEASE：客户端到服务器，放弃网络地址和取消剩余的租约时间 DHCP INFORM：客户端到服务器, 客户端如果需要从DHCP服务器端获取更为详细的配置信息，则发送Inform报文向服务器进行请求，极少用到 &hearts; DHCP相关概念 续租&diams; 50% ：租赁时间达到50%时来续租，刚向DHCP服务器发向新的DHCPREQUEST请求。如果dhcp服务没有拒绝的理由，则回应DHCPACK信息。当DHCP客户端收到该应答信息后，就重新开始新的租用周期&diams; 87.5%：如果之前DHCP Server没有回应续租请求，等到租约期的7/8时，主机会再发送一次广播请求 同网段多DHCP服务&diams; DHCP服务必须基于本地&diams; 先到先得的原则 跨网段&diams; RFC 1542 Compliant Routers&diams; dhcrelay: 中继 相关协议&diams; Arp&diams; rarp DHCP协议实现&hearts; dhcp Linux DHCP协议的实现程序：dhcp, dnsmasq（dhcp,dns） dhcpDhcp Server相关文件&diams; /usr/sbin/dhcpd&diams; /etc/dhcp/dhcpd.conf –&gt; /etc/rc.d/init.d/dhcpd&diams; /etc/dhcp/dhcpd6.conf–&gt; /etc/rc.d/init.d/dhcpd6&diams; /usr/sbin/dhcrelay&diams; /etc/rc.d/init.d/dhcrelay&diams; dhcp server:67/udp&diams; dhcp client: 68/udp&diams; dhcpv6 client:546/udp Dhcp client相关文件&diams; dhclient&diams; 自动获取的IP信息： /var/lib/dhclient &hearts; dhcp配置文件 dhcpd.conf:帮助参考：man 5 dhcpd.conf全局配置subnet {…}host {…} 地址分配记录&diams; /var/lib/dhcpd/dhcpd.leases 示例 123456789101112131415#域名option domain-name "xfanyi.top"; #DNS服务器IPoption domain-name-servers 114.114.114.114,8.8.8.8; #默认租期，单位 秒default-lease-time 86400; #最大租期，单位 秒max-lease-time 164000; #地址段subnet 192.168.8.0 netmask 255.255.255.0 &#123; #地址范围 range 192.168.8.50 192.168.100.200; #分配的路由 option routers 192.168.8.1; &#125; 注： dhcp配置文件中，要有跟本机网卡IP相关的地址段，否定服务会启不来 PXE介绍&hearts; pxe概念 预启动执行环境，提供了一种使用网络接口（Network Interface）启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。 Intel公司研发 PXE可以引导和安装Windows,linux等多种操作系统 基于Client/Server的网络模式，支持远程主机通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统 &hearts; PXE工作原理 Client向PXE Server上的DHCP发送IP地址请求消息，DHCP检测Client是否合法（主要是检测Client的网卡MAC地址），如果合法则返回Client的IP地址，同时将启动文件pxelinux.0的位置信息一并传送给Client Client向PXE Server上的TFTP发送获取pxelinux.0请求消息，TFTP接收到消息之后再向Client发送pxelinux.0大小信息，试探Client是否满意，当TFTP收到Client发回的同意大小信息之后，正式向Client发送pxelinux.0 Client执行接收到的pxelinux.0文件 Client向TFTP Server发送针对本机的配置信息文件（在TFTP 服务的pxelinux.cfg目录下），TFTP将配置文件发回Client，继而Client根据配置文件执行后续操作。 Client向TFTP发送Linux内核请求信息，TFTP接收到消息之后将内核文件发送给Client Client向TFTP发送根文件请求信息，TFTP接收到消息之后返回Linux根文件系统 Client启动Linux内核 Client下载安装源文件，读取自动化安装脚本 自动化之系统部署实现pxe自动化安装centos6&hearts; 环境构建 安装所需要用的到软件包，并设置为自启动1234567yum -y install dhcp httpd tftp-server syslinux chkconfig tftp opchkconfig xinetd on chkconfig httpd on chkconfig dhcpd on /etc/init.d/httpd start/etc/init.d/xinetd 准备好yum源和相关目录 12mkdir -pv /var/www/html/centos&#123;6,ks&#125;mount /dev/sr0 /var/www/html/centos/6 准备kickstart文件&diams; 用虚拟机最小化安装一个centos ,把里面的 /root/anaconda-ks.cfg 文件复制到图形的centos6虚拟机里&diams; 执行 system-config-kickstart命令，配置属于自己的kickstart文件&diams; 示例&diams; 导出配置文件命名为c6.cfg，并传到服务器端 12scp c6.cfg root@192.168.8.1:/var/www/html/ks/chmod 644 /var/www/html/ks/c6.cfg 准备相关的启动文件 12345678#在服务器端配置mkdir /var/lib/tftpboot/pxelinux.cfg/ cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/ # 前面把光盘挂到这个目录下了cd /var/www/html/centos/6/images/pxeboot/ cp vmlinuz initrd.img /var/lib/tftpboot cd /var/www/html/centos/6/isolinux/ cp boot.msg vesamenu.c32 splash.jpg /var/lib/tftpboot 准备启动菜单文件 123456789101112131415161718192021222324252627282930cp /var/www/html/centos/6/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default vim /var/lib/tftpboot/pxelinux.cfg/default default vesamenu.c32 指定菜单风格 #prompt 1 timeout 600 display boot.msg menu background splash.jpg menu title Welcome to wang CentOS 6 menu color border 0 #ffffffff #00000000 menu color sel 7 #ffffffff #ff000000 menu color title 0 #ffffffff #00000000 menu color tabmsg 0 #ffffffff #00000000 menu color unsel 0 #ffffffff #00000000 menu color hotsel 0 #ff000000 #ffffffff menu color hotkey 7 #ffffffff #ff000000 menu color scrollbar 0 #ffffffff #00000000 label auto# ^的含义，按首字母的时候跳过到这一项 menu label ^Automatic Install Centos6 kernel vmlinuz append initrd=initrd.img ks=http://192.168.8.1/centos/ks/centos6.cfg label manual menu label ^Manual Install Centos kernel vmlinuz append initrd=initrd.img inst.repo=http://192.168.8.1/centos/6 label local #默认是从本地启动，如果想直接自动化，可以把menu default放到对应项 menu default menu label Boot from ^local drive localboot 0xffff 配置dhcp服务器 12345678910111213141516171819cp /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf vim /etc/dhcp/dhcpd.conf subnet 192.168.8.0 netmask 255.255.255.0 &#123; range 192.168.8.100 192.168.8.200; option domain-name-servers 114.114.114.114,8.8.8.8; option domain-name "xfanyi.top"; option routers 192.168.8.1; option broadcast-address 192.168.8.255; #这两项很关键 #启动文件 filename "pxelinux.0"; #服务器地址 next-server 192.168.8.1; # default-lease-time 600; max-lease-time 7200;&#125;#配置好之后 记得把dhcp服务器启动/etc/init.d/dhcpd start 目录结构 123456789101112131415 [root@nginx dhcp]$ tree /var/lib/tftpboot//var/lib/tftpboot/├── boot.msg├── initrd.img├── pxelinux.0├── pxelinux.cfg│ └── default├── splash.jpg├── vesamenu.c32└── vmlinuz1 directory, 7 files#找台同局域网的服务器开机测试#安装过程中如有报 repo等错误，解决办法把cfg中的 repo禁用即可##repo --name="CentOS" --baseurl=cdrom:sr0 --cost=100 pxe自动化安装centos7 安装所需要的软件包、并启动 123456mount /dev/sr0 /mediayum -y install httpd tftp-server dhcp syslinuxsystemctl enable httpdsystemctl start httpd.service systemctl enable tftp.socketsystemctl start tftp.socket 配置dhcp服务器 123配置方法，同centos6一样systemctl start dhcpd systemctl enable dhcpd 创建镜像目录，kickstart文件 123mkdir -pv /var/www/html/&#123;os/7,ks&#125;umount /media ; mount /dev/sr0 /var/www/html/os/7#创建kickstart文件，方法同centos6一样,然后复制文件到/var/www/html/ks/目录下 提供相关文件 123456789101112mkdir /var/lib/tftpboot/pxelinux.cfg/ cp /usr/share/syslinux/&#123;pxelinux.0,menu.c32&#125; /var/lib/tftpboot/ cp /misc/cd/isolinux/&#123;vmlinuz,initrd.img&#125; /var/lib/tftpboot/ cp /misc/cd/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default tree /var/lib/tftpboot/var/lib/tftpboot/ ├── initrd.img ├── menu.c32 ├── pxelinux.0 ├── pxelinux.cfg │ └── default └── vmlinuz 查看对应的服务端口是否监听，如没有问题，测试 总结&hearts; pxe安装centos6、centos7的相关文件对比 cenots6相关文件及目录1234567891011121314151617181920mkdir /var/lib/tftpboot/pxelinux.cfg/ cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/ cd /光盘/images/pxeboot/ cp vmlinuz initrd.img /var/lib/tftpboot Cd /光盘/isolinux/ cp boot.msg vesamenu.c32 splash.jpg /var/lib/tftpbootcp /光盘/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/defaulttree /var/lib/tftpboot/var/lib/tftpboot/ ├── boot.msg ├── initrd.img ├── pxelinux.0 ├── pxelinux.cfg │ └── default ├── splash.jpg ├── vesamenu.c32 └── vmlinuz 1 directory, 7 files cenots7相关文件及目录123456789101112mkdir /var/lib/tftpboot/pxelinux.cfg/ cp /usr/share/syslinux/&#123;pxelinux.0,menu.c32&#125; /var/lib/tftpboot/ cp /光盘/isolinux/&#123;vmlinuz,initrd.img&#125; /var/lib/tftpboot/ cp /光盘/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default /var/lib/tftpboot/ ├── initrd.img ├── menu.c32 ├── pxelinux.0 ├── pxelinux.cfg │ └── default └── vmlinuz cobbler部署cobbler介绍&hearts; cobbler概念 快速网络安装linux操作系统的服务，支持众多的Linux发行版：Red Hat、Fedora、CentOS、Debian、Ubuntu和SuSE，也可以支持网络安装windows PXE的二次封装，将多种安装参数封装到一个菜单 Python编写 提供了CLI和Web的管理形式 &hearts; cobbler工作流程 client裸机配置了从网络启动后，开机后会广播包请求DHCP服务器（cobbler server）发送其分配好的一个IP DHCP服务器（cobbler server）收到请求后发送responese，包括其ip地址 client裸机拿到ip后再向cobbler server发送请求OS引导文件的请求 cobbler server告诉裸机OS引导文件的名字和TFTP server的ip和port client裸机通过上面告知的TFTP server地址通信，下载引导文件 client裸机执行执行该引导文件，确定加载信息，选择要安装的os，期间会再向cobbler server请求kickstart文件和os image cobbler server发送请求的kickstart和os iamge client裸机加载kickstart文件 client裸机接收os image，安装该os image 示例 &hearts; cobbler 相关术语 发行版：&diams; 表示一个操作系统版本，它承载了内核和 initrd 的信息，以及内核参数等其他数据 配置文件：&diams; 包含一个发行版、一个 kickstart 文件以及可能的存储库，还包含更多特定的内核参数等其他数据 系统：&diams; 表示要配置的主机，它包含一个配置文件或一个镜像，还包含 IP 和 MAC 地址、电源管理（地址、凭据、类型）以及更为专业的数据等信息 存储库：&diams; 保存一个 yum 或 rsync 存储库的镜像信息 镜像：&diams; 可替换一个包含不属于此类别的文件的发行版对象（例如，无法分为内核和initrd的对象） cobbler安装配置&hearts; 安装 cobbler 基于EPEL源&diams; 安装：yum install cobbler dhcp cobbler 服务集成&diams; PXE&diams; DHCP&diams; rsync&diams; Http&diams; DNS&diams; Kickstart&diams; IPMI 电源管理 &hearts; 配置 配置文件目录 /etc/cobbler&diams; /etc/cobbler/settings : cobbler 主配置文件&diams; /etc/cobbler/iso/: iso模板配置文件&diams; /etc/cobbler/pxe: pxe模板文件&diams; /etc/cobbler/power: 电源配置文件&diams; /etc/cobbler/user.conf: web服务授权配置文件&diams; /etc/cobbler/users.digest: web访问的用户名密码配置文件&diams; /etc/cobbler/dhcp.template : dhcp服务器的的配置末班&diams; /etc/cobbler/dnsmasq.template : dns服务器的配置模板&diams; /etc/cobbler/tftpd.template : tftp服务的配置模板&diams; /etc/cobbler/modules.conf : 模块的配置文件 数据目录&diams; /var/lib/cobbler/config/: 用于存放distros，system，profiles 等信息配置文件&diams; /var/lib/cobbler/triggers/: 用于存放用户定义的cobbler命令&diams; /var/lib/cobbler/kickstart/: 默认存放kickstart文件&diams; /var/lib/cobbler/loaders/: 存放各种引导程序 镜像目录&diams; /var/www/cobbler/ks_mirror/: 导入的发行版系统的所有数据&diams; /var/www/cobbler/images/ : 导入发行版的kernel和initrd镜像用于远程网络启动&diams; /var/www/cobbler/repo_mirror/: yum 仓库存储目录 日志目录&diams; /var/log/cobbler/installing: 客户端安装日志&diams; /var/log/cobbler/cobbler.log : cobbler日志 &hearts; cobbler 命令介绍 cobbler check 核对当前设置是否有问题 cobbler list 列出所有的cobbler元素 cobbler report 列出元素的详细信息 cobbler sync 同步配置到数据目录,更改配置最好都要执行下 cobbler reposync 同步yum仓库 cobbler distro 查看导入的发行版系统信息 cobbler system 查看添加的系统信息 cobbler profile 查看配置信息 cobbler实现部署&hearts; 步骤如下 安装包，并设置服务 检查配置 根据上面提示修改配置 下载启动相关文件菜单 配置DHCP服务 分别导入centos的安装源,并查看 准备kickstart文件并导入cobbler 测试 &hearts; 示图 增加epel源、安装cobbler及其它包 1234567891011cat &gt;&gt; /etc/yum.repos.d/base.repo &lt;&lt;EFO &gt; [epel]&gt; name=epel&gt; baseurl=https://mirrors.aliyun.com/epel/6/x86_64/&gt; gpgcheck=0EFOyum -y install cobbler dhcp httpd tftp/etc/init.d/cobbler start/etc/init.d/http start/etc/init.d/xinetd startchkconfig tftp on ; chkconfig httpd on ; chkconfig dhcpd on 执行cobbler check,根据报错、解决报错就可以了&diams; 这个报错重启cobbler 服务即可 /etc/init.d/cobbler restart&diams; 接下来只要解决图下的报错就可以了 123456#需要更改的项vim /etc/cobbler/settingsdefault_password_crypted: "$1$rHH5STtx$dI7Yo3.FmxbqA3cokkPg71" next_server: 192.168.8.1server: 192.168.8.1manage_dhcp: 1 &diams; 修改配置文件后报错&diams; 解决办法：&raquo; 关闭防火墙、关闭selinux&raquo; 增加wsgi代理模块&raquo; 在服务器上配置好上一步在settings中配置的server IP （切记） cobbler get-loaders 下载boot loaders 修改dhcp配置文件 123456vim /etc/cobvim /etc/cobbler/dhcp.templatesubnet 192.168.8.0 netmask 255.255.255.0 &#123; option routers 192.168.8.1; option domain-name-servers 114.114.114.114; option subnet-mask 255.255.255.0; range dynamic-bootp 192.168.8.50 192.168.8.200; 重启cobbler服务 12/etc/init.d/cobbler restartcobbler sync 导入镜像 1cobbler import --path=/misc/cd/ --name=Centos6.10-x86_64 --arch=x86_64 提供应答文件 1234567cp c6.cfg /var/lib/cobbler/kickstarts/ks6.cfgvim /var/lib/cobbler/kickstarts/ks6.cfg --url=$tree# 对应的查看命令# cobbler distro list # cobbler profile list# cobbler sync 关联应答文件 1234#删除默认的应答文件cobbler profile remove --name=centos6.10-x86_64#镜像文件关联应答文件cobbler profile add --name=Centos6.10-x86_64_desktop --distro=Centos6.10-x86_64 --kickstart=/var/lib/cobbler/kickstarts/c6.cfg 修改默认菜单项 123456789101112131415161718192021222324DEFAULT menuPROMPT 0MENU TITLE Cobbler | http://cobbler.github.io#等待时间，默认是20S、可根具实现情况修改TIMEOUT 200TOTALTIMEOUT 6000#超时之后选项方式ONTIMEOUT localLABEL local MENU LABEL (local) LOCALBOOT -1LABEL minc6 kernel /images/centos6.10-x86_64/vmlinuz # 默认菜单 MENU DEFAULT MENU LABEL minc6 append initrd=/images/centos6.10-x86_64/initrd.img ksdevice=bootif lang= kssendmac text ks=http://192.168.11.100/cblr/svc/op/ks/profile/minc6 ipappend 2MENU end 测试 cobbler总结 cobbler配置文件需要修改的地方&diams; 示例 1234567openssl passwd -1 生成密码default_password_crypted: "$1$rHH5STtx$dI7Yo3.FmxbqA3cokkPg71" #对应服务器的地址 next_server: 192.168.11.88server: 192.168.11.88#关联dhcp的配置文件manage_dhcp: 1 安装get-loaders 配置dhcp服务器&diams; 示例 123456vim /etc/cobbler/dhcp.templatesubnet 192.168.11.0 netmask 255.255.255.0 &#123; option routers 192.168.11.1; option domain-name-servers 114.114.114; option subnet-mask 255.255.255.0; range dynamic-bootp 192.168.11.100 192.168.11.200; 镜像与应答文件&diams; 示例 123456789101112#镜像文件查看 cobbler distro list#镜像文件导入cobbler import --path=/misc/cd/ --name=Centos6.10-x86_64 --arch=x86_64#du -sh /www/html配置文件路径 cp c6.cfg /var/lib/cobbler/kickstarts/c6.cfgurl --url=$tree#repo --name="CentOS" --baseurl=cdrom:sr0 --cost=100#删除应答文件cobbler profile remove --name=centos6.10-x86_64#镜像文件关联应答文件cobbler profile add --name=Centos6.10-x86_64_desktop --distro=Centos6.10-x86_64 --kickstart=/var/lib/cobbler/kickstarts/c6.cfg &hearts; 故障处理 tftp报错，解决方案&diams; 查看端口69是否监听&diams; 查看selinux、防火墙是否关闭&diams; dhcp配置文件中next-server跟cobbler的模板dhcp里的next-server是否一致]]></content>
      <categories>
        <category>puppet</category>
      </categories>
      <tags>
        <tag>puppet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密和安全]]></title>
    <url>%2F2018%2F09%2F11%2F%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[加密和安全对称加密算法&hearts; 对称加密：加密和解密使用同一个密钥 DES：Data Encryption Standard，56bits 3DES： AES：Advanced (128, 192, 256bits) Blowfish，Twofish IDEA，RC6，CAST5 特性：&diams;加密、解密使用同一个密钥，效率高&diams;将原始数据分割成固定大小的块，逐个进行加密 &hearts; 缺陷： 密钥过多 密钥分发 数据来源无法确认 非对称加密算法&hearts; 公钥加密：密钥是成对出现 公钥：公开给所有人；public key 私钥：自己留存，必须保证其私密性；secret key 特点：用公钥加密数据，只能使用与之配对的私钥解密；反之亦然 功能：&diams;数字签名：主要在于让接收方确认发送方身份&diams;对称密钥交换：发送方用对方的公钥加密一个对称密钥后发送给对方&diams;数据加密：适合加密较小数据 缺点：密钥长，加密解密效率低下 算法：&diams; RSA（加密，数字签名）&diams; DSA（数字签名）&diams; ELGamal 非对称加密&hearts; 基于一对公钥/密钥对 用密钥对中的一个加密，另一个解密 &hearts; 实现加密： 接收者&diams; 生成公钥/密钥对：P和S&diams;公开公钥P，保密密钥S 发送者&diams;使用接收者的公钥来加密消息M&diams;将P(M)发送给接收者 接收者&diams;使用密钥S来解密：M=S(P(M)) &hearts; 实现数字签名： 发送者&diams;生成公钥/密钥对：P和S&diams;公开公钥P，保密密钥S&diams;使用密钥S来加密消息M&diams;发送给接收者S(M) 接收者&diams;使用发送者的公钥来解密M=P(S(M)) 结合签名和加密 分离签名 单向散列&hearts;将任意数据缩小成固定大小的“指纹” 任意长度输入 固定长度输出 若修改数据，指纹也会改变（“不会产生冲突”） 无法从指纹中重新生成数据（“单向”） &hearts;功能：数据完整性&hearts;常见算法 md5: 128bits、sha1: 160bits、sha224、sha256、sha384、sha512 &hearts;常用工具 md5sum | sha1sum [ –check ] file openssl、gpg rpm -V 数字签名&hearts;如图 应用程序：RPM&hearts; 文件完整性的两种实施方式&hearts; 被安装的文件 MD5单向散列 rpm –verify package_name (or -V) &hearts; 发行的软件包文件 GPG公钥签名 rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat* rpm –checksig pakage_file_name (or -K) GPG使用对称加密&hearts; 对称加密示例 对称加密file文件&diams; gpg -c file&diams; ll file 在另一台主机上解密file&diams; gpg -o file -d file.gpg 公钥加密&hearts; 公钥加密示例 在hostB主机上用公钥加密，在hostA主机上解密 在hostA主机上生成公钥/私钥对&diams; gpg - -gen-key 在hostA主机上查看公钥&diams; gpg - -list-keys 在hostA主机上导出公钥到xfang.pubkey&diams; gpg -a - -export -o xfang.pubkey 从hostA主机上复制公钥文件到需加密的B主机上&diams; scp xfang.pubkey hostB: 在需加密数据的hostB主机上生成公钥/私钥对&diams; gpg - -list-keys&diams; gpg - -gen-key 在hostB主机上导入公钥&diams; gpg - -import xfang.pubkey&diams; gpg - -list-keys 用从hostA主机导入的公钥，加密hostB主机的文件file,生成file.gpg&diams; gpg -e -r xfang file&diams; file file.gpg 复制加密文件到hostA主机&diams; scp file.gpg hostA: 在hostA主机解密文件&diams; gpg -d file.gpg&diams; gpg -o file -d file.gpg 删除公钥和私钥&diams; gpg - -delete-keys fangy&diams; gpg - -delete-secret-keys fangy 安全协议与软件OpenSSLopenssl介绍&hearts; OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连线者的身份。这个包广泛被应用在互联网的网页服务器上。其主要库是以C语言所写成，实现了基本的加密功能，实现了SSL与TLS协议。opessl的开发者为 openssl项目。 三个组件：&diams; openssl: 多用途的命令行工具，包openssl&diams; libcrypto: 加密算法库，包openssl-libs&diams; libssl：加密模块应用库，实现了ssl及tls，包nss openssl命令：&diams; 两种运行模式：交互模式和批处理模式&diams; openssl version：程序版本号&diams; 标准命令、消息摘要命令、加密命令 CA和证书CA介绍&hearts; PKI: Public Key Infrastructure 签证机构：CA（Certificate Authority） 注册机构：RA 证书吊销列表：CRL 证书存取库： &hearts; X.509：定义了证书的结构以及认证协议标准 版本号 主体公钥 序列号 CRL分发点 签名算法 扩展信息 颁发者 发行者签名 有效期限 主体名称 &hearts; 证书获取 证书授权机构的证书 服务器 用户证书 &hearts; 获取证书两种方法： 使用证书授权机构&diams; 生成签名请求（csr）&diams; 将csr发送给CA&diams; 从CA处接收签名 自签名的证书&diams; 自已签发自己的公钥 创建CA和申请证书&hearts; CA配置文件： openssl的配置文件：/etc/pki/tls/openssl.cnf 三种策略：匹配、支持和可选 匹配指要求申请填写的信息跟CA设置信息必须一致，支持指必须填写这项申请信息，可选指可有可无 &hearts; 创建私有CA： 创建所需要的文件&diams; touch /etc/pki/CA/index.txt 生成证书索引数据库文件&diams; echo 01 &gt; /etc/pki/CA/serial 指定第一个颁发证书的序列号 CA自签证书&diams; 生成私钥&diams; cd /etc/pki/CA/&diams; (umask 066; openssl genrsa -out /etc/pki/CA/private/cakey.pem 2048) 生成自签名证书&diams; openssl req -new -x509 –ke &raquo; -new: 生成新证书签署请求 &raquo; -x509: 专用于CA生成自签证书 &raquo; -key: 生成请求时用到的私钥文件 &raquo; -days n：证书的有效期限 &raquo; -out /PATH/TO/SOMECERTFILE: 证书的保存路径&diams; /etc/pki/CA/private/cakey.pem -days 7300 -out&diams; /etc/pki/CA/cacert.pem &hearts; 颁发证书 在需要使用证书的主机生成证书请求 &diams; 给web服务器生成私钥 &raquo; (umask 066; openssl genrsa -out/etc/pki/tls/private/test.key 2048) &diams; 生成证书申请文件 &raquo; openssl req -new -key /etc/pki/tls/private/test.key-days 365 -out etc/pki/tls/test.csr 将证书请求文件传输给CA CA签署证书，并将证书颁发给请求者 &diams; openssl ca -in /tmp/test.csr –out/etc/pki/CA/certs/test.crt -days 365 &raquo; 注意：默认国家，省，公司名称三项必须和CA一致 查看证书中的信息： 1openssl x509 -in /PATH/FROM/CERT_FILE -noout -text|issuer|subject|serial|dates &diams; openssl ca -status SERIAL 查看指定编号的证书状态 &hearts; 吊销证书 在客户端获取要吊销的证书的serial &diams; openssl x509 -in /PATH/FROM/CERT_FILE -noout -serial -subject 在CA上，根据客户提交的serial与subject信息，对比检验是否与index.txt文件中的信息一致&diams; 吊销证书：&raquo; openssl ca -revoke /etc/pki/CA/newcerts/SERIAL.pem 指定第一个吊销证书的编号,注意：第一次更新证书吊销列表前，才需要执行&diams; echo 01 &gt; /etc/pki/CA/crlnumber 更新证书吊销列表 &diams; openssl ca -gencrl -out /etc/pki/CA/crl.pem 查看crl文件：&diams; openssl crl -in /etc/pki/CA/crl.pem -noout -text &hearts; 示例，可以在同一服务器上操作。 创建文件、并生成私钥 1cd /etc/pki/CA;touch index.txt;echo 01 &gt; serial;(umask 077;openssl genrsa -out private/cakey.pem 2048) CA服务器端: 国家，省，公司必须保持一致，如有特殊情况需改配置文件 CA客户端&diams; 把生成的证书发给服务端 scp app.csr root@192.168.11.138:/opt/ 颁发证书并验证 查看证书&diams; openssl x509 -in certs/app.crt -noout -text&hearts; 故障整理12345Using configuration from /etc/pki/tls/openssl.cnfunable to load number from /etc/pki/CA/serialerror while loading serial number140226921523088:error:0D066096:asn1 encoding routines:a2i_ASN1_INTEGER:short line:f_int.c:210:解决办法 echo 00 &gt; /etc/pki/CA/serial 从初始值开始 openssl生成随机数&diams; 成随机数脚本中常用： openssl rand -base64|-hex NUM&diams; NUM: 表示字节数；-hex时，每个字符为十六进制，相当于4位二进制，出现的字符数为NUM*2 示例：生成10位随机字符方法1234567openssl rand -base64 30 | tr -dc '[:alnum:]'| head -c10 |xargsopenssl rand -hex 5#其它的方法cat /dev/urandom | tr -dc '[:alnum:]' | head -c10 | xargsecho $RANDOM | md5sum | head -c10|xargs#生成指定位数的数字 1-100为例echo $[RANDOM%100+1] SSHSSH协议介绍&hearts; ssh协议是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。 ssh: secure shell, protocol, 22/tcp, 安全的远程登录 具体的软件实现：&diams; OpenSSH: ssh协议的开源实现，CentOS默认安装&diams; dropbear：另一个开源实现 &hearts; SSH协议版本 v1: 基于CRC-32做MAC，不安全；man-in-middle v2：双方主机协议选择安全的MAC方式 基于DH算法做密钥交换，基于RSA或DSA实现身份认证 &hearts; 两种方式的用户登录认证： 基于password 基于key Openssh软件openssh软件介绍&hearts; 相关包： openssh openssh-clients openssh-server &hearts; 工具： 基于C/S结构 Client: ssh, scp, sftp，slogin&diams; Windows客户端：&raquo; xshell, putty, securecrt, sshsecureshellclient Server: sshd ssh客户端&hearts; ssh, 配置文件：/etc/ssh/ssh_config Host PATTERN &hearts; 格式： ssh [user@]host [COMMAND] ssh [-l user] host [COMMAND] &hearts; 常见选项 -p port：远程服务器监听的端口 -b：指定连接的源IP -v：调试模式 -X：支持x11转发 结合Xstart 可以实现远程桌面的效果 -t：强制伪tty分配 用于跳跃连接&diams; ssh -t remoteserver1 ssh remoteserver2 允许实现对远程系统经验证地加密安全访问 当用户远程连接ssh服务器时，会复制ssh服务器/etc/ssh/ssh_host * key.pub（CentOS7默认是ssh_host_ecdsa_key.pub）文件中的公钥到客户机的 ~ ./ssh/know_hosts中。下次连接时，会自动匹配相应私钥，不能匹配，将拒绝连接 &hearts; ssh服务登录验证方式： 用户/口令 基于密钥 &hearts; 基于用户和口令登录验证 客户端发起ssh请求，服务器会把自己的公钥发送给用户 用户会根据服务器发来的公钥对密码进行加密 加密后的信息回传给服务器，服务器用自己的私钥解密，如果密码正确，则用户登录成功 基于用户名口令登录验证 &hearts; 基于密钥的登录方式 首先在客户端生成一对密钥（ssh-keygen） 并将客户端的公钥ssh-copy-id 拷贝到服务端 当客户端再次发送一个连接请求，包括ip、用户名 服务端得到客户端的请求后，会到authorized_keys中查找，如果有响应的IP和用户，就会随机生成一个字符串，例如：acdf 服务端将使用客户端拷贝过来的公钥进行加密，然后发送给客户端 得到服务端发来的消息后，客户端会使用私钥进行解密，然后将解密后的字符串发送给服务端 服务端接受到客户端发来的字符串后，跟之前的字符串进行对比，如果一致，就允许免密码登录 示例 &hearts; 基于密钥的认证： 在客户端生成密钥对&diams; ssh-keygen -t rsa -P”” 把公钥文件传输至远程服务器对应用户的家目录&diams; ssh-copy-id [-i [identity_file]] [user@]host 测试 在SecureCRT或Xshell实现基于key验证 ssh服务端&hearts; 服务器端：sshd, 配置文件: /etc/ssh/sshd_config 常用参数：&diams; Port&diams; ListenAddress ip&diams; LoginGraceTime 2m&diams; PermitRootLogin yes&diams; StrictModes yes 检查.ssh/文件的所有者，权限等&diams; MaxAuthTries 6&diams; MaxSessions 10 同一个连接最大会话&diams; PubkeyAuthentication yes&diams; PermitEmptyPasswords no&diams; PasswordAuthentication yes&diams; GatewayPorts no&diams; ClientAliveInterval：单位:秒&diams; ClientAliveCountMax：默认3&diams; UseDNS yes&diams; GSSAPIAuthentication yes 提高速度可改为no&diams; MaxStartups 未认证连接最大值，默认值10&diams; Banner /path/file&diams; 限制可登录用户的办法：&raquo; AllowUsers user1 user2 user3&raquo; DenyUsers&raquo; AllowGroups &raquo; DenyGroups ssh服务的最佳实践&hearts; sshd配置 建议使用非默认端口 禁止使用protocol version 1 限制可登录用户 设定空闲会话超时时长 利用防火墙设置ssh访问策略 仅监听特定的IP地址 基于口令认证时，使用强密码策略 使用基于密钥的认证 禁止使用空密码 禁止root用户直接登录 限制ssh的访问频度和并发在线数 经常分析日志 常用命令scp命令：&hearts; scp [options] SRC… DEST/&hearts; 两种方式： scp [options] [user@]host:/sourcefile /destpath scp [options] /sourcefile [user@]host:/destpath &hearts; 常用选项： 压缩数据流 递归复制 保持原文件的属性信息 静默模式 指明remote host的监听的端口 rsync命令&hearts; 基于ssh和rsh服务实现高效率的远程系统之间复制文件&hearts; 使用安全的shell连接做为传输方式 rsync –av /etc server1:/tmp 复制目录和目录下文件 rsync –av /etc/ server1:/tmp 只复制目录下文件 &hearts; 比scp更快，只复制不同的文件 选项：&diams; -n 模拟复制过程&diams; -v 显示详细过程&diams; -r 递归复制目录树&diams; -p 保留权限&diams; -t 保留时间戳&diams; -g 保留组信息&diams; -o 保留所有者信息&diams; -l 将软链接文件本身进行复制（默认）&diams; -L 将软链接文件指向的文件复制&diams; -a 存档，相当于–rlptgoD，但不保留ACL（-A）和SELinux属性（-X） 更改身份sudo&hearts; sudo程序介绍 作用：允许用户透过安全的方式使用特殊的权限运行程序。（通常为系统的超级用户）、授权某些用户运行某些命令。 来自sudo包，man 5 sudoers sudo为系统管理员提供配置文件，允许系统管理员集中地管理用户的使用权限和使用的主机 &hearts; sudo配置文件 配置文件：/etc/sudoers, /etc/sudoers.d/ 时间戳文件：/var/db/sudo 日志文件：/var/log/secure 配置文件支持使用通配符glob：&diams; ？:任意单一字符&diams; * ：匹配任意长度字符&diams; [wxc]:匹配其中一个字符&diams; [!wxc]:除了这三个字符的其它字符&diams; \x : 转义&diams; [[alpha]] :字母 示例： /bin/ls [[alpha]]* 配置文件规则有两类；&diams; 别名定义:不是必须的&diams; 授权规则:必须的 &hearts; sudo基本配置 授权规则格式：&diams; 用户 登入主机=(代表用户) 命令 示例：&diams; root ALL=(ALL) ALL 格式说明：&diams; user: 运行命令者的身份&diams; host: 通过哪些主机&diams; (runas)：以哪个用户的身份&diams; command: 运行哪些命令 &hearts; 示例：12345678#编辑配置文件vim /etc/sudoers#指定用户从那个主机运行哪个用户的命令，多个命令用逗号割开。fang ALL=(root) /sbin/shutdown -r now, /bin/cat#检查语法visudo -c#用suod命令来执行授权的命令sudo /bin/cat /etc/passwd]]></content>
      <categories>
        <category>linuxapp</category>
      </categories>
      <tags>
        <tag>linuxapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWK]]></title>
    <url>%2F2018%2F09%2F11%2FAWK%2F</url>
    <content type="text"><![CDATA[AWKawk介绍 awk：Aho, Weinberger, Kernighan，报告生成器，格式化文本输出 有多种版本：New awk（nawk），GNU awk（ gawk） gawk：模式扫描和处理语言 基本用法：&diams;awk [options] ‘program’ var=value file&diams;awk [options] -f programfile var=value file&diams;awk [options] ‘BEGIN{ action;… } pattern{ action;… } END{ action;… }’ file&diams;awk 程序通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块，共3部&diams;分组成、program通常是被单引号或双引号中 选项：&diams;-F 指明输入时用到的字段分隔符&diams;-v var=value: 自定义变量 awk语言 基本格式：awk [options] ‘program’ file… program:pattern{action statements;..} pattern和action：&diams; pattern部分决定动作语句何时触发及触发事件 BEGIN,END&diams; action statements对数据进行处理，放在{}内指明 print, printf 分割符、域和记录&diams;awk执行时，由分隔符分隔的字段（域）标记$1,$2..$n称为域标识。$0为所有域，注意：和shell中变量$符含义不同&diams;文件的每一行称为记录&diams;省略action，则默认执行 print $0 的操作 awk工作原理 第一步：执行BEGIN{action;… }语句块中的语句 第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ action;… }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。 第三步：当读至输入流末尾时，执行END{action;…}语句块 BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中 END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块 pattern语句块中的通用命令是最重要的部分，也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块 awk变量 变量：内置和自定义变量 FS：输入字段分隔符，默认为空白字符&diams; awk -v FS=’:’ ‘{print $1,FS,$3}’ /etc/passwd&diams; awk –F: ‘{print $1,$3,$7}’ /etc/passwd OFS：输出字段分隔符，默认为空白字符&diams; awk -v FS=‘:’ -v OFS=‘:’ ‘{print $1,$3,$7}’ /etc/passwd RS：输入记录分隔符，指定输入时的换行符&diams;awk -v RS=’ ‘ ‘{print }’ /etc/passwd ORS：输出记录分隔符，输出时用指定符号代替换行符&diams;awk -v RS=’ ‘ -v ORS=’###’‘{print }’ /etc/passwd NF：字段数量&diams;awk -F： ‘{print NF}’ /etc/fstab,引用内置变量不用$&diams;awk -F: ‘{print $(NF-1)}’ /etc/passwd NR：记录号&diams;awk ‘{print NR}’ /etc/fstab ; awk END’{print NR}’ /etc/fstab FNR：各文件分别计数,记录号&diams;awk ‘{print FNR}’ /etc/fstab /etc/inittab FILENAME：当前文件名&diams;awk ‘{print FILENAME}’ /etc/fstab ARGC：命令行参数的个数&diams;awk ‘{print ARGC}’ /etc/fstab /etc/inittab&diams;awk ‘BEGIN {print ARGC}’ /etc/fstab /etc/inittab ARGV：数组，保存的是命令行所给定的各参数&diams;awk ‘BEGIN {print ARGV[0]}’ /etc/fstab /etc/inittab&diams;awk ‘BEGIN {print ARGV[1]}’ /etc/fstab /etc/inittab 自定义变量(区分字符大小写)&diams;-v var=value&diams; 在program中直接定义 示例123awk -v test='hello gawk' '&#123;print test&#125;' /etc/fstabawk -v test='hello gawk' 'BEGIN&#123;print test&#125;' awk 'BEGIN&#123;test="hello,gawk";print test&#125;' printf命令 格式化输出：printf “FORMAT”, item1, item2,&diams;必须指定FORMAT&diams;不会自动换行，需要显式给出换行控制符，\n&diams; FORMAT中需要分别为后面每个item指定格式符 格式符：与item一一对应&diams;%c: 显示字符的ASCII码&diams;%d, %i: 显示十进制整数&diams;%e, %E:显示科学计数法数值&diams;%f：显示为浮点数&diams;%g, %G：以科学计数法或浮点形式显示数值&diams;%s：显示字符串&diams;%u：无符号整数&diams;%%: 显示%自身 修饰符：&diams;：#[.#]：第一个数字控制显示的宽度；第二个#表示小数点后精度，%3.1f&diams;-: 左对齐（默认右对齐） %-15s&diams;+：显示数值的正负符号 %+d printf示例1234567awk -F: ‘&#123;printf "%s",$1&#125;’ /etc/passwdawk -F: ‘&#123;printf "%s\n",$1&#125;’ /etc/passwdawk -F: '&#123;printf "%-20s %10d\n",$1,$3&#125;' /etc/passwdawk -F: ‘&#123;printf "Username: %s\n",$1&#125;’ /etc/passwdawk -F: ‘&#123;printf “Username: %s,UID:%d\n",$1,$3&#125;’ /etc/passwdawk -F: ‘&#123;printf "Username: %15s,UID:%d\n",$1,$3&#125;’ /etc/passwdawk -F: ‘&#123;printf "Username: %-15s,UID:%d\n",$1,$3&#125;’ /etc/passwd AWK操作符 比较操作符：&diams;==, !=, &gt;, &gt;=, &lt;, &lt;= 模式匹配符：&diams; ~：左边是否和右边匹配包含 !~：是否不匹配 1234awk –F: '$0 ~ /root/&#123;print $1&#125;‘ /etc/passwdawk '$0~“^root"' /etc/passwdawk '$0 !~ /root/‘ /etc/passwdawk –F: ‘$3==0’ /etc/passwd 逻辑操作符：与&amp;&amp;，或||，非! 1234awk –F: '$3&gt;=0 &amp;&amp; $3&lt;=1000 &#123;print $1&#125;' /etc/passwdawk -F: '$3==0 || $3&gt;=1000 &#123;print $1&#125;' /etc/passwdawk -F: ‘!($3==0) &#123;print $1&#125;' /etc/passwd awk -F: ‘!($3&gt;=500) &#123;print $3&#125;’ /etc/passwd 函数调用： function_name(argu1, argu2, …) 条件表达式（三目表达式）：&diams;selector?if-true-expression:if-false-expression&diams;awk -F: ‘{$3&gt;=1000?usertype=”Common User”:usertype=”Sysadmin or SysUser”;printf”%15s:%-s\n”,$1,usertype}’ /etc/passwd awk PATTERN PATTERN:根据pattern条件，过滤匹配的行，再做处理&diams;如果未指定：空模式，匹配每一行&diams; /regular expression/：仅处理能够模式匹配到的行，需要用/ /括起来 12awk '/^UUID/&#123;print $1&#125;' /etc/fstabawk '!/^UUID/&#123;print $1&#125;' /etc/fstab &diams; relational expression: 关系表达式，结果为“真”才会被处理真：结果为非0值，非空字符串假：结果为空字符串或0值 123456awk -F: 'i=1;j=1&#123;print i,j&#125;' /etc/passwdawk ‘!0’ /etc/passwd ; awk ‘!1’ /etc/passwdawk –F: '$3&gt;=1000&#123;print $1,$3&#125;' /etc/passwdawk -F: '$3&lt;1000&#123;print $1,$3&#125;' /etc/passwdawk -F: '$NF=="/bin/bash"&#123;print $1,$NF&#125;' /etc/passwdawk -F: '$NF ~ /bash$/&#123;print $1,$NF&#125;' /etc/passwd line ranges：行范围&diams;startline,endline：/pat1/,/pat2/ 不支持直接给出数字格式&diams;awk -F: ‘/^root>/,/^nobody>/{print $1}’ /etc/passwd&diams;awk -F: ‘(NR&gt;=10&amp;&amp;NR&lt;=20){print NR,$1}’ /etc/passwd BEGIN/END模式&diams;BEGIN{}: 仅在开始处理文件中的文本之前执行一次&diams;END{}：仅在文本处理完成之后执行一次1234567891011 awk -F : 'BEGIN &#123;print "USER USERID"&#125; &#123;print $1":"$3&#125; END&#123;print "end file"&#125;'/etc/passwd awk -F : '&#123;print "USER USERID“;print $1":"$3&#125; END&#123;print "end file"&#125;' /etc/passwd awk -F: 'BEGIN&#123;print " USER UID \n--------------- "&#125;&#123;print $1,$3&#125;' /etc/passwd awk -F: 'BEGIN&#123;print " USER UID \n--------------- "&#125;&#123;print $1,$3&#125;'END&#123;print"=============="&#125; /etc/passwd seq 10 |awk ‘i=0’ seq 10 |awk ‘i=1’ seq 10 | awk 'i=!i‘ seq 10 | awk '&#123;i=!i;print i&#125;‘ seq 10 | awk ‘!(i=!i)’ seq 10 |awk -v i=1 'i=!i' awk action 常用的action分类&diams;Expressions:算术，比较表达式等&diams;Control statements：if, while等&diams;Compound statements：组合语句&diams;input statements&diams;output statements：print等 awk控制语句 { statements;… } 组合语句 if(condition) {statements;…} if(condition) {statements;…} else {statements;…} while(conditon) {statments;…} do {statements;…} while(condition) for(expr1;expr2;expr3) {statements;…} break continue delete array[index] delete array exit awk控制语句if-else 语法：if(condition){statement;…}[else statement] if(condition1){statement1}else if(condition2){statement2}else{statement3} 使用场景：对awk取得的整行或某个字段做条件判断123456789awk -F: '&#123;if($3&gt;=1000)print $1,$3&#125;' /etc/passwdawk -F: '&#123;if($NF=="/bin/bash") print $1&#125;' /etc/passwdawk '&#123;if(NF&gt;5) print $0&#125;' /etc/fstabawk -F: '&#123;if($3&gt;=1000) &#123;printf "Common user: %s\n",$1&#125; else &#123;printf "root or Sysuser: %s\n",$1&#125;&#125;'/etc/passwdawk -F: '&#123;if($3&gt;=1000) printf "Common user: %s\n",$1; else printf "root or Sysuser: %s\n",$1&#125;'/etc/passwddf -h|awk -F% '/^\/dev/&#123;print $1&#125;'|awk '$NF&gt;=80&#123;print $1,$5&#125;‘awk 'BEGIN&#123; test=100;if(test&gt;90)&#123;print "very good“&#125;else if(test&gt;60)&#123; print "good"&#125;else&#123;print "no pass"&#125;&#125;' awk控制语句 while循环 语法：while(condition){statement;…} 条件“真”，进入循环；条件“假”，退出循环 使用场景：&diams;对一行内的多个字段逐一类似处理时使用&diams;对数组中的各元素逐一处理时使用 1234awk '/^[[:space:]]*linux16/&#123;i=1;while(i&lt;=NF)&#123;print $i,length($i); i++&#125;&#125;' /etc/grub2.cfgawk ‘/^[[:space:]]*linux16/&#123;i=1;while(i&lt;=NF) &#123;if(length($i)&gt;=10) &#123;print$i,length($i)&#125;; i++&#125;&#125;’ /etc/grub2.cfg do-while循环 语法：do {statement;…}while(condition) 意义：无论真假，至少执行一次循环体1awk 'BEGIN&#123; total=0;i=0;do&#123; total+=i;i++;&#125;while(i&lt;=100);print total&#125;’ for循环 语法：for(expr1;expr2;expr3) {statement;…} 常见用法：&diams;for(variable assignment;condition;iteration process) {for-body} 特殊用法：能够遍历数组中的元素&diams;语法：for(var in array) {for-body}12awk '/^[[:space:]]*linux16/&#123;for(i=1;i&lt;=NF;i++) &#123;print $i,length($i)&#125;&#125;'/etc/grub2.cfg switch语句 语法：switch(expression) {case VALUE1 or /REGEXP/: statement1; caseVALUE2 or /REGEXP2/: statement2; …; default: statementn} break和continue&diams;awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++){if(i%2==0)continue;sum+=i}print sum}&diams;awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++){if(i==66)break;sum+=i}print sum}‘ next&diams;提前结束对本行处理而直接进入下一行处理（awk自身循环）awk -F: ‘{if($3%2!=0) next; print $1,$3}’ /etc/passwd awk数组]]></content>
      <categories>
        <category>linuxshell</category>
      </categories>
      <tags>
        <tag>linuxshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议和管理]]></title>
    <url>%2F2018%2F09%2F10%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[网络协议和管理网络模型分层OSI 模型OSI七层结构&hearts; OSI 模型的七层结构 七层结构&diams; 示图 各层之间联系&diams; 示图 数据封装&diams; 示图 数据解封&diams; 示图 相关概念对等通信&hearts; 对等通信 同层之间的数据传输&diams; 示图 PDU&hearts; PDU PDU: Protocol Data Unit,协议数据单元是指对等层次之间传递的数据单位 物理层的 PDU是数据位 bit 数据链路层的 PDU是数据帧 frame 网络层的PDU是数据包 packet 传输层的 PDU是数据段 segment 其他更高层次的PDU是消息 message 三种通讯模式&hearts; 单播 单播通讯&diams; 示图 &hearts; 广播 单播通讯&diams; 示图 &hearts; 组播 组播通讯&diams; 示图 局域网TCP/IP 协议栈TCP/IP协议栈介绍&hearts; TCP/IP协议栈相关概念 Transmission Control Protocol/Internet Protocol传输控制协议/因特网互联协议 TCP/IP是一个Protocol Stack，包括TCP、IP、UDP、ICMP、RIP、TELNET、FTP、SMTP、ARP等许多协议 最早发源于美国国防部（缩写为DoD）的因特网的前身ARPA网项目，1983年1月1日，TCP/IP取代了旧的网络控制协议NCP，成为今天的互联网和局域网的基石和标准,由互联网工程任务组负责维护 共定义了四层 和ISO参考模型的分层有对应关系 TCP/IP分层&hearts; TCP/IP堆栈 模型结构&diams; 示图 TCP/IP堆栈与ISO七层对比&diams; 示图 TCP协议TCP相关概念&hearts; TCP介绍 工作在传输层 面向连接协议 全双工协议 半关闭 错误检查 将数据打包成段，排序 确认机制 数据恢复，重传 流量控制，滑动窗口 拥塞控制，慢启动和拥塞避免算法 &hearts; TCP包头 示图 源端口、目标端口：计算机上的进程要和其他进程通信是要通过计算机端口的，而一个计算机端口某个时刻只能被一个进程占用，所以通过指定源端口和目标端口，就可以知道是哪两个进程需要通信。源端口、目标端口是用16位表示的，可推算计算机的端口个数为2^16个 序列号：表示本报文段所发送数据的第一个字节的编号。在TCP连接中所传送的字节流的每一个字节都会按顺序编号。由于序列号由32位表示，所以每2^32个字节，就会出现序列号回绕，再次从 0 开始 确认号：表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。也就是告诉发送方：我希望你（指发送方）下次发送的数据的第一个字节数据的编号为此确认号 数据偏移：表示TCP报文段的首部长度，共4位，由于TCP首部包含一个长度可变的选项部分，需要指定这个TCP报文段到底有多长。它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。该字段的单位是32位(即4个字节为计算单位），4位二进制最大表示15，所以数据偏移也就是TCP首部最大60字节 URG：表示本报文段中发送的数据是否包含紧急数据。后面的紧急指针字段（urgent pointer）只有当URG=1时才有效 ACK：表示是否前面确认号字段是否有效。只有当ACK=1时，前面的确认号字段才有效。TCP规定，连接建立后，ACK必须为1,带ACK标志的TCP报文段称为确认报文段 PSH：提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间。如果为1，则表示对方应当立即把数据提交给上层应用，而不是缓存起来，如果应用程序不将接收到的数据读走，就会一直停留在TCP接收缓冲区中 RST：如果收到一个RST=1的报文，说明与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。或者说明上次发送给主机的数据有问题，主机拒绝响应，带RST标志的TCP报文段称为复位报文段 SYN：在建立连接时使用，用来同步序号。当SYN=1，ACK=0时，表示这是一个请求建立连接的报文段；当SYN=1，ACK=1时，表示对方同意建立连接。SYN=1，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中SYN才置为1，带SYN标志的TCP报文段称为同步报文段 FIN：表示通知对方本端要关闭连接了，标记数据是否发送完毕。如果FIN=1，即告诉对方：“我的数据已经发送完毕，你可以释放连接了”，带FIN标志的TCP报文段称为结束报文段 TCP协议PORT&hearts; TCP端口 传输层通过port号，确定应用层协议 tcp：传输控制协议，面向连接的协议；通信前需要建立虚拟链路；结束后拆除链路 0-65535 IANA:互联网数字分配机构（负责域名，数字资源，协议分配）&diams; 0-1023：系统端口或特权端口(仅管理员可用) ，众所周知，永久的分配给固定的系统应用使用，22/tcp(ssh), 80/tcp(http), 443/tcp(https)&diams; 1024-49151：用户端口或注册端口，但要求并不严格，分配给程序注册为某应用使用，1433/tcp(SqlServer), 1521/tcp(oracle),3306/tcp(mysql),11211/tcp/udp (memcached) 常见端口&diams; 示图 TCP三次握手&hearts; TCP三次握手 三次握手过程&diams; 示图 TCP四次挥手&hearts; TCP四次挥手 四次挥手过程&diams; 示图]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统启动和内核管理]]></title>
    <url>%2F2018%2F09%2F08%2F%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%92%8C%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[系统启动和内核管理Linux组成&hearts; Linux: kernel+rootfs kernel: 进程管理、内存管理、网络管理、驱动程序、文件系统、安全功能 rootfs:程序和glibc 库：函数集合, function, 调用接口（头文件负责描述）&diams; 过程调用：procedure，无返回值&diams; 函数调用：function 程序：二进制执行文件 &hearts; 内核设计流派： 单内核(monolithic kernel)：Linux&diams; 把所有功能集成于同一个程序 微内核(micro kernel)：Windows, Solaris&diams; 每种功能使用一个单独子系统实现 &hearts; Linux内核特点： 支持模块化：.ko（内核对象）&diams; 如：文件系统，硬件驱动，网络协议等&diams; 支持内核模块的动态装载和卸载 &hearts; 组成部分： 核心文件：/boot/vmlinuz-VERSION-release&diams; ramdisk：辅助的伪根系统&diams; CentOS 5: /boot/initrd-VERSION-release.img&diams; CentOS 6,7: /boot/initramfs-VERSION-release.img 模块文件：/lib/modules/VERSION-release CentOS6启动流程 总体流程 Power On 加载BIOS的硬件信息，获取第一个启动设备 读取第一个启动设备MBR的引导加载程序(grub)的启动信息 加载核心操作系统的核心信息，核心开始解压缩，并尝试驱动所有的硬件设备 核心执行init程序，并获取默认的运行信息 init程序执行/etc/rc.d/rc.sysinit文件 启动核心的外挂模块 init执行运行的各个批处理文件(scripts) init执行/etc/rc.d/rc.local 执行/bin/login程序，等待用户登录 登录之后开始以Shell控制主机 第一阶段&hearts; POST：Power-On-Self-Test，加电自检，是BIOS功能的一个主要部分。负责完成对CPU、主板、内存、硬盘子系统、显示子系统、串并行接口、键盘等硬件情况的检测 ROM：BIOS，Basic Input and Output System，保存着有关计算机系统最重要的基本输入输出程序，系统信息设置、开机加电自检程序和系统启动自举程序等 RAM：CMOS互补金属氧化物半导体，保存各项参数的设定按次序查找引导设备，第一个有引导程序的设备为本次启动设备 &hearts; bootloader: 引导加载器，引导程序 windows: ntloader，仅是启动OS Linux：功能丰富，提供菜单，允许用户选择要启动系统或不同的内核版本；把用户选定的内核装载到内存中的特定空间中，解压、展开，并把系统控制权移交给内核 &diams; LILO：LInux LOader &diams; GRUB: GRand Unified Bootloader GRUB 0.X: GRUB Legacy， GRUB2 第二阶段&hearts; 加载MBR MBR：446: bootloader, 64: 分区表, 2: 55AA GRUB: primary boot loader : 1st stage，1.5 stage secondary boot loader ：2nd stage，分区文件 第三阶段&hearts; kernel：自身初始化 探测可识别到的所有硬件设备 加载硬件驱动程序（借助于ramdisk加载驱动） 以只读方式挂载根文件系统 运行用户空间的第一个应用程序：/sbin/init &hearts; ramdisk：内核中的特性之一：使用缓冲和缓存来加速对磁盘上的文件访问，并加载相应的硬件驱动 ramdisk –&gt; ramfs 提高速度&diams; CentOS 5: initrd 工具程序：mkinitrd&diams; CentOS 6，7: initramfs 工具程序：mkinitrd, dracut &hearts; 系统初始化： POST –&gt; BootSequence (BIOS) –&gt; Bootloader(MBR) –&gt;kernel(ramdisk) –&gt; rootfs(只读) –&gt; init（systemd） &hearts; ramdisk文件的制作： mkinitrd命令:为当前正在使用的内核重新制作ramdisk文件 mkinitrd /boot/initramfs-$(uname -r).img $(uname -r) dracut命令、为当前正在使用的内核重新制作ramdisk文件 dracut /boot/initramfs-$(uname -r).img $(uname -r) 第四阶段&hearts; init程序的类型：SysV: init, CentOS 5之前 配置文件：/etc/inittab&diams; Upstart: init,CentOS 6 配置文件：/etc/inittab, /etc/init/*.conf Systemd：systemd, CentOS 7&diams; 配置文件：/usr/lib/systemd/system /etc/systemd/system &hearts; /sbin/init CentOS6之前 运行级别：为系统运行或维护等目的而设定；0-6：7个级别&diams; 0：关机&diams; 1：单用户模式(root自动登录), single, 维护模式&diams; 2: 多用户模式，启动网络功能，但不会启动NFS；维护模式&diams; 3：多用户模式，正常模式；文本界面&diams; 4：预留级别；可同3级别&diams; 5：多用户模式，正常模式；图形界面&diams; 6：重启 默认级别：3, 5 切换级别：init # 查看级别：runlevel ; who -r &hearts; init读取其初始化文件：/etc/inittab 初始运行级别(RUN LEVEL) 系统初始化脚本 对应运行级别的脚本目录 捕获某个关键字顺序 定义UPS电源终端/恢复脚本 在虚拟控制台生成getty 在运行级别5初始化X &hearts; 配置文件：/etc/inittab 每一行格式： id:runlevel:action:process&diams; id：是惟一标识该项的字符序列&diams; runlevels： 定义了操作所使用的运行级别&diams; 定义了要执行的进程&diams; action： 指定了要执行的特定操作 &raquo; wait: 切换至此级别运行一次 &raquo; respawn：此process终止，就重新启动之 &raquo; initdefault：设定默认运行级别；process省 &raquo; sysinit：设定系统初始化方式 示例：&diams; id:3:initdefault:&diams; si::sysinit:/etc/rc.d/rc.sysinit&diams; l0:0:wait:/etc/rc.d/rc 0&diams; l1:1:wait:/etc/rc.d/rc 1…&diams; l6:6:wait:/etc/rc.d/rc 6&diams; ca::ctrlaltdel:/sbin/shutdown -t3 -r now 第五阶段&hearts; init程序执行/etc/rc.d/rc.sysinit文件 设置主机名 设置欢迎信息 激活udev和selinux 挂载/etc/fstab文件中定义的文件系统 检测根文件系统，并以读写方式重新挂载根文件系统 设置系统时钟 激活swap设备 根据/etc/sysctl.conf文件设置内核参数 激活lvm及software raid设备 加载额外设备的驱动程序 清理操作 第六阶段&hearts; init执行运行的各个批处理文件(scripts) 关闭或启动对应级别的服务 第七阶段&hearts; init执行/etc/rc.d/rc.local （源码安装的启动程序可以放在此处） 第八阶段&hearts; 设置登录终端 各阶段故障处理grub配置文件详解&hearts; grub.conf 示图如下 &hearts; 选项参数如下 示图如下123456789101112default=#: 设定默认启动的菜单项；落单项(title)编号从0开始 timeout=#： 指定菜单项等待选项选择的时长 splashimage= (hd#,#)/PATH/XPM_FILE：菜单背景图片文件路径 password [--md5] STRING: 启动菜单编辑认证 生成grub口令 grub-md5-crypt grub-crypt hiddenmenu： 隐藏菜单 title TITLE： 定义菜单项“标题”, 可出现多次root (hd#,#)： 查找stage2及kernel文件所在设备分区；为grub的根kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]：启动的内核initrd /PATH/TO/INITRAMFS_FILE: 内核匹配的ramfs文件 grub 1 阶段故障&hearts; 删除主引导记录MBR的前446字节 人为操作&diams; hexdump -C -n 512 /dev/sda&diams; dd if=/dev/zer0 of=/dev/sda bs=1 count=446 故障现象如下 &hearts; 修复方法 bios设置光盘启动，并进入救援模式 修复如图所示 grub 1.5阶段故障&hearts; MBR后27扇区 人为操作&diams; dd if=/dev/zer0 of=/dev/sda bs=1 count=12000 seek 512 (跳过分区表) 故障现象如下 &hearts; 修复方法 同1阶段故障修复方法一样 grub 2阶段故障&hearts; 删除/boot/grub 目录 故障现象如下 &hearts; 修复方法 第一步: 跟1 1.5阶段一样的方法 第二步：如图 删除/boot 分区及 etc/fstab文件修复&hearts; /boot 文件损坏，/etc/fstab文件损坏 第一步： 救援模式，测试出根的位置并新建fstab文件 第二步： 在创建好fstab文件基础上，然后切根 第三步： 如图 grub通用修复方法&hearts; 总结 光盘救援模式，查看根挂载位置&diams; lsblk 切根，挂载光盘&diams; chroot /mnt/sysimage&diams; mount /dev/sr0 /media 强制安装内核&diams; rpm -ivh /media/Pakcage/kerne- –force 安装grub&diams; grub-install /dev/sda 手动创建grub目录下的 grub.conf文件 注（如有问题，先关闭防火墙，selinux) Centos7 Systemed特性启动过程 POST –&gt; Boot Sequence –&gt; Bootloader –&gt; kernel + initramfs(initrd) –&gt; rootfs –&gt; /sbin/init init:&diams; CentOS 5: SysV init&diams; CentOS 6: Upstart&diams; CentOS 7: Systemd Systemd作用： 系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其它进程 Systemd新特性： 系统引导时实现服务并行启动 按需启动守护进程 自动化的服务依赖关系管理 同时采用socket式与D-Bus总线式激活服务 系统状态快照 向后兼容sysv init脚本 systemctl命令固定不变，不可扩展 非由systemd启动的服务，systemctl无法与之通信和控制 Systemd类型及unit unit表示不同类型的systemd对象，通过配置文件进行标识和配置；文件中主要包含了系统服务、监听socket、保存的系统快照以及其它与init相关的信息 Systemctl –t help 查看unit类型 Service unit: 文件扩展名为.service, 用于定义系统服务 Target unit: 文件扩展名为.target，用于模拟实现运行级别 Device unit: .device, 用于定义内核识别的设备 Mount unit: .mount, 定义文件系统挂载点 Socket unit: .socket, 用于标识进程间通信用的socket文件，也可在系统启动时，延迟启动服务，实现按需启动 Snapshot unit: .snapshot, 管理系统快照 Swap unit: .swap, 用于标识swap设备 Automount unit: .automount，文件系统的自动挂载点 Path unit: .path，用于定义文件系统中的一个文件或目录使用,常用于当文件系统变化时，延迟激活服务，如：spool 目录 Systemd配置文件： /usr/lib/systemd/system:每个服务最主要的启动脚本设置，类似于之前的/etc/init.d/ /run/systemd/system：系统执行过程中所产生的服务脚本，比上面目录优先运行 /etc/systemd/system：管理员建立的执行脚本，类似于/etc/rc.d/rcN.d/Sxx类的功能，比上面目录优先运行 Systemd管理服务 CentOS 7: service unit 注意：能兼容早期的服务脚本 命令：systemctl COMMAND name.service 启动：service name start ==&gt; systemctl start name.service 停止：service name stop ==&gt; systemctl stop name.service 重启：service name restart ==&gt; systemctl restart name.service 状态：service name status ==&gt; systemctl status name.service 条件式重启：已启动才重启，否则不做操作 服务查看 列出所有服务单元&diams; systemctl list-units –type=service –all 列出活动状态的所有服务单元&diams; systemctl list-units –type=service 查看服务单元的启用和禁用状态&diams; systemctl list-unit-files –type=service 列出失败的服务&diams; systemctl –failed –type=service 修改主机名 &diams; hostnamectl set-hostname centos7 &diams; exec bash 开机启动服务 查看所有服务的开机自启状态：&diams; chkconfig –list ==&gt; systemctl list-unit-files –type service 查看服务是否开机自启：&diams; chkconfig –list | grep service ==&gt; systemctl is-enabled name.service 设置开机自动启动：&diams; chkconfig on name ==&gt; systemctl enable name.service 取消开机自动启动：&diams; chkconfig off name ==&gt; systemctl disable name.service 查看当前系统的运行级别&diams; cat /etc/inittab ==&gt; systemctl get-default 列出该服务在哪些运行级别下启用和禁用&diams; chkconfig sshd –list&diams; ls /etc/systemd/system/* .wants/sshd.service 破解CentOS7的root口令方法一 启动时任意键暂停启动 按e键进入编辑模式 将光标移动linux16开始的行，添加内核参数rd.break 按ctrl-x启动 mount –o remount,rw /sysroot chroot /sysroot passwd root touch /.autorelabel&diams; 重建标签，如开启selinux 这一步必做 exit reboot 方法二 启动时任意键暂停启动 按e键进入编辑模式 将光标移动linux16开始的行，改为rw init=/sysroot/bin/sh 按ctrl-x启动 chroot /sysroot passwd root touch /.autorelabel exit reboot]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 练习]]></title>
    <url>%2F2018%2F09%2F06%2Fshell-%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[分支练习条件判断练习 编写脚本/root/bin/createuser.sh，实现如下功能：使用一个用户名做为参数，如果指定参数的用户存在，就显示其存在，否则添加之；显示添加的用户的id号等信息 12345678910111213141516171819#!/bin/bash##FileName: createuser.sh#交互输入read -t 30 -p "Please enter a parameter: " num#判断是否为空，如果为空则退出[ -z $num ] &amp;&amp; &#123; echo "You enter a null value" ; exit 2; &#125;#判断用户是否存在id $num &amp;&gt;/dev/nullif [ $? -eq 0 ]then echo "The user you entered already exists" exit 2else useradd $num &amp;&gt;/dev/nullfi echo "The User $num id is `id $num`" 编写脚本/root/bin/yesorno.sh，提示用户输入yes或no,并判断用户输入的是yes还是no,或是其它信息 123456789101112131415161718#!/bin/bash##FileName: yesorno.shread -t 30 -p "Please enter yes or no: " varcase $var in[Yy]|[Yy][Ee][Ss]) echo "You typed yes" ;;[Nn]|[Nn][Oo]) echo "You typed no" ;;*) echo "You're not saying yes or no" ;;esac 编写脚本/root/bin/filetype.sh,判断用户输入文件路径，显示其文件类型（普通，目录，链接，其它文件类型） 12345678910111213141516171819202122232425#!/bin/bash##FileName: filetype.shread -t 30 -p "Please enter a file path: " var#判断是否为空[ -z $var ] &amp;&amp; &#123; echo "You enter a null value"; exit 2; &#125;#判断是否为链接if [ -h $var ]then echo "You typed in a soft link"#判断是否为文件，软链接应在文件前面判断elif [ -f $var ]then echo "You're typing in a file"#判断是否为目录elif [ -d $var ]then echo "You enter a directory"else echo "You are entering other types of files"fi 编写脚本/root/bin/checkint.sh,判断用户输入的参数是否为正整数 123456789101112131415161718192021222324252627#!/bin/bash##FileName: checkint.shread -t 30 -p "Please enter a parameter: " var#第一种方法#判断是否为空，为空则退出[ -z $var ] &amp;&amp; &#123; echo "You enter a null value";exit 2;&#125;#用正则表达示匹配是否为数字if [[ $var =~ ^[[:digit:]]+$ ]]then echo "You enter a positive integer"else echo "You're not entering a positive integer"fi#第二种方法#匹配是否全为数字，如果不是全数字num的值不为0num=$(echo $var | grep '[^0-9]' | wc -l)if [ $num -ne 0 ]then echo "You're not entering a positive integer"else echo "You enter a positive integer"fi 循环练习 判断/var/目录下所有文件的类型 1234567891011121314151617181920#!/bin/bash##FileName: var.shfor i in `ls /var`do cd /var if [ -h $i ] then echo "$i This file is a soft link" elif [ -f $i ] then echo "$i This file is a normal file" elif [ -d $i ] then echo "$i This file is a directory" else echo "$i This file is not a common file type" fidone 添加10个用户user1-user10，密码为8位随机字符 12345678910111213141516171819#!/bin/bash##FileName: user.sh[ -e /opt/user.txt ]&amp;&amp; rm -rf /opt/user.txt &amp;&gt;/dev/nullfor i in &#123;1..10&#125;do id user$i &amp;&gt;/dev/null if [ $? -ne 0 ] then useradd user$i &amp;&gt;/dev/null pass=$(openssl rand -hex 4) echo $pass | passwd --stdin user$i &amp;&gt;/dev/null echo "user==user$i password is $pass" &gt;&gt; /opt/user.txt echo "user $user$i is add ok The passwd is in /opt/user.txt" else echo "user$i User already exists" fidone /etc/rc.d/rc5.d目录下分别有多个以K开头和以S开头的文件；分别读取每个文件，以K开头的输出为文件加stop，以S开头的输出为文件名加start，如K34filename stopS66filename start 12345678910111213141516#!/bin/bash##FileName: init.sh[ -e /etc/rc.d/rc5.d.bak ] || cp -r /etc/rc.d/rc5.d&#123;,.bak&#125;for i in `ls /etc/rc5.d`do cd /etc/rc5.d if [[ $i =~ ^S ]] then mv $i $i.start else mv $i $i.stop fidone 编写脚本，提示输入正整数n的值，计算1+2+…+n的总和 1234567891011121314#!/bin/bash##FileName: sum.shread -t 30 -p "Please enter a positive integer: " var[ -z $var ] &amp;&amp; &#123; echo "you input is empty"; exit 2; &#125;sum=0for i in `seq 1 $var`do sum=$(($sum+$i))done echo "The sum of 1..$var is $sum" 计算100以内所有能被3整除的整数之和 123456789101112131415#!/bin/bash##FileName: sum3.shsum=0for i in &#123;1..100&#125;do if [ $(($i%3)) -eq 0 ] then sum=$(($sum+$i)) else true fidone echo "The sum of the Numbers 1..100 that are divisible by 3 sum is $sum" 编写脚本，提示请输入网络地址，如192.168.0.0，判断输入的网段中主机在线状态 12345678910111213141516171819202122#!/bin/bash##FileName: ip.sh#交换互提示 read -t 30 -p "Please enter a segment of IP address such as: 192.168.0.0: " num#判断是否为空[ -z $num ] &amp;&amp; &#123; echo "You input is empty"; exit 2; &#125;#提取ip前段ip=$(echo $num | cut -d "." -f1,2,3)for i in &#123;1..254&#125;do &#123; ping -c1 -w1 $ip.$i &amp;&gt;/dev/null if [ $? -ne 0 ] then echo "The ip $ip.$i is down" else echo "The ip $ip.$i is OK" fi &#125; &amp;done#大括号的作用 并行运行可以加快速度 wait的作用 脚本执行完 直接回到操作界面不加，会卡在最后面wait 打印九九乘法表 1234567891011121314151617181920212223242526#!/bin/bash##FileName: 99.sh# $i用来决定打印的列，$j用来打印对应的行 \c 不换行 \t 用制表符隔开# 最后一个echo 用来换行for i in &#123;1..9&#125;do for j in `seq $i` do #注写先制表\t 不然对不齐 echo -e "$i*$j=$(($i*$j)) \t\c" done echodone#随机颜色的99乘法表#!/bin/bashfor i in &#123;1..9&#125;do for k in `seq $i` do var=$[$RANDOM%6+31] echo -e "\033[5;$var;40m$i*$k=$(($i*$k))\033[0m\t\c" done echodone 在/testdir目录下创建10个html文件,文件名格式为数字N（从1到10）加随机8个字母，如：1AbCdeFgH.html 12345678910#!/bin/bash##FileName: html.sh#脚本执行前，先判断目录是否存在，如果存在则进入目录，如果不存在则创建目录，并进入目录for i in &#123;1..10&#125;do [ -d /testdir ]&amp;&amp; cd /testdir || &#123; mkdir /testdir ; cd /testdir ;&#125; name=$(openssl rand -hex 4) touch $i$name.htmldone 打印等腰三角形 12345678910111213141516171819202122232425262728293031323334#!/bin/bash##FileName: triangle.sh# 打印等腰三角形思路 理解99乘法表的基础上# 空行的个数 == $var(边数）-当前行# 星的个数 == 2*n(当前行)-1read -t 30 -p "Please enter the number of sides of the triangle: " var#判断是否为空if [ -z $var ]then echo "You enter a null value" exit 2#判断是否为纯数字elif [[ ! $var =~ ^[[:digit:]]+$ ]]then echo "You're not entering a pure number" exit 2fifor i in `seq $var`do #打印空格不换行 for j in `seq $[$var-$i]` do echo -n " " done #打印星加了点颜色5为颜色闪烁且不换行 for k in `seq $[2*$i-1]` do echo -e "\033[5;35;40m*\033[0m\c" done #每循环一行 换一下行 echodone while循环练习 编写脚本，求100以内所有正奇数之和 1234567891011121314151617#!/bin/bash##FileName: while1.shsum=0i=1while [ $i -le 100 ]do if [ $(($i%3)) -eq 0 ] then sum=$(($sum+$i)) else true fi let i++done echo "The sum of by 3 totle is $sum" 编写脚本，提示请输入网络地址，如192.168.0.0，判断输入的网段中主机在线状态，并统计在线和离线主机各多少 12345678910111213141516171819202122#!/bin/bash##FileName: ip.shread -t 30 -p "Please enter a network segment such as: 192.168.0.0 : " var[ -z $var ] &amp;&amp; &#123; echo "You input is empty"; exit 2; &#125;ip=$(echo $var | cut -d"." -f1,2,3)echo $ipi=1while [ $i -le 254 ] &amp;&gt;/dev/nulldo &#123; ping -c 1 -w 1 $ip.$i &amp;&gt;/dev/null if [ $? -ne 0 ] then echo "The IP $ip.$i is down" else echo "The IP $ip.$i is ok" fi &#125; &amp; let i++donewait 编写脚本，打印九九乘法表 1234567891011121314#!/bin/bashi=1while [ $i -le 9 ]do j=1 while [ $j -le $i ] do echo -e "$i*$j=$(($i*$j))\t\c" let j++ done echo let i++done 编写脚本，利用变量RANDOM生成10个随机数字，输出这个10数字，并显示其中的最大值和最小值 123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bash#方法一：[ -e /home/num.file ]&amp;&amp; rm -f /home/num.filefor i in &#123;1..10&#125;do num=$(echo $RANDOM) echo $num &gt;&gt; /home/num.file echo $numdone max=$(cat /home/num.file | sort -nr | head -n1) min=$(cat /home/num.file | sort -nr | tail -n1) echo "The Max is $max The Min is $min"#方法二：##!/bin/bash##FileName: random.sh#打印随机列表，不换行的作用是，把随机数跟这个提示在同一行echo -e "Random list: \c"for i in &#123;1..10&#125;do num=$(echo $RANDOM) #第一次循环，只有一个值，即最大值、最小值一样 if [ $i -eq 1 ] then max=$num min=$num fi #如果最大值都小于随机数，那把新值附于最大值 if [ $max -lt $num ] then max=$num #如果最小值都大于随机数，那把新值附于最小值 elif [ $min -gt $num ] then min=$num fi echo -e "$num \c"done #循环中没有换行所有用echo 来换行 echo echo "The Max is $max" echo "The min is $min" 编写脚本，实现打印国际象棋棋盘 123456789101112131415161718192021222324252627282930313233343536#脚本思路#第一：先试着打印一个正方形##!/bin/bashfor i in 1do for k in 1 do echo -e -n "\033[42m " "\033[0m" done echodone#第二：一个棋盘由8个正方形成且颜色错开#行为偶数与列为偶数的颜色相同#!/bin/bash##FileName: game.shfor i in &#123;1..8&#125;do #判断列是否为偶数 a=$(($i%2)) for k in &#123;1..8&#125; do #判断行是否为偶数 b=$(($k%2)) if [ $a -eq $b ] then echo -e -n "\033[42m " "\033[0m" else echo -e -n "\033[46m " "\033[0m" fi done echodone 后续六个字符串：efbaf275cd、4be9c40b8b、44b2395c46、f8c8873ce0、b902c16c8b、ad865d2f63是通过对随机数变量RANDOM随机执行命令： echo $RANDOM|md5sum|cut –c1-10 后的结果，请破解这些字符串对应的RANDOM值 12345678910111213141516171819#思路 先找出随机数的个数 man bash 找到RANDOM 32767 ##!/bin/bash#判断文件是否存在，如果存在则删除[ -e /home/num.file ] &amp;&amp; rm -f /home/num.file#看一下找完需要多少时间echo `date +%T`#key 的值也可以用 key=$(echo $i | md5sum | head -c10)#加大括号是为了并行运行，加快执行结果for i in &#123;1..32767&#125;do &#123; key=$(echo $i | md5sum| cut -c1-10) if [ "$key" == "efbaf275cd" -o "$key" == "4be9c40b8b" -o "$key" == "44b2395c46" -o "$key" == "f8c8873ce0" -o "$key" == "b902c16c8b" -o "$key" == "ad865d2f63" ] then echo $i &gt;&gt; /home/num.file fi &#125; &amp;doneecho `date +%T` 每隔3秒钟到系统上获取已经登录的用户的信息；如果发现用户hacker登录，则将登录时间和主机记录于日志/var/log/login.log中,并退出脚本 1234567891011121314151617#!/bin/bash#FileName: login.shwhile truedo who | grep '^hacker' &amp;&gt;/dev/null if [ $? -eq 0 ] then user=$(who | tr -d "(|)" | awk '/^hacker/&#123;print $3,$4,$5&#125;') echo $user &gt;&gt; /var/log/login.log exit 2 else true fi sleep 3done 随机生成10以内的数字，实现猜字游戏，提示比较大或小，相等则退出 1234567891011121314151617181920212223242526#!/bin/bash##FileName: num.sh#生成10以内的随机数a=$[$RANDOM%10]while truedo read -t 30 -p "Please enter a number less than 10: " num #如果用户输入的为空则提示用户 [ -z $num ]&amp;&amp; echo "You enter a null value" #如果用户输入的不是一个纯数字 或者大于10 则提示用户 [[ ! $num =~ ^[[:digit:]]$ ]] &amp;&amp; echo "You're not entering a pure number or more than 10" if [ $num -gt $a ] &amp;&gt;/dev/null then echo "The value you input is large" elif [ $num -lt $a ] &amp;&gt;/dev/null then echo "The value you input is small" elif [ $num -eq $a ] &amp;&gt;/dev/null then echo -e "The value you input is equal to the value of the system \nThe system num is $a" sleep 2 exit 2 fidone 用文件名做为参数，统计所有参数文件的总行数 123456789101112131415161718192021222324#!/bin/bash##FileName file.sh#如果参数小于1 提示用户if [ $# -lt 1 ]then echo "The value you input is equal to the value of the system" exit 2fisum=0#循环输入的参数for i in $*do#如果不为文件则告知用户 if [ ! -f $i ] then echo "You are not entering $i as a valid file path" continue else line=$(cat $i | wc -l) sum=$(($line+$sum)) fidone echo "The sum of line is $sum" 用二个以上的数字为参数，显示其中的最大值和最小值 123456789101112131415161718192021222324252627282930313233#!/bin/bash#判断参数是否大于2，如果小于2则退出if [ $# -lt 2 ]then echo "You should type in more than two, less than 10" exit 2fifor k in &#123;1..10&#125;do for i in $@ do #判断是否为数字，如果不为纯数字则跳过 if [[ ! $i =~ ^[[:digit:]]+$ ]] then continue #第一次循环最大值等于最小值 elif [ $k -eq 1 ] then max=$i min=$i fi #如果循环中最大值小于新值，则最大值重新赋值 if [ $max -lt $i ] then max=$i elif [ $min -gt $i ] then min=$i fi donedone echo "The max is $max" echo "The min is $min" 扫描/etc/passwd文件每一行，如发现GECOS字段为空，则填充用户名和单位电话为62985600，并提示该用户的GECOS信息修改成功 1234567891011121314151617181920212223242526272829#!/bin/bashcat /etc/passwd | while read ido gencos=$(echo $i | cut -d: -f5) name=$(echo $i | cut -d: -f1) if [ -z $gencos ] &amp;&gt;/dev/null then chfn -f "$name" -p "62985600" $name &amp;&gt;/dev/null echo "The User $name is change" else true fidone###还原#!/bin/bashcat /etc/passwd | while read i do num=$(echo $i | cut -d: -f5 | cut -d, -f3) name=$(echo $i | cut -d: -f1) if [[ $num =~ ^[[:digit:]]+$ ]] then usermod -c "" $name echo "The User $name is back" else true fidone 函数练习 编写函数，实现OS的版本判断 12345678910111213#!/bin/bashios()&#123; os=$(cat /etc/centos-release | sed -r 's#.* ([0-9])\..*#\1#g') os1=$(cat /etc/centos-release | grep -o "[0-9]" | head -1) os2=$(cat /etc/centos-release | tr -dc "[0-9.]" | cut -d. -f1) os3=$(cat /etc/centos-release | awk -F "[ .]+" '&#123;print $4&#125;') echo $os echo $os1 echo $os2 echo $os3&#125;ios 编写函数，实现取出当前系统eth0的IP地址 12345678910111213#!/bin/baship()&#123; eth=$(ifconfig | grep '^eth0' -A1 | grep 'inet' | egrep "[0-9.]+" -o | grep -v "255") eth1=$(ifconfig |sed -n '/^eth0/,/inet/p' | sed -n -r '2s#(.*inet)(.*)( netmask.*)#\2#gp') eth2=$(ifconfig | awk '/^eth0/,/inet/&#123;if(NR==2)print $2&#125;') echo $eth echo $eth1 echo $eth2&#125;ip 编写函数，实现打印绿色OK和红色FAILED 12345678910#!/bin/bashcolor()&#123; ok='[ OK ]' fail='[ FAILED ]' echo -e "------------------------------------------------------------\033[31;40m $ok \033[0m" echo -e "------------------------------------------------------------\033[32;40m $fail \033[0m"&#125;color 编写函数，实现判断是否无位置参数，如无参数，提示错误 1234567891011#!/bin/bashnum()&#123; if [ $# -lt 1 ] then echo "Wrong" else echo "Ok" fi&#125;num $1 编写服务脚本/root/bin/testsrv.sh，完成如下要求 脚本可接受参数：start, stop, restart, status 如果参数非此四者之一，提示使用格式后报错退出 如是start:则创建/var/lock/subsys/SCRIPT_NAME, 并显示“启动成功”&diams; 考虑：如果事先已经启动过一次，该如何处理？ 如是stop:则删除/var/lock/subsys/SCRIPT_NAME, 并显示“停止完成” 如是restart，则先stop, 再start 如是status, 则如果/var/lock/subsys/SCRIPT_NAME文件存在，则显示“SCRIPT_NAME isrunning…” 如果/var/lock/subsys/SCRIPT_NAME文件不存在，则显示“SCRIPT_NAME is stopped…”其中：SCRIPT_NAME为当前脚本名 在所有模式下禁止启动该服务，可用chkconfig 和 service命令管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/bin/bash#chkconfig: - 78 66job()&#123;[ -z $1 ] &amp;&amp; &#123; echo "you should input start|stop|restart|status"; exit 2; &#125;case $1 instart) if [ -e /var/lock/subsys/testsrv.sh ] then echo "httpd is running" return 2 else touch /var/lock/subsys/testsrv.sh echo "httpd start successful " return 1 fi ;;stop) if [ ! -e /var/lock/subsys/testsrv.sh ] then echo "httpd is stopped" return 2 else rm -f /var/lock/subsys/testsrv.sh echo "httpd stopped successfully" return 1 fi ;;restart) if [ -e /var/lock/subsys/testsrv.sh ] then rm -f /var/lock/subsys/testsrv.sh touch /var/lock/subsys/testsrv.sh echo "Restart the success" return 1 else touch /var/lock/subsys/testsrv.sh echo "httpd start is ok" fi ;;status) if [ -e /var/lock/subsys/testsrv.sh ] then echo "httpd is running" else echo "httpd is stopped" fi ;;*) echo "Please input start|stop|restart|status" ;;esac&#125;job $1 编写函数实现两个数字做为参数，返回最大值 123456789101112131415161718192021222324252627282930313233343536373839#!/bin/bashfun()&#123;if [ $# -ne 2 ]then echo "Please enter two Numbers" return 2fifor k in &#123;1..2&#125;do for i in $@ do if [[ ! "$i" =~ ^[[:digit:]]+$ ]] then echo "The $i is not a number" return 2 fi if [ $k -eq 1 ] then max=$i min=$i fi if [ $i -gt $max ] then max=$i elif [ $i -lt $min ] then min=$i fi done done echo "The max is $max"&#125;fun $@ 综合练习100+ 电脑版石头、剪刀、布游戏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/bin/bashvar=(石头 剪刀 布)num=$[$RANDOM%3]roto=$&#123;var[$num]&#125;cat &lt;&lt;EFOnumber 1 :石头number 2 :剪刀number 3 :布EFOread -t 30 -p "please input you choose: " varcase $var in 1) if [ $num -eq 0 ] then echo "平局,电脑出的是石头" elif [ $num -eq 1 ] then echo "你赢了，电脑出的是剪刀" else echo "你输入了，电脑出的是布" fi ;; 2) if [ $num -eq 0 ] then echo "你输了，电脑出的是石头" elif [ $num -eq 1 ] then echo "平局，电脑出的是剪刀" else echo "你赢了，电脑出的是布" fi ;; 3) if [ $num -eq 0 ] then echo "你赢了，电脑出的是石头" elif [ $num -eq 1 ] then echo "你输入了，电脑出的是剪刀" else echo "平局，电脑出的是布" fi ;; *) echo "请输入1,2,3" ;;esac 使用egrep过渡MAC地址 1ifconfig | egrep -o "[0-9a-fA-F]&#123;2&#125;(:[0-9a-fA-F]&#123;2&#125;)&#123;5&#125;" 打印各种时间格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748echo "显示星期简称"（如：Sum）echo +%aecho "显示星期全称"（如：Sunday）date +%Aecho "显示月份简称（如:oct)"date +%becho "显示月份全称（如:October)"date +%B echo "显示数字月份（如：10）"date +%mecho "显示数字日期（如：01号）"date +%d echo "显示数字年全称（如:2018)"date +%Yecho "显示数字年简称（如：18)"date +%yecho "显示年-月-日"date +%Fecho "显示小时（24小时制）"date +%Hecho "显示分钟"date +%Mecho "显示秒"date +%S echo "显示纳秒"date +%N echo "组合"date +"%F %T"echo "7天以前"date -d "-7 day"任意一个时间戳的转换date -d "2008-08-08 20:00:00" +%sdate -d @1218196800 +"%F %T" 根据计算机当前时间，返回问候语 注（00-12点为早晨，12-18点下午，18-24点为晚上） 1234567891011121314151617#!/bin/bashvar=$(date +%H)morn="Good morning $user"after="Good afternoon $user"even="Good evening $user"rand=$[$RANDOM%6+31]if [ $var -le 12 ]then echo -e "\033[5;$rand;40m$morn\033[0m"elif [ $var -lt 18 -a $var -gt 12 ]then echo -e "\033[5;$rand;40m$after\033[0m"else echo -e "\033[5;$rand;40m$even\033[0m"fi 使用shell脚本打印如下图形 123456789101112131415161718192021222324252627282930313233343536373839404142#图形1#!/bin/bashfor i in &#123;1..9&#125;do for k in `seq $i` do echo -n $i done echodone#图形2##!/bin/bashfor i in &#123;1..5&#125;do for k in `seq $i` do echo -n " |" done echo "_"done#图形3#!/bin/bashfor i in &#123;1..5&#125;do for k in `seq $i` do echo -n "*" done echodonei=5while [ $i -ge 1 ]do for j in `seq $i` do echo -n "*" done echo let i--done 显示本机linux系统上所有开放的端口列表 1ss -ntlu | awk '$0 !~ /Port/&#123;print $5&#125;' | awk -F":" '&#123;print $NF&#125;'| sort | uniq 读取用户输入的账户名称，将账户名写入到数组中，并提示用户按quit退出并查看用户信息 123456789101112131415161718192021222324252627282930i=0unset userwhile truedo read -t 30 -p "Please enter a username and quit if you want to quit and view user information: " var if [ -z $var ] then echo "You don't input a username" continue fi if [ $var == "quit" ] then break fi getent passwd $var &amp;&gt;/dev/null if [ $? -ne 0 ] then echo "The user $var is not exits" continue else user[$i]=$var fi let i++done echo "The totle user is $&#123;#user[*]&#125;" echo "The user is $&#123;user[*]&#125;"]]></content>
      <categories>
        <category>linuxshell</category>
      </categories>
      <tags>
        <tag>linuxshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本编程进阶]]></title>
    <url>%2F2018%2F09%2F06%2Fshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[过程式编程语言的执行顺序： 顺序执行 选择执行 循环执行 条件选择if语句 选择执行：if语句可嵌套 单分支 123if 判断条件; 条件为真的分支代码fi 双分支 12345if 判断条件;then 条件为真的分支代码 else 条件为假的分支代码 fi 多分支 123456789if 判断条件1; then 条件1为真的分支代码elif 判断条件2; then 条件2为真的分支代码elif 判断条件3; then 条件3为真的分支代码else 以上条件都为假的分支代码fi 实例：1234567ping -c1 -w1 192.168.11.2 &amp;&gt;/dev/nullif [ $? -eq 0 ]then echo "192.168.11.2 is up"else echo "192.168.11.2 is down"fi 条件判断：case语句 示例123456789101112case 变量引用 inPAT1) 分支1 ;;PAT2) 分支2 ;;*) 默认分支;;esac 循环 循环执行 将某代码段重复运行多次 重复运行多少次 循环次数事先已知 循环次数事先未知 有进入条件和退出条件 for, while, until for循环 示例 1234for 变量名 in 列表do 循环体 done 执行机制： 依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直 到列表中的元素耗尽，循环结束 列表生成方式：123456直接给出列表:整数列表： a:&#123;start..end&#125; b:$(seq [start [step]] end) 返回列表的命令: $(COMMAND)使用glob，如： *.sh变量引用: $@, $* while循环 示例 123while CONDITION;do 循环done CONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为“false”终止循环 因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地被修正 进入条件：CONDITION为true 退出条件：CONDITION为false until循环 示例 1234until CONDITION do 循环体done 进入条件： CONDITION 为false 退出条件： CONDITION 为true 循环控制语句continue 示例 1 123456789while CONDTIITON1do CMD1if CONDITION2 then continuefi CMDn done 示例 2 123456789101112131415#!/bin/bash##FileName: continue.shfor i in &#123;1..10&#125;do # 如果能被2整除则打印否则结束本轮循环，直接一下轮 # 打印的结果为1--10的全部偶数 2，4，6，8，10 if [ $(($i%2)) -eq 0 ] then echo $i else continue fidone 循环控制语句break 用于循环体中 break：提前结束第N层循环，最内层为第1层 示例1 123456789while CONDTIITON1 do CMD1if CONDITION2 then breakfi CMDn done 示例2 1234567891011121314151617```bash#!/bin/bash##FileName: continue.shfor i in &#123;1..10&#125;do if [ $i -lt 8 ] then echo $i else #如果$i 小于8则打印，否则循环结束 #输入结果为1--8的值 break fidone 循环控制shift命令 用于将参量列表 list 左移指定次数，缺省为左移一次。 参量列表 list 一旦被移动，最左端的那个参数就从列表中删除。while 循环遍历位置参量列表时，常用到 shift 示例题12345while [ $# -gt 0 ]do echo $* shiftdone 创建无限循环 示例12345678while true do 循环体doneuntil false do 循环体done 特殊用法 while循环的特殊用法（遍历文件的每一行）： 1234while read linedo 循环体Done &lt; /PATH/FROM/SOMEFILE 依次读取/PATH/FROM/SOMEFILE文件中的每一行，且将行赋值给变量line 双小括号方法，即((…))格式，也可以用于算术运算 双小括号方法也可以使bash Shell实现C语言风格的变量操作 for循环的特殊格式： 1234for ((控制变量初始化;条件判断表达式;控制变量的修正表达式)) do 循环体 done 控制变量初始化：仅在运行到循环代码段时执行一次 控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做条件判断 select循环与菜单 示例 1234select variable in list do 循环体命令 done select 循环主要用于创建菜单，按数字顺序排列的菜单项将显示在标准错误上，并显示 PS3 提示符，等待用户输入 用户输入菜单列表中的某个数字，执行相应的命令 用户输入被保存在内置变量 REPLY 中 select与case select 是个无限循环，因此要记住用 break 命令退出循环，或用 exit 命令终止脚本。也可以按 ctrl+c 退出循环 select 经常和 case 联合使用 与 for 循环类似，可以省略 in list，此时使用位置参量 函数介绍 函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程 它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运行，而是shell程序的一部分 函数和shell程序比较相似，区别在于： Shell程序在子Shell中运行 而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变量进行修改 定义函数 函数由两部分组成：函数名和函数体 示例123456789101112语法一:name()&#123; 函数体&#125;语法二：function name()&#123; 函数体&#125;语法三：function name&#123; 函数体&#125; 函数使用 函数的定义和使用： 可在交互式环境下定义函数 可将函数放在脚本文件中作为它的一部分 可放在只包含函数的单独文件中 调用：函数只有被调用才会执行 调用：给定函数名 函数名出现的地方，会被自动替换为函数代码 函数的生命周期：被调用时创建，返回时终止 函数返回值 函数有两种返回值： 函数的执行结果返回值： 函数体中调用命令的输出结果 函数的退出状态码 默认取决于函数中执行的最后一条命令的退出状态码 自定义退出状态码，其格式为： return 从函数中返回，用最后状态命令决定返回值 return 0 无错误返回。 return 1-255 有错误返回 交互式环境下定义和使用函数 示例： 1234dir()&#123; ls -l&#125;若要使用该函数直接 dir 调用及可 定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同dir 该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令unset dir 在脚本中定义及使用函数 函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它后才能使用 调用函数仅使用其函数名即可 示例12345678910#!/bin/bash##FileName: func1.shhello()&#123; echo "Today is $(date +%A)"&#125; echo "Today is What day is it today" hello echo "OK 3Q" 使用函数文件 可以将经常使用的函数存入函数文件，然后将函数文件载入shell 文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main 一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数 若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新载入此文件 创建函数文件 函数文件示例：12345678910#!/bin/bash#functions.mainfindit()&#123; if [ $# -lt 1 ] ; then echo "Usage:findit file" return 1 fi find / -name $1 –print&#125; 载入函数 函数文件已创建好后，要将它载入shell 定位函数文件并载入shell的格式 . filename 或者 source filename 注意：此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt; 这里的文件名要带正确路径 上例中的函数，可使用如下命令： . functions.main 检查载入函数 使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数 执行shell函数 要执行函数，简单地键入函数名即可 删除shell函数 现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命令完成删除函数 命令格式为： unset function_name 环境函数 使子进程也可使用 声明：export -f function_name 查看：export -f 或 declare -xf 函数参数 函数可以接受参数： 传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；例如“testfunc arg1 arg2 …” 在函数体中当中，可使用$1, $2, …调用这些参数；还可以使用$@, $*, $#等特殊变量 函数变量 变量作用域： 环境变量：当前shell和子shell有效 本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程； 局部变量：函数的生命周期；函数结束时变量被自动销毁 注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量 在函数中定义局部变量的方法 local name=value fork炸弹1bomb() &#123; bomb | bomb &amp; &#125;; bomb 信号捕捉trap trap ‘触发指令’ 信号 自定义进程收到系统发出的指定信号后，将执行触发指令，而不会执行原操作 trap ‘’ 信号 忽略信号的操作 trap ‘-‘ 信号 恢复原信号的操作 trap -p 列出自定义信号操作 示例12345678910111213141516171819202122#!/bin/bashtrap 'echo “signal:SIGINT"' inttrap -pfor((i=0;i&lt;=10;i++))dosleep 1echo $idonetrap '' inttrap -pfor((i=11;i&lt;=20;i++))dosleep 1echo $idonetrap '-' inttrap -pfor((i=21;i&lt;=30;i++))dosleep 1echo $idone 数组 变量：存储单个元素的内存空间 数组：存储多个元素的连续的内存空间，相当于多个变量的集合 数组名和索引 索引：编号从0开始，属于数值索引 注意：索引可支持使用自定义的格式，而不仅是数值格式，即为关联索引 bash的数组支持稀疏格式（索引不连续） 声明数组： declare -a ARRAY_NAME declare -A ARRAY_NAME: 关联数组 注意：两者不可相互转换 数组赋值 数组元素的赋值 一次只赋值一个元素 ARRAY_NAME[INDEX]=VALUE weekdays[0]=”Sunday” weekdays[4]=”Thursday” 一次赋值全部元素 ARRAY_NAME=(“VAL1” “VAL2” “VAL3” …) 只赋值特定元素 ARRAY_NAME=([0]=”VAL1” [3]=”VAL2” …) 交互式数组值对赋值 read -a ARRAY 显示所有数组：declare -a 引用数组 示例123456789101112引用数组元素：$&#123;ARRAY_NAME[INDEX]&#125;注意：省略[INDEX]表示引用下标为0的元素引用数组所有元素：$&#123;ARRAY_NAME[*]&#125;$&#123;ARRAY_NAME[@]&#125;数组的长度(数组中元素的个数)：$&#123;#ARRAY_NAME[*]&#125;$&#123;#ARRAY_NAME[@]&#125;删除数组中的某元素：导致稀疏格式删除整个数组：unset ARRAY 数组数据处理 示例123456789101112引用数组中的元素：数组切片：$&#123;ARRAY[@]:offset:number&#125;offset: 要跳过的元素个数number: 要取出的元素个数取偏移量之后的所有元素$&#123;ARRAY[@]:offset&#125;向数组中追加元素：ARRAY[$&#123;#ARRAY[*]&#125;]=value关联数组：declare -A ARRAY_NAMEARRAY_NAME=([idx_name1]='val1' [idx_name2]='val2‘...)注意：关联数组必须先声明再调用]]></content>
      <categories>
        <category>linuxshell</category>
      </categories>
      <tags>
        <tag>linuxshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和计划任务]]></title>
    <url>%2F2018%2F09%2F06%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[进程和计划任务linux进程概念&hearts; 进程概念 Process: 运行中的程序的一个副本，是被载入内存的一个指令集合&diams; 进程ID（Process ID，PID）号码被用来标记各个进程&diams; UID、GID、和SELinux语境决定对文件系统的存取和访问权限&diams; 通常从执行进程的用户来继承&diams; 存在生命周期 task struct：Linux内核存储进程信息的数据结构格式 task list：多个任务的的task struct组成的链表 进程创建：&diams; init：第一个进程&diams; 进程：都由其父进程创建，父子关系，CoW fork(), clone() 进程的基本状态和转换&hearts; 进程的基本状态 创建状态：进程在创建时需要申请一个空白PCB(process control block进程控制块)，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态 就绪状态：进程已准备好，已分配到所需资源，只要分配到CPU就能够立即运行 执行状态：进程处于就绪状态被调度后，进程进入执行状态 阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用 终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行 状态之间转换六种情况&hearts; 进程之间的状态转换 运行——&gt;就绪：1，主要是进程占用CPU的时间过长，而系统分配给该进程占用CPU的时间是有限的；2，在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行时，该进程就被迫让出CPU，该进程便由执行状态转变为就绪状态 就绪——&gt;运行：运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配CPU 运行——&gt;阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如发生了I/O请求 阻塞——&gt;就绪:进程所等待的事件已经发生，就进入就绪队列 以下两种状态是不可能发生的： 阻塞——&gt;运行：即使给阻塞进程分配CPU，也无法执行，操作系统在进行调度时不会从阻塞队列进行挑选，而是从就绪队列中选取 就绪——&gt;阻塞：就绪态根本就没有执行，谈不上进入阻塞态 进程类型及分类&hearts; 进程类型： 守护进程: daemon,在系统引导过程中启动的进程，和终端无关进程 前台进程：跟终端相关，通过终端启动的进程 注意：两者可相互转化 &hearts; 进程状态： 运行态：running 就绪态：ready 睡眠态：&diams; 可中断：interruptable&diams; 不可中断：uninterruptable 停止态：stopped,暂停于内存，但不会被调度，除非手动启动 僵死态：zombie，结束进程，父进程结束前，子进程不关闭 &hearts; 进程的分类： CPU-Bound：CPU密集型，非交互 IO-Bound：IO密集型，交互 进程间通信及优先级&hearts; 进程间通信方式 同一主机： &diams; signal:信号&diams; shm: shared memory 共享内存&diams; semaphore:信号量，一种计数器 不同主机：&diams; socket: IP和端口号&diams; RPC: remote procedure call&diams; MQ：消息队列，Kafka，ActiveMQ &hearts; 进程优先级 系统优先级：数字越小，优先级越高&diams; 0-139（CentOS4,5）&diams; 0-98，99（CentOS6） 实时优先级: 99-0 值最大优先级最高 nice值：-20到19，对应系统优先级100-139或99 (nice值越小，优先集越高) 示图 &hearts; 进程优先级查看及调整 进程优先级调整：&diams; 静态优先级：100-139&diams; 进程默认启动时的nice值为0，优先级为120&diams; 只有根用户才能降低nice值（提高优先性） nice命令：&diams; nice [OPTION] [COMMAND [ARG]…]&diams; nice -n -10 /etc/init.d/httpd start renice命令： &diams; renice [-n] priority pid… &diams; renice -n -10 -p 110 查看：&diams; ps axo pid,comm,ni&diams; Linux系统各进程的相关信息均保存在/proc/PID目录下的各文件中 进程管理常用工具系统状态查看命令pstree&hearts; 树状进程显示 pstree - display a tree of processes&diams; -p 详细信息&diams; {} 里为线程，（）为进程 ps&hearts; ps [OPTION]… 支持三种选项：&diams; UNIX选项 如-A -e&diams; BSD选项 如a&diams; GNU选项 如–help 选项：默认显示当前终端中的进程&diams; a 选项包括所有终端中的进程&diams; x 选项包括不链接终端的进程&diams; u 选项显示进程所有者的信息&diams; f 选项显示进程树,相当于 –forest&diams; k|–sort 属性 对属性排序,属性前加- 表示倒序&diams; o 属性… 选项显示定制的信息 pid、cmd、%cpu、%mem&diams; L 显示支持的属性列表&diams; –context 显示安全信息 CPU 高消耗&diams; ping -f 127.0.0.1&diams; dd if=/dev/zero of=/dev/null&diams; 示图12345678910111213141516171819202122#命令生效用户 USER#当前进程的ID PID #进程CPU使用率 %CPU#进程内存使用率 %MEM #虚拟内存集 VSZ #常驻内存集 RSS #终端 TTY #进程状态 STAT #几点几分开启 START #执行了多久 TIME #命令COMMAND top&hearts; top 有许多内置命令 排序：&diams; P：以占据的CPU百分比,%CPU&diams; M：占据内存百分比,%MEM&diams; T：累积占据CPU时长,TIME+&diams; -d # 指定刷新时间间隔，默认为3秒&diams; -b 全部显示所有进程&diams; -n # 刷新多少次后退出&diams; -H 线程模式，示例：top -H -p pidof mysqld 首部信息显示&diams; uptime信息：l命令&diams; tasks及cpu信息：t命令&diams; cpu分别显示：1 (数字)&diams; memory信息：m命令&diams; 退出命令：q&diams; 修改刷新时间间隔：s&diams; 终止指定进程：k&diams; 保存文件：W 栏位信息简介&diams; us：用户空间&diams; sy：内核空间&diams; ni：调整nice时间&diams; id：空闲&diams; wa：等待IO时间&diams; hi：硬中断&diams; si：软中断（模式切换）&diams; st：虚拟机偷走的时间(虚拟机) 故障定位&hearts; 查找占用最多内存和CPU的进程： ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%mem | head ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%cpu | head 通过进程ID来显示所属的进程：&diams; ps -fp pid 以父进程ID来显示其下所有的进程，如显示父进程为1154的所有进程：&diams; ps -f –ppid 1154 使用watch实用程序执行重复的输出以实现对就程进行实时的监视，如下面的命令显示每秒钟的监视：&diams; watch -n 1 ‘ps axo ppid,pid,%mem,%cpu –sort=-%cpu | head’ 检查一个进程的执行时间&diams; ps axo comm,etime,user | grep httpd pgrep&hearts; 搜索进程 按预定义的模式：pgrep pgrep [options] pattern&diams; -u uid: effective user，生效者&diams; -U uid: real user，真正发起运行命令者&diams; -t terminal: 与指定终端相关的进程&diams; -l: 显示进程名&diams; -a: 显示完整格式的进程名&diams; -P pid: 显示指定进程的子进程&diams; -o 显示最小的进程id&diams; -n 显示最大的进程id 12345#搜索以sh、php结尾的进程，并杀掉对应的进程pgrep -l sh$ kill pid pgrep -l php$ kill pid 按确切的程序名称：/sbin/pidof&diams; pidof bash uptime&hearts; 查看负载 uptime&diams; 显示当前时间，系统已启动的时间、当前上线人数，系统平均负载（1、5、10分钟的平均负载，一般不会超过1）&diams; 系统平均负载:&raquo; 指在特定时间间隔内运行队列中的平均进程数&diams; 通常每个CPU内核的当前活动进程数不大于3，那么系统的性能良好。如果每个CPU内核的任务数大于5，那么此主机的性能有严重问题&diams; 如果linux主机是1个双核CPU，当Load Average 为6的时候说明机器已经被充分使用&diams; 示图12#当前系统时间 运行了多少时间 当前有多少个登陆用户 系统1，5，15钟的平均负载05:18:19 up 13:28, 4 users, load average: 0.00, 0.00, 0.00 free&hearts; 内存空间内存查看 free [OPTION]&diams; -b 以字节为单位&diams; -m 以MB为单位&diams; -g 以GB为单位&diams; -h 易读格式&diams; -o 不显示-/+buffers/cache行&diams; -t 显示RAM + swap的总和&diams; -s n 刷新间隔为n秒&diams; -c n 刷新n次后即退出&diams; 示图 buffers 与cached&diams; buffers：是系统两端处理速度平衡时使用的。它的引入是为了减小短期内突发I/O的影响，起到流量整形的作用。&diams; cached： 是为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到加快访问速度的作用。 vmstat&hearts; vmstat命令：虚拟内存信息 vmstat [options] [delay [count]] vmstat 2 5 procs:&diams; r：可运行（正运行或等待运行）进程的个数，和核心数有关&diams; b：处于不可中断睡眠态的进程个数(被阻塞的队列的长度) 选项&diams; -s: 显示内存的统计数据 memory&diams; swpd: 交换内存的使用总量&diams; free：空闲物理内存总量&diams; buffer：用于buffer的内存总量&diams; cache：用于cache的内存总量 swap&diams; si：从磁盘交换进内存的数据速率(kb/s)&diams; so：从内存交换至磁盘的数据速率(kb/s)&diams; 模似：dd if=/dev/zero of=/dev/null bs=3G count=100 io&diams; bi：从块设备读入数据到系统的速率(kb/s)&diams; 模似：dd if=/dev/sda of=/dev/null&diams; bo: 保存数据至块设备的速率&diams; 模似：dd if=/dev/zero of=/fi system&diams; in: interrupts 中断速率，包括时钟&diams; cs: context switch 进程切换速率 cpu&diams; us:Time spent running non-kernel code&diams; sy: Time spent running kernel code&diams; id: Time spent idle. Linux 2.5.41前,包括IO-wait time&diams; wa: Time spent waiting for IO. 2.5.41前，包括in idle.&diams; st: Time stolen from a virtual machine. 2.6.11前, unknown. pmap&hearts; pmap命令：进程对应的内存映射 pmap [options] pid […]&diams; -x: 显示详细格式的信息&diams; 示例：pmap 1 另外一种实现：&diams; cat /proc/PID/maps iotop&hearts; iotop 作用： iotop命令是一个用来监视磁盘I/O使用状况的top类工具iotop具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息，可查看每个进程是如何使用IO lsof&hearts; lsof Lsof：list open files查看当前系统文件的工具。在linux环境下，一切皆文件，用户通过文件不仅可以访问常规数据，还可以访问网络连接和硬件如传输控制协议 (TCP) 和用户数据报协议 (UDP)套接字等，系统在后台都为该应用程序分配了一个文件描述符 命令参数&diams; -a：列出打开文件存在的进程&diams; -c&lt;进程名&gt;：列出指定进程所打开的文件&diams; -g：列出GID号进程详情&diams; -d&lt;文件号&gt;：列出占用该文件号的进程&diams; +d&lt;目录&gt;：列出目录下被打开的文件&diams; +D&lt;目录&gt;：递归列出目录下被打开的文件&diams; -n&lt;目录&gt;：列出使用NFS的文件&diams; -i&lt;条件&gt;：列出符合条件的进程(4、6、协议、:端口、 @ip )&diams; -p&lt;进程号&gt;：列出指定进程号所打开的文件&diams; -u：列出UID号进程详情&diams; -v：显示版本信息。&diams; -h：显示帮助信息&diams; -n: 不反向解析网络名字 常用选项&diams; 查看由登陆用户启动而非系统启动的进程&raquo; lsof /dev/pts1 &diams; 指定进程号，可以查看该进程打开的文件&raquo; lsof -p 9527 &diams; 查看指定程序打开的文件&raquo; lsof -c httpd &diams; 查看指定用户打开的文件&raquo; lsof -u root | more &diams; 查看指定目录下被打开的文件&raquo; lsof +D /var/log/&raquo; lsof +d /var/log/&raquo; 参数+D为递归列出目录下被打开的文件，参数+d为列出目录下被打开的文件 &diams; 查看所有网络连接&raquo; lsof -i –n lsof -i@127.0.0.1&raquo; 通过参数-i查看网络连接的情况，包括连接的ip、端口等以及一些服务的连接情况，例如：sshd等。也可以通过指定ip查看该ip的网络连接情况 &diams; 查看端口连接情况&raquo; lsof -i :80 -n&raquo; 通过参数-i:端口可以查看端口的占用情况，-i参数还有查看协议，ip的连接情况等 &diams; 查看指定进程打开的网络连接&raquo; lsof -i –n -a -p 9527&raquo; 参数-i、-a、-p等，-i查看网络连接情况，-a查看存在的进程，-p指定进程 &diams; 查看指定状态的网络连接&raquo; lsof -n -P -i TCP -s TCP:ESTABLISHED&raquo; -n:no host names, -P:no port names,-i TCP指定协议，-s指定协议状态通过多个参数可以清晰的查看网络连接情况、协议连接情况等 lsof 恢复删除文件&diams; 示例 12345lsof |grep /var/log/messages rm -f /var/log/messages lsof |grep /var/log/messages cat /proc/653/fd/6 cat /proc/653/fd/6 &gt; /var/log/messages taskset&hearts; 查看进程与CPU的关系 示例&diams; pgrep -f httpd&diams; taskset -p PID 查看进程工作在哪一颗CPU上&diams; taskset -cp n pid 绑定对应的进程到对应的CPU上 kill&hearts; kill命令： 向进程发送控制信号，以实现对进程管理,每个信号对应一个数字，信号名称以SIG开头（可省略），不区分大小写 显示当前系统可用信号： kill –l,trap -l 常用信号：man 7 signal&diams; 1) SIGHUP: 无须关闭进程而让其重读配置文件&diams; 2) SIGINT: 中止正在运行的进程；相当于Ctrl+c&diams; 3) SIGQUIT:相当于ctrl+\&diams; 9) SIGKILL: 强制杀死正在运行的进程&diams; 15) SIGTERM：终止正在运行的进程&diams; 18) SIGCONT：继续运行&diams; 19) SIGSTOP：后台休眠 指定信号的方法：&diams; 信号的数字标识：1, 2, 9&diams; 信号完整名称：SIGHU&diams; 信号的简写名称：HUP&diams; kill –n SIGNAL pid;kill –s SIGNAL pid &hearts; 相关命令 killall 按名称&diams; killall -9 httpd pkill 按模式&diams; -SIGNAL&diams; -u uid: effective user，生效者&diams; -U uid: real user，真正发起运行命令者&diams; -t terminal: 与指定终端相关的进程&diams; -l: 显示进程名（pgrep可用）&diams; -a: 显示完整格式的进程名（pgrep可用）&diams; -P pid: 显示指定进程的子进程 作业管理&hearts; 作业管理 Linux的作业控制&diams; 前台作业：通过终端启动，且启动后一直占据终端&diams; 后台作业：可通过终端启动，但启动后即转入后台运行（释放终端） 让作业运行于后&diams; 运行中的作业： Ctrl+z&diams; 尚未启动的作业： COMMAND &amp;&diams; 后台作业虽然被送往后台运行，但其依然与终端相关；退出终端，将关闭后台作业。如果希望送往后台后，剥离与终端的关系&raquo; nohup COMMAND &amp;&gt;/dev/null &amp;&raquo; screen;COMMAND 查看当前终端所有作业：jobs 作业控制：&diams; fg [[%]JOB_NUM]：把指定的后台作业调回前台&diams; bg [[%]JOB_NUM]：让送往后台的作业在后台继续运行&diams; kill [%JOB_NUM]： 终止指定的作业 &hearts; 并行运行方法 同时运行多个进程，提高效率 方法1&diams; vi all.sh&diams; f1.sh&amp;&diams; f2.sh&amp;&diams; f3.sh&amp; 方法2&diams; (f1.sh&amp;);(f2.sh&amp;);(f3.sh&amp;) 方法3&diams; { f1.sh&amp; f2.sh&amp; f3.sh&amp; } 任务计划任务计划概念&hearts; Linux任务计划、周期性任务执行 未来的某时间点执行一次任务&diams; at&diams; batch：系统自行选择空闲时间去执行此处指定的任务 周期性运行某任务&diams; cron 任务计划实现at&hearts; 软件包: at&hearts; at命令：at [option] TIME 作用：未来的某时间点执行一次任务 常用选项：&diams; -V 显示版本信息:&diams; -l 列出指定队列中等待运行的作业；相当于atq&diams; -d 删除指定的作业；相当于atrm&diams; -c 查看具体作业任务&diams; -f /path/file 指定的文件中读取任务&diams; -m 当任务被完成之后，将给用户发送邮件，即使没有标准输出 注意：作业执行命令的结果中的标准输出和错误以邮件通知给相关用户 TIME:定义出什么时候进行 at 这项任务的时间&diams; HH:MM [YYYY-mm-dd]&diams; noon, midnight, teatime（4pm）&diams; tomorrow&diams; now+#{minutes,hours,days, OR weeks} at时间格式&diams; HH:MM 02:00&raquo; 在今日的 HH:MM 进行，若该时刻已过，则明天此时执行任务&diams; HH:MM YYYY-MM-DD 02:00 2016-09-20&raquo; 规定在某年某月的某一天的特殊时刻进行该项任务&diams; HH:MM[am|pm] [Month] [Date]&raquo; 04pm March 17&raquo; 17:20 tomorrow&diams; HH:MM[am|pm] + number [minutes|hours|days|weeks]在某个时间点再加几个时间后才进行该项任务&raquo; now + 5 min&raquo; 02pm + 3 days 执行方式：&diams; 交互式&diams; 输入重定向&diams; at –f 文件 &hearts; 配置文件 依赖与atd服务,需要启动才能实现at任务 at队列存放在/var/spool/at目录中 /etc/at.{allow,deny}控制用户是否能执行at任务&diams; 白名单：/etc/at.allow 默认不存在，只有该文件中的用户才能执行at命令&diams; 黑名单：/etc/at.deny 默认存在，拒绝该文件中用户执行at命令，而没有在&diams; at.deny 文件中的使用者则可执行&diams; 如果两个文件都不存在，只有 root 可以执行 at 命令 cron程序包&hearts; 相关的程序包： cronie: 主程序包，提供crond守护进程及相关辅助工具 cronie-anacron：cronie的补充程序，用于监控cronie任务执行状况，如cronie中的任务在过去该运行的时间点未能正常运行，则anacron会随后启动一次此任务 crontabs：包含CentOS提供系统维护任务 日志：/var/log/cron 作用&hearts; crond作用 计划周期性执行的任务提交给crond，到指定时间会自动运行&diams; 系统cron任务：系统维护作业&raquo; /etc/crontab&diams; 用户cron任务：&raquo; crontab命令 配置文件&hearts; 相关配置文件 系统的计划任务:&diams; /etc/crontab 配置文件&diams; /etc/cron.d/ 配置文件&diams; /etc/cron.hourly/ 脚本&diams; /etc/cron.daily/ 脚本&diams; /etc/cron.weekly/ 脚本&diams; /etc/cron.monthly/ 脚本 运行状态&hearts; 确保crond守护处于运行状态： CentOS 7:&diams; systemctl status crond CentOS 6:&diams; service crond status 定时任务实现&hearts; cron实现定时任务 系统cron任务:/etc/crontab 注释行以 # 开头&diams; 示图 12345678# Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed &diams; 示例 12#例如：晚上9点10分运行echo命令10 21 * * * fang /bin/echo "hello world!" 时间表示方式 时间表示法：&diams; 特定值&raquo; 给定时间点有效取值范围内的值 &diams; *&raquo; 给定时间点上有效取值范围内的所有值 表示“每…” &diams; 离散取值&raquo; #,#,# &diams; 连续取值&raquo; #-# &diams; 在指定时间范围上，定义步长&raquo; /#: #即为步长&diams; 示例 12#每3小时执行echo和wall命令 0 */3 * * * centos /bin/echo “hello wolrd”;/usr/bin/wall “hello world!” 用户定义计划任务 &hearts; 用户计划任务 crontab命令定义&diams; 每个用户都有专用的cron任务文件：&raquo; /var/spool/cron/USERNAME crontab命令：&diams; -l: 列出所有任务&diams; -e: 编辑任务&diams; -r: 移除所有任务&diams; -i：同-r一同使用，以交互式模式移除指定任务&diams; -u user: 仅root可运行，指定用户管理cron任务&diams; 小技巧 crontab -e 带颜色12#如想永久生效写配置文件export EDITOR=vim at和crontab 对比&hearts; 总结 一次性作业使用 at 重复性作业使用crontab 12345Create at time crontab -e List at -l crontab -l Details at -c jobnum N/A Remove at -d jobnum crontab -r Edit N/A crontab -e 没有被重定向的输出会被邮寄给用户 root能够修改其它用户的作业 注意&diams; 运行结果的标准输出和错误以邮件通知给相关用户&raquo; COMMAND &gt; /dev/null&raquo; COMMAND &amp;&gt; /dev/null &diams; 对于cron任务来讲，%有特殊用途；如果在命令中要使用%，则需要转义，将%放置于单引号中，则可不用转义 sleep&hearts; sleep命令： sleep NUMBER[SUFFIX]…&diams; s: 秒, 默认&diams; m: 分&diams; h: 小时&diams; d: 天]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容器技术]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习]]></title>
    <url>%2F2018%2F09%2F06%2Fpython%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存技术]]></title>
    <url>%2F2018%2F09%2F06%2F%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"></content>
      <categories>
        <category>cache</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负载匀衡]]></title>
    <url>%2F2018%2F09%2F06%2F%E8%B4%9F%E8%BD%BD%E5%8C%80%E8%A1%A1%2F</url>
    <content type="text"></content>
      <categories>
        <category>haproxy</category>
      </categories>
      <tags>
        <tag>haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web服务篇2]]></title>
    <url>%2F2018%2F09%2F06%2Fweb%E6%9C%8D%E5%8A%A1%E7%AF%872%2F</url>
    <content type="text"></content>
      <categories>
        <category>linuxweb</category>
      </categories>
      <tags>
        <tag>linuxweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘存储和文件系统]]></title>
    <url>%2F2018%2F08%2F11%2F%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[磁盘存储和文件系统硬盘两种分区方式MBR分区&hearts; MBR介绍 MBR: Master Boot Record，1982年，使用32位表示扇区数，分区不超过2T 按柱面分区 0磁道0扇区：512bytes&diams; 446bytes: boot loader&diams; 64bytes：分区表，其中每16bytes标识一个分区&diams; 2bytes: 55AA 4个主分区；3主分区+1扩展(N个逻辑分区) &hearts; MBR分区结构图 MBR硬盘分区结构图&diams; 示图 硬盘主引导记录MBR由4个部分组成 主引导程序（偏移地址0000H–0088H），它负责从活动分区中装载，并运行系统引导程序 出错信息数据区，偏移地址0089H–00E1H为出错信息，00E2H–01BDH全为0字节 分区表（DPT,Disk Partition Table）含4个分区项，偏移地址01BEH–01FDH,每个分区表项长16个字节，共64字节为分区项1、分区项2、分区项3、分区项4 结束标志字，偏移地址01FE–01FF的2个字节值为结束标志55AA&diams; 示图 GPT分区&hearts; GTP分区介绍 GPT分区结构&diams; 示图 GPT:GUID（Globals Unique Identifiers） partition table 支持128个分区，使用64位，支持8Z（ 512Byte/block ）64Z （ 4096Byte/block） 使用128位UUID(Universally Unique Identifier) 表示磁盘和分区 GPT分区表自动备份在头和尾两份，并有CRC校验位 UEFI (统一扩展固件接口)硬件支持GPT，使操作系统启动 两种分区系统引导方式&hearts; BIOS+MBR与UEFI+GPT BIOS+MBR&diams; 示图 UEFI+GPT&diams; 示图 管理分区lsblk&hearts; lsblk 列出块设备&diams; lsblk&diams; lsblk -f 查看块设备的文件系统 fdisk&hearts; fdisk命令 fdisk -l [-u] [device…] 查看分区 fdisk /dev/sdb 管理分区 相关子命令如下&diams; p 分区列表&diams; t 更改分区类型&diams; n 创建新分区&diams; d 删除分区&diams; v 校验分区&diams; u 转换单位&diams; w 保存并退出&diams; q 不保存并退出 注意分区时的柱面位置 相关命令&hearts; 相关命令介绍 gdisk&diams; 创建GPT分区 parted&diams; 高级分区操作&diams; 用法：parted [选项]… [设备 [命令 [参数]…]…]&raquo; parted /dev/sdb mklabel gpt|msdos&raquo; parted /dev/sdb print&raquo; parted /dev/sdb mkpart primary 1 200 （默认M）&raquo; parted /dev/sdb rm 1&raquo; parted –l 列出分区信息&diams; 注意：parted的操作都是实时生效的，小心使用 同步分区表&hearts; centos6同步方式 新增分区用&diams; partx -a /dev/DEVICE&diams; kpartx -a /dev/DEVICE -f: force 删除分区用&diams; partx -d –nr M-N /dev/DEVICE 清空全部分区&diams; dd if=/dev/zer0 of=/dev/sdc bs=1 count=512 查看磁盘分区&diams; fdisk -l /dev/sdb 查看的是硬盘上的分区 查看内存加载的分区&diams; cat /proc/partitions&diams; ls /dev/sdb*&diams; lsblk &hearts; CentOS 5、7同步方式 partprobe [/dev/DEVICE] 自动化分区&hearts; 自动化分区实现 echo -e ‘n\np\n\n\n+1G\nw\n’ | fdisk /dev/sdc12345678fdisk /dev/sdc &lt;&lt; EFOnp+4GwEFO 文件系统文件系统介绍&hearts; 文件系统介绍及相关概念 文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件结构称为文件管理系统，简称文件系统 从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，安全控制，日志，压缩，加密等 支持的文件系统：/lib/modules/uname –r/kernel/fs 各种文件系统：&diams; https://en.wikipedia.org/wiki/Comparison_of_file_systems&diams; lsmod 查看已加载到内存的模块&diams; 查看硬盘详细分区信息&diams; hexdump -C -n 1024 /dev/sdb1 -v 文件系统分类&hearts; 相关文件系统类型 Linux文件系统类型&diams; ext2(Extended file system) :适用于那些分区容量不是太大，更新也不频繁的情况，例如 /boot 分区&diams; ext3:是 ext2 的改进版本，其支持日志功能，能够帮助系统从非正常关机导致的异常中恢复。它通常被用作通用的文件系统&diams; ext4:是 ext 文件系统的最新版。提供了很多新的特性，包括纳秒级时间戳、创建和使用巨型文件(16TB)、最大1EB的文件系统，以及速度的提升&diams; xfs：SGI，支持最大8EB的文件系统&diams; btrfs（Oracle）, reiserfs, jfs（AIX）, swap 光盘：iso9660 Windows：FAT32, exFAT,NTFS Unix: FFS（fast）, UFS（unix）, JFS2 网络文件系统：NFS, CIFS 集群文件系统：GFS2, OCFS2（oracle） 分布式文件系统： fastdfs,ceph, moosefs, mogilefs, glusterfs, Lustre RAW：未经处理或者未经格式化产生的文件系统 &hearts; 文件系统分类 根据其是否支持”journal”功能：&diams; 日志型文件系统: ext3, ext4, xfs, …&diams; 非日志型文件系统: ext2, vfat 查前支持的文件系统：cat /proc/filesystems Linux的虚拟文件系统：VFS&diams; 示图 &hearts; 文件系统的组成部分 内核中的模块：ext4, xfs, vfat 用户空间的管理工具：mkfs.ext4, mkfs.xfs,mkfs.vfat &hearts; 文件系统参数 文件系统选择&diams; 示图 文件系统创建及相关内容文件系统相关命令mkfs&hearts; 命令：mkfs mkfs.FS_TYPE /dev/DEVICE&diams; ext4&diams; xfs&diams; btrfs&diams; vfat mkfs -t FS_TYPE /dev/DEVICE&diams; -L ‘LABEL’ 设定卷标&diams; 建议：卷标的名称和挂载点名称一致 &diams; -f 强制分区 &diams; blkid &diams; 查看所有被创建好文件系统的分区 mke2fs&hearts; 命令：mke2fs ext系列文件系统专用管理工具&diams; -t {ext2|ext3|ext4} 指定文件系统类型&diams; -b {1024|2048|4096} 指定块大小 (分件分配的最小单位)&diams; -L ‘LABEL’ 设置卷标&diams; -j 相当于 -t ext3&diams; -i 为数据空间中每多少个字节创建一个inode；不应该小于block大小&diams; -N 指定分区中创建多少个inode&diams; -I 一个inode记录占用的磁盘空间大小，128—4096&diams; -m # 默认5%,为管理人员预留空间占总空间的百分比&diams; -O FEATURE[,…] 启用指定特性&diams; -O ^FEATURE 关闭指定特性 tune2fs&hearts; 命令：tune2fs 查看文件系统的元数据 重新设定ext系列文件系统可调整参数的值&diams; -l 查看指定文件系统超级块信息；super block&diams; -L ‘LABEL‘ 修改卷标&diams; -m # 修预留给管理员的空间百分比&diams; -j 将ext2升级为ext3&diams; -O 文件系统属性启用或禁用, –O ^has_journal&diams; -o 调整文件系统的默认挂载选项，–o ^acl&diams; -U UUID 修改UUID号&diams; tune2fs -l /dev/sdb2&diams; tune2fs -o acl /dev/sdb2 增加acl功能&diams; tune2fs -o ^acl /dev/sdb2 取消acl功能 dumpe2fs&hearts; 命令：dumpe2fs 块分组管理，32768块&diams; -h：查看超级块信息，不显示分组信息&diams; dumpe2fs /dev/sdb1&diams; 超级块：文件系统的元数据、记录分区的属性&diams; 块大小、块分组 mount&hearts; 命令：mount mount相关概念&diams; 挂载:将额外文件系统与根文件系统某现存的目录建立起关联关系，进而使得此目录做为其它文件访问入口的行为&diams; 卸载:为解除此关联关系的过程&diams; 把设备关联挂载点：mount Point&raquo; mount&diams; 卸载时：可使用设备，也可以使用挂载点&raquo; umount&diams; 挂载点下原有文件在挂载完成后会被临时隐藏&diams; 挂载点目录一般为空 mount挂载方法&diams; mount DEVICE MOUNT_POINT&diams; mount [-fnrsvw] [-t vfstype] [-o options] device dir&raquo; device：指明要挂载的设备；&raquo; 设备文件：例如/dev/sda5&raquo; 卷标：-L ‘LABEL’, 例如 -L ‘MYDATA’&raquo; UUID, -U ‘UUID’：例如 -U ‘0c50523c-43f1-45e7-85c0-a126711d406e’&raquo; 伪文件系统名称：proc, sysfs, devtmpfs, configfs&diams; dir：挂载点&raquo; 事先存在；建议使用空目录&raquo; 进程正在使用中的设备无法被卸载 mount常用参数&diams; -t vsftype 指定要挂载的设备上的文件系统类型&diams; -r readonly，只读挂载&diams; -w read and write, 读写挂载&diams; -n 不更新/etc/mtab，mount不可见&diams; -a 自动挂载所有支持自动挂载的设备(定义在了/etc/fstab文件中，且挂载选项中有auto功能)&diams; -L ‘LABEL’ 以卷标指定挂载设备&diams; -U ‘UUID’ 以UUID指定要挂载的设备&diams; -B, –bind 绑定目录到另一个目录上 &diams; -o options：(挂载文件系统的选项)，多个选项使用逗号分隔&raquo; async 异步模式 sync 同步模式,内存更改时，同时写磁盘&raquo; atime/noatime 包含目录和文件&raquo; diratime/nodiratime 目录的访问时间戳&raquo; auto/noauto 是否支持自动挂载,是否支持-a选项&raquo; exec/noexec 是否支持将文件系统上运行应用程序&raquo; dev/nodev 是否支持在此文件系统上使用设备文件&raquo; suid/nosuid 是否支持suid和sgid权限&raquo; remount 重新挂载&raquo; ro只读 rw读写&raquo; user/nouser 是否允许普通用户挂载此设备，/etc/fstab使用&raquo; acl 启用此文件系统上的acl功能&raquo; loop 使用loop设备&raquo; mount -o remount,noatime /dev/sdb1 &diams; defaults：相当于rw, suid, dev, exec, auto, nouser, async &diams; 查看内核追踪到的已挂载的所有设备&raquo; cat /proc/mounts &hearts; 命令：umount 卸载&diams; umount DEVICE&diams; umount MOUNT_POINT findmnt&hearts; 命令：findmnt 查看挂载情况&diams; findmnt MOUNT_POINT|device 查看正在访问指定文件系统的进程&diams; lsof MOUNT_POINT&diams; fuser -v MOUNT_POINT 终止所有在正访问指定的文件系统的进程&diams; fuser -km MOUNT_POINT df&hearts; 命令：df 文件系统空间占用等信息的查看工具 df [OPTION]… [FILE]…&diams; -H 以1000为单位&diams; -T 文件系统类型&diams; -h: human-readable&diams; -i：inodes instead of blocks&diams; -P: 以Posix兼容的格式输出 du&hearts; 命令：du 查看某目录总体空间占用状态 du [OPTION]… DIR&diams; -h: human-readable&diams; -s: summary –max-depth dddd命令&hearts; 命令：dd dd命令：convert and copy a file 用法：&diams; dd if=/PATH/FROM/SRC of=/PATH/TO/DEST&diams; bs=#：block size, 复制单元大小&diams; count=#：复制多少个bs&diams; of=file 写到所命名的文件而不是到标准输出&diams; if=file 从所命名文件读取而不是从标准输入&diams; bs=size 指定块大小（既是是ibs也是obs)&diams; ibs=size 一次读size个byte&diams; obs=size 一次写size个byte&diams; cbs=size 一次转化size个byte&diams; skip=blocks 从开头忽略blocks个ibs大小的块&diams; seek=blocks 从开头忽略blocks个obs大小的块&diams; count=n 只拷贝n个记录&diams; conv=conversion[,conversion…] 用指定的参数转换文件&diams; 转换参数:&diams; ascii 转换 EBCDIC 为 ASCII&diams; ebcdic 转换 ASCII 为 EBCDIC&diams; lcase 把大写字符转换为小写字符&diams; ucase 把小写字符转换为大写字符&diams; nocreat 不创建输出文件&diams; noerror 出错时不停止&diams; notrunc 不截短输出文件&diams; sync 把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐&diams; Fdatasync 写完成前，物理写入输出文件 dd用法&hearts; dd实例 备份MBR&diams; dd if=/dev/sda of=/tmp/mbr.bak bs=512 count=1 破坏MBR中的bootloader&diams; dd if=/dev/zero of=/dev/sda bs=64 count=1 seek=446 将本地的/dev/sdx整盘备份到/dev/sdy&diams; dd if=/dev/sdx of=/dev/sdy 将/dev/sdx全盘数据备份到指定路径的image文件&diams; dd if=/dev/sdx of=/path/to/image 备份/dev/sdx全盘数据，并利用gzip压缩，保存到指定路径&diams; dd if=/dev/sdx | gzip &gt;/path/to/image.gz 将备份文件恢复到指定盘&diams; dd if=/path/to/image of=/dev/sdx 将压缩的备份文件恢复到指定盘&diams; gzip -dc /path/to/image.gz | dd of=/dev/sdx 将内存里的数据拷贝到root目录下的mem.bin文件&diams; dd if=/dev/mem of=/root/mem.bin bs=1024 从光盘拷贝iso镜像&diams; dd if=/dev/cdrom of=/root/cd.iso 销毁磁盘数据&diams; dd if=/dev/urandom of=/dev/sda1&diams; 利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据，执行此操作以后，/dev/sda1将无法挂载，创建和拷贝操作无法执行 得到最恰当的block size&diams; dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000&diams; dd if=/dev/zero of=/root/1Gb.file bs=2048 count=500000&diams; dd if=/dev/zero of=/root/1Gb.file bs=4096 count=250000 测试硬盘写速度&diams; dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000 测试硬盘读速度&diams; dd if=/root/1Gb.file bs=64k | dd of=/dev/null 修复硬盘&diams; dd if=/dev/sda of=/dev/sda&diams; 当硬盘较长时间（比如1,2年）放置不使用后，磁盘上会产生消磁点。当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数据起死回生,且这个过程是安全高效的 文件系统配制文件/etc/fstab介绍 配置文件系统体系 被mount、fsck和其它程序使用 系统重启时保留文件系统体系 可以在设备栏使用文件系统卷标 使用mount -a 命令挂载/etc/fstab中的所有文件系统 /etc/fstab文件编辑 /etc/fstab每行定义一个要挂载的文件系统&diams; 示图 12345678910UUID=11077dea-859c-4a04-9309-8c38a04b88e3 / ext4 defaults 1 1UUID=0b7a5801-4ce3-4b0a-a764-a7bb986609c2 /boot ext4 defaults 1 2UUID=46b4302e-6b7b-492c-830e-3e2fc144cc06 swap swap defaults 0 0 #文件系统检测次序tmpfs /dev/shm tmpfs defaults 0 0devpts /dev/pts devpts gid=5,mode=620 0 0sysfs /sys sysfs defaults 0 0proc /proc proc defaults 0 0/data/file1 /mnt/file1 ext4 loop 0 0/etc /mnt/etc none bind 0 0 参数详解&diams; 要挂载的设备或伪文件系统&raquo; 设备文件&raquo; LABEL：LABEL=””&raquo; UUID：UUID=””&raquo; 伪文件系统名称：proc, sysfs &diams; 挂载点 &diams; 文件系统类型：ext4,xfs,nfs,none &diams; 挂载选项：defaults ，acl，bind &diams; 转储频率：0：不做备份 1：每天转储 2：每隔一天转储 &diams; fsck检查的文件系统的顺序：允许的数字是0, 1, 和2 &raquo; 0：不自检 &raquo; 1：首先自检；一般只有rootfs才用 &raquo; 2：非rootfs使用 交换分区介绍&hearts; 相关概念 交换分区是系统RAM的补充 基本设置包括：&diams; 创建交换分区或者文件&diams; 使用mkswap写入特殊签名&diams; 在/etc/fstab文件中添加适当的条目&diams; 使用swapon -a 激活交换空间 启用：swapon&diams; swapon [OPTION]… [DEVICE]&raquo; -a：激活所有的交换分区&raquo; -p PRIORITY：指定优先级&raquo; /etc/fstab:pri=value 禁用：swapoff SWAP的优先级&diams; 可以指定swap分区0到32767的优先级，值越大优先级越高&diams; 如果用户没有指定，那么核心会自动给swap指定一个优先级，这个优先级从-1开始，每加入一个新的没有用户指定优先级的swap，会给这个优先级减一&diams; 先添加的swap的缺省优先级比较高，除非用户自己指定一个优先级，而用户指定的优先级(是正数)永远高于核心缺省指定的优先级(是负数)&diams; 优化性能：分布存放，高性能磁盘存放 RAIDRAID介绍&hearts; RAID介绍 RAID:Redundant Arrays of Inexpensive（Independent） Disks 1988年由加利福尼亚大学伯克利分校（University of California-Berkeley） “A Case for Redundant Arrays of Inexpensive Disks” &hearts; RAID作用 提高IO能力&diams; 磁盘并行读写 提高耐用性 多个磁盘合成一个“阵列”来提供更好的性能、冗余，或者两者都提供 RAID级别&hearts; RAID级别 级别：多块磁盘组织在一起的工作方式有所不同 RAID实现的方式&diams; 外接式磁盘阵列：通过扩展卡提供适配能力&diams; 内接式RAID：主板集成RAID控制器，安装OS前在BIOS里配置&diams; 软件RAID：通过OS实现 RAID-0&hearts; RAID-0 读、写性能提升 可用空间：N*min(S1,S2,…) 无容错能力 最少磁盘数：2, 2+&diams; 示图 RAID-1&hearts; RAID-1 读性能提升、写性能略有下降 可用空间：1*min(S1,S2,…) 有冗余能力 最少磁盘数：2, 2N&diams; 示图 RAID-4&hearts; RAID-4 多块数据盘异或运算值存于专用校验盘 RAID-5&hearts; RAID-5 读、写性能提升 可用空间：(N-1)*min(S1,S2,…) 有容错能力：允许最多1块磁盘损坏 最少磁盘数：3, 3+&diams; 示图 RAID-6&hearts; RAID-6 读、写性能提升 可用空间：(N-2)*min(S1,S2,…) 有容错能力：允许最多2块磁盘损坏 最少磁盘数：4, 4+&diams; 示图 RAID-10&hearts; RAID-10 读、写性能提升 可用空间：N*min(S1,S2,…)/2 有容错能力：每组镜像最多只能坏一块 最少磁盘数：4, 4+&diams; 示图 RAID-01&hearts; RAID-01 多块磁盘先实现RAID0,再组合成RAID1&diams; 示图 RAID-50&hearts; RAID-50 多块磁盘先实现RAID5,再组合成RAID0&diams; 示图 JBOD&hearts; JBOD 功能：将多块磁盘的空间合并一个大的连续空间使用可用空间：sum(S1,S2,…)&diams; 示图 RAID-7 可以理解为一个独立存储计算机，自身带有操作系统和管理工具，可以独立运行，理论上性能最高的RAID模式 LVM逻辑卷LVM介绍及相关概念&hearts; LVM逻辑卷管理器介绍 逻辑卷管理器（英语：Logical VolumeManager，缩写为LVM），又译为逻辑卷宗管理器、逻辑扇区管理器、逻辑磁盘管理器，是Linux核心所提供的逻辑卷管理（Logical volume management）功能。它在硬盘的硬盘分区之上，又创建一个逻辑层，以方便系统管理硬盘分区系统。最先由IBM开发，在AIX系统上实现，OS/2 操作系统与 HP-UX也支持这个功能。在1998年，Heinz Mauelshagen 根据在 HP-UX 上的逻辑卷管理器，写作出第一个 Linux 版本的逻辑卷管理器。 允许对卷进行方便操作的抽象层，包括重新设定文件系统的大小 允许在多个物理设备间重新组织文件系统&diams; 将设备指定为物理卷&diams; 用一个或者多个物理卷来创建一个卷组&diams; 物理卷是用固定大小的物理区域（Physical Extent，PE）来定义的&diams; 在物理卷上创建的逻辑卷,是由物理区域（PE）组成&diams; 可以在逻辑卷上创建文件系统 LVM可以弹性的更改LVM的容量 通过交换PE来进行资料的转换，将原来LV内的PE转移到其他的设备中以降低LV的容量，或将其他设备中的PE加到LV中以加大容量&diams; 示图 LVM逻辑卷实现PV管理工具&hearts; PV 显示pv信息&diams; pvs：简要pv信息显示&diams; pvdisplay 创建pv&diams; pvcreate /dev/DEVICE VG管理工具&hearts; VG 显示卷组&diams; vgs&diams; vgdisplay 创建卷组&diams; vgcreate [-s #[kKmMgGtTpPeE]] VolumeGroupName&diams; PhysicalDevicePath [PhysicalDevicePath…] 管理卷组&diams; vgextend VolumeGroupName PhysicalDevicePath [PhysicalDevicePath…]&diams; vgreduce VolumeGroupName PhysicalDevicePath [PhysicalDevicePath…] 删除卷组&diams; 先做pvmove，再做vgremove LV管理工具显示逻辑卷&hearts; lv 显示逻辑卷&diams; lvs&diams; Lvdisplay 创建逻辑卷&hearts; 创建 创建逻辑卷&diams; lvcreate -L #[mMgGtT] -n NAME VolumeGroup&diams; lvcreate -l 60%VG -n mylv testvg&diams; lvcreate -l 100%FREE -n yourlv testvg 删除逻辑卷&hearts; 删除 删除逻辑卷&diams; lvremove /dev/VG_NAME/LV_NAME 重设文件系统大小&diams; fsadm [options] resize device [new_size[BKMGTEP]]&diams; resize2fs [-f] [-F] [-M] [-P] [-p] device [new_size] 扩展逻辑卷&hearts; 扩展 扩展逻辑卷：&diams; lvextend -L [+]#[mMgGtT] /dev/VG_NAME/LV_NAME&diams; resize2fs /dev/VG_NAME/LV_NAME&diams; lvresize -r -l +100%FREE /dev/VG_NAME/LV_NAME 缩减逻辑卷&hearts; 缩减 缩减逻辑卷：&diams; umount /dev/VG_NAME/LV_NAME&diams; e2fsck -f /dev/VG_NAME/LV_NAME&diams; resize2fs /dev/VG_NAME/LV_NAME #[mMgGtT]&diams; lvreduce -L [-]#[mMgGtT] /dev/VG_NAME/LV_NAME&diams; mount 跨主机迁移卷组&hearts; 迁移 源计算机上&diams; 第一步&raquo; 在旧系统中，umount所有卷组上的逻辑卷 &diams; 第二步 &raquo; vgchange –a n vg0 &raquo; lvdisplay &diams; 第三步 &raquo; vgexport vg0 &raquo; pvscan &raquo; vgdisplay &raquo; 拆下旧硬盘 在目标计算机上&diams; 第四步&raquo; 在新系统中安装旧硬盘，并vgimport vg0. &diams; 第五步 &raquo; vgchange –ay vg0 &diams; 第六步 &raquo; mount所有卷组上的逻辑卷 创建逻辑卷示例&hearts; 示例 创建物理卷&diams; pvcreate /dev/sda3 为卷组分配物理卷&diams; vgcreate vg0 /dev/sda3 从卷组创建逻辑卷&diams; lvcreate -L 256M -n data vg0&diams; mke2fs -j /dev/vg0/data mount /dev/vg0/data /mnt/data LVM逻辑卷快照LVM快照介绍&hearts; 快照介绍 快照是特殊的逻辑卷，它是在生成快照时存在的逻辑卷的准确拷贝 对于需要备份或者复制的现有数据临时拷贝以及其它操作来说，快照是最合适的选择 快照只有在它们和原来的逻辑卷不同时才会消耗空间&diams; 在生成快照时会分配给它一定的空间，但只有在原来的逻辑卷或者快照有所改变才会使用这些空间&diams; 当原来的逻辑卷中有所改变时，会将旧的数据复制到快照中。&diams; 快照中只含有原来的逻辑卷中更改的数据或者自生成快照后的快照中更改的数据&diams; 建立快照的卷大小只需要原始逻辑卷的15%～20%就够了,也可以使用lvextend放大快照&diams; 快照就是将当时的系统信息记录下来，就好像照相一般，若将来有任何数据改动了，则原始数据会被移动到快照区，没有改动的区域则由快照区和文件系统共享&diams; 由于快照区与原本的LV共用很多PE的区块，因此快照与被快照的LV必须在同一个VG中.系统恢复的时候的文件数量不能高于快照区的实际容量&diams; 示图 LVM快照实现&hearts; LVM快照实现 为现有逻辑卷创建快照&diams; lvcreate -l 64 -s -n data-snapshot -p r /dev/vg0/data 挂载快照&diams; mkdir -p /mnt/snap&diams; mount -o ro /dev/vg0/data-snapshot /mnt/snap 恢复快照&diams; umount /dev/vg0/data-snapshot&diams; umount /dev/vg0/data&diams; lvconvert –merge /dev/vg0/data-snapshot 删除快照&diams; umount /mnt/databackup&diams; lvremove /dev/vg0/databackup 综合练习 创建一个2G的文件系统，块大小为2048byte，预留1%可用空间,文件系统ext4，卷标为TEST，要求此分区开机后自动挂载至/test目录，且默认有acl挂载选项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647fdisk /dev/sdbWARNING: DOS-compatible mode is deprecated. It's strongly recommended to switch off the mode (command 'c') and change display units to sectors (command 'u').Command (m for help): nCommand action e extended p primary partition (1-4)pPartition number (1-4): 1First cylinder (1-2610, default 1): Using default value 1Last cylinder, +cylinders or +size&#123;K,M,G&#125; (1-2610, default 2610): +2GCommand (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes255 heads, 63 sectors/track, 2610 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0xac950244 Device Boot Start End Blocks Id System/dev/sdb1 1 262 2104483+ 83 LinuxCommand (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks.#分区 -m指定预留空间 -b指定块大小mkfs.ext4 -b 2048 -m 1 -L "TEST" /dev/sdb1#创建目录，挂载目录并启用acl功能mkdir /test ; mount -o acl /dev/sdb1 /test#查看分区uuidlsblk -fblkid /dev/sdb1#开机挂载UUID=6e6d76d2-974d-4db2-aa20-7f3189086b2b /test ext4 acl 0 0#检测配置文件是否有错mount -a #查看块大小tune2fs -l /dev/sdb1 | grep -i block 创建一个至少有两个PV组成的大小为10G的名为testvg的VG；要求PE大小为16MB, 而后在卷组中创建大小为5G的逻辑卷testlv；挂载至/users目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657分两个为8e标签的分区Command (m for help): nCommand action e extended p primary partition (1-4)pPartition number (1-4): 1First cylinder (1-2610, default 1): Using default value 1Last cylinder, +cylinders or +size&#123;K,M,G&#125; (1-2610, default 2610): +5GCommand (m for help): tSelected partition 1Hex code (type L to list codes): 8eChanged system type of partition 1 to 8e (Linux LVM)Command (m for help): nCommand action e extended p primary partition (1-4)pPartition number (1-4): 2First cylinder (655-2610, default 655): Using default value 655Last cylinder, +cylinders or +size&#123;K,M,G&#125; (655-2610, default 2610): +5GCommand (m for help): t Partition number (1-4): 2Hex code (type L to list codes): 8eChanged system type of partition 2 to 8e (Linux LVM)Command (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes255 heads, 63 sectors/track, 2610 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0xac950244 Device Boot Start End Blocks Id System/dev/sdb1 1 654 5253223+ 8e Linux LVM/dev/sdb2 655 1308 5253255 8e Linux LVMCommand (m for help): w##pvcreate /dev/sdb1 /dev/sdb2vgdisplay#vgcreate -s 16m testvg /dev/sdb1 /dev/sdb2 vgdisplay#lvcreate -L 5G -n testlv testvglvcreate -l +50%free -n testlv testvgmkfs.ext4 /dev/testvg/testlvmount /dev/testvb/testlv /users]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件包管理]]></title>
    <url>%2F2018%2F08%2F10%2F%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[软件包管理软件包相关概念&hearts; 二进制程序组成部分 二进制文件、库文件、配置文件、帮助文件 &hearts; 开发语言 系统级开发&diams; C&diams; C++ 应用级开发&diams; java&diams; Python&diams; go&diams; php&diams; perl&diams; delphi&diams; ruby &hearts; 软件运行和编译 ABI：Application Binary Interface&raquo; 二进制调用接口&diams; Windows与Linux不兼容&raquo; ELF(Executable and Linkable Format&raquo; PE（Portable Executable）&diams; 库级别的虚拟化：&raquo; Linux: WINE&raquo; Windows: Cygwin API：Application Programming Interface&diams; 库接口&raquo; POSIX：Portable OS 执行过程&diams; 程序源代码 –&gt; 预处理 –&gt; 编译 –&gt; 汇编 –&gt; 链接&diams; 静态编译：.a&diams; 动态编译：.so 相应程序编译过程&diams; C程序编译过程&diams; Java程序运行 &hearts; 静态和动态链接 链接作用：&diams; 链接主要作用是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确地衔接，分为静态链接和动态链接 静态链接&diams; 把程序对应的依赖库复制一份到包&diams; libxxx.a&diams; 嵌入程序包&diams; 升级难，需重新编译&diams; 占用较多空间，迁移容易 动态链接&diams; 只把依赖加做一个动态链接&diams; libxxx.so&diams; 连接指向&diams; 占用较少空间，升级方便&diams; 链接示图&diams; C程序静态链接示图 包管理器&hearts; 程序包管理器的作用 功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件，从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作 &hearts; 包管理分类 debian： deb文件, dpkg包管理器 redhat： rpm文件, rpm包管理器 rpm： Redhat Package Manager 源代码：name-VERSION.tar.gz|bz2|xz&diams; VERSION: major.minor.release &hearts; rpm包名令方式 name-VERSION-release.arch.rpm&diams; 例：bash-4.2.46-19.el7.x86_64.rpm&diams; VERSION: major.minor.release&diams; release：release.OS 常见的arch：&diams; x86: i386, i486, i586, i686&diams; x86_64: x64, x86_64, amd64&diams; powerpc: ppc&diams; 跟平台无关：noarch &hearts; 包组成及依赖 包分类&diams; Application-VERSION-ARCH.rpm: 主包&diams; Application-devel-VERSION-ARCH.rpm 开发子包&diams; Application-utils-VERSION-ARHC.rpm 其它子包&diams; Application-libs-VERSION-ARHC.rpm 其它子包&diams; 注：包之间可能存在依赖关系，甚至循环依赖&diams; 解决依赖工具&raquo; yum：rpm包管理器的前端工具&raquo; apt-get：deb包管理器前端工具&raquo; zypper: suse上的rpm前端管理工具&raquo; dnf: Fedora 18+ rpm包管理器前端管理工具 库文件&diams; 查看二进制程序所依赖的库文件&raquo; ldd /PATH/TO/BINARY_FILE&diams; 管理及查看本机装载的库文件&raquo; ldconfig 加载库文件&raquo; /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件路径&diams; 映射关系&raquo; 配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf&raquo; 缓存文件：/etc/ld.so.cache rpm包管理器rpm包来源&hearts; rpm包 包文件组成 (每个包独有)&diams; RPM包内的文件&diams; RPM的元数据，如名称，版本，依赖性，描述等&diams; 安装或卸载时运行的脚本 数据库(公共)：/var/lib/rpm&diams; 程序包名称及版本&diams; 依赖关系&diams; 功能说明&diams; 包安装后生成的各文件路径及校验码信息 获取程序包的途径：&diams; 系统发版的光盘或官方的服务器&raquo; CentOS镜像：&raquo; https://www.centos.org/download/&raquo; http://mirrors.aliyun.com&raquo; http://mirrors.sohu.com&raquo; http://mirrors.163.com&diams; 项目官方站点&diams; 第三方组织&raquo; Fedora-EPEL： Extra Packages for Enterprise Linux&raquo; Rpmforge:RHEL推荐，包很全&raquo; 搜索引擎：&raquo; http://pkgs.org&raquo; http://rpmfind.net&raquo; http://rpm.pbone.net&raquo; https://sourceforge.net/&raquo; 第三方包建议要检查其合法性来源合法性,程序包的完整性&diams; 自己制作 rpm命令&hearts; rpm命令 CentOS系统上使用rpm命令管理程序包：&diams; 安装、卸载、升级、查询、校验、数据库维护&diams; rpm -ivh PACKAGE_FILE &hearts; rpm包安装 相关参数&diams; –test: 测试安装，但不真正执行安装，即dry run模式&diams; –nodeps：忽略依赖关系&diams; –replacepkgs | replacefiles&diams; –nosignature: 不检查来源合法性&diams; –nodigest：不检查包完整性&diams; –noscripts：不执行程序包脚本&raquo; %pre: 安装前脚本 –nopre&raquo; %post: 安装后脚本 –nopost&raquo; %preun: 卸载前脚本 –nopreun&raquo; %postun: 卸载后脚本 –nopostun&raquo; –force强制安装 &hearts; rpm包升级 rpm {-U|–upgrade} [install-options] PACKAGE_FILE…&diams; rpm -Uvh PACKAGE_FILE …&diams; upgrade：&raquo; 安装有旧版程序包，则“升级”&raquo; 如果不存在旧版程序包，则“安装” rpm {-F|–freshen} [install-options] PACKAGE_FILE…&diams; rpm -Fvh PACKAGE_FILE …&diams; freshen&raquo; 安装有旧版程序包，则“升级”&raquo; 如果不存在旧版程序包，则不执行升级操作&raquo; –oldpackage：降级 &hearts; rpm包查询 rpm {-q|–query} [select-options] [query-options]&diams; [select-options]&raquo; -a: 所有包&raquo; -f: 查看指定的文件由哪个程序包安装生成&raquo; -p rpmfile：针对尚未安装的程序包文件做查询操作&raquo; –whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供&raquo; –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖&raquo; rpm2cpio 包文件|cpio –itv 预览包内文件&raquo; rpm2cpio 包文件|cpio –id “*.conf” 释放包内文件&diams; [query-options]&raquo; –changelog：查询rpm包的changelog&raquo; -c: 查询程序的配置文件&raquo; -d: 查询程序的文档&raquo; -i: information&raquo; -l: 查看指定的程序包安装后生成的所有文件&raquo; –scripts：程序包自带的脚本 1rpm -q --scripts httpd &raquo; –provides: 列出指定程序包所提供的CAPABILITY &raquo; -R: 查询指定的程序包所依赖的CAPABILITY &diams; 常用组合 12345678-qa #查询所有包-qi PACKAGE, #查询包相关信息-qf FILE, #查询指定的文件由哪个程序包安装生成，常用查询命令由那个包安装-qc PACKAGE, #查询程序的配置文件，服务软件常用-ql PACKAGE, #查询指定的程序包安装后生成的所有文件-qd PACKAGE #查询程序的文档-qpi PACKAGE_FILE, #查询未安装程序的相关信息-qpl PACKAGE_FILE, #查询未安装程序，安装后会生成的所有文件 &hearts; rpm校验 包来源合法性验正及完整性验正&diams; 完整性验正：SHA256&diams; 来源合法性验正：RSA 公钥加密&diams; 对称加密：加密、解密使用同一密钥&diams; 非对称加密：密钥是成对儿的&raquo; public key: 公钥，公开所有人&raquo; secret key: 私钥, 不能公开 导入所需要公钥&diams; rpm -K|checksig rpmfile 检查包的完整性和签名&diams; rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7&diams; CentOS 7发行版光盘提供：RPM-GPG-KEY-CentOS-7&diams; rpm -qa “gpg-pubkey*” &hearts; rpm数据库 /var/lib/rpm rpm数据库相关参数： rpm {–initdb|–rebuilddb}&diams; initdb: 初始化&raquo; 如果事先不存在数据库，则新建之&raquo; 否则，不执行任何操作&diams; rebuilddb：&raquo; 重建已安装的包头的数据库索引目录 yumyum介绍&hearts; yum介绍 YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依赖性，可在多个库之间定位软件包，up2date的替代工具&diams; yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据&diams; 放置于特定目录repodata下 如下文件服务器：&raquo; http://&raquo; https://&raquo; ftp://&raquo; file:// &hearts; yum配置文件 yum客户端配置文件：&diams; /etc/yum.conf：为所有仓库提供公共配置&diams; /etc/yum.repos.d/*.repo：为仓库的指向提供配置&raquo; 仓库指向的定义： 1234567891011[repositoryID]name=Some name for this repositorybaseurl=url://path/to/repository/enabled=&#123;1|0&#125;gpgcheck=&#123;1|0&#125;gpgkey=URLenablegroups=&#123;1|0&#125;failovermethod=&#123;roundrobin|priority&#125;roundrobin： 意为随机挑选，默认值priority: 按顺序访问cost= 默认为1000 yum的repo配置文件中可用的变量：&diams; $releasever: 当前OS的发行版的主版本号&diams; $arch: 平台，i386,i486,i586,x86_64等&diams; $basearch：基础平台；i386, x86_64&diams; $YUM0-$YUM9:自定义变量&diams; 实例:&raquo; http://server/centos/$releasever/$basearch/&raquo; http://server/centos/7/x86_64&raquo; http://server/centos/6/i384 yum源&hearts; 常用yum源 阿里云repo文件：&diams; http://mirrors.aliyun.com/repo/ CentOS系统的yum源&diams; 阿里云：https://mirrors.aliyun.com/centos/$releasever/os/x86_64/&diams; 清华：https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/x86_64/ EPEL的yum源:&diams; 阿里云：https://mirrors.aliyun.com/epel/$releasever/x86_64 管理命令&diams; yum-config-manager&raquo; yum-config-manager –disable “仓库名” 禁用仓库&raquo; yum-config-manager –enable “仓库名” 启用仓库 yum命令&hearts; yum命令常用参数 查看程序包information：&diams; yum info 查看指定的特性(可以是某文件)是由哪个程序包所提供：&diams; yum provides | whatprovides feature1 [feature2] […] 清理本地缓存：&diams; 清除/var/cache/yum/$basearch/$releasever缓存&diams; yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ] 构建缓存：&diams; yum makecache 搜索：yum search string1 [string2] […]&diams; 以指定的关键字搜索程序包名及summary信息 查看指定包所依赖的capabilities：&diams; yum deplist package1 [package2] […] 查看yum事务历史：&diams; yum history [info|list|packages-list|packages-info|&diams; summary|addon-info|redo|undo|&diams; rollback|new|sync|stats]&diams; yum history&diams; yum history info 6&diams; yum history undo 6 #卸载包跟所安装的依赖包 （实用） 常用选项：&diams; –nogpgcheck：禁止进行gpg check&diams; -y: 自动回答为“yes”&diams; -q：静默模式&diams; –disablerepo=repoidglob：临时禁用此处指定的repo&diams; –enablerepo=repoidglob：临时启用此处指定的repo&diams; –noplugins：禁用所有插件 日志&diams; /var/log/yum.log &hearts; yum安装及升级本地程序包 安装&diams; yum -y install rpmfile1 [rpmfile2] […] -y 自动应答 升级&diams; yum -y update rpmfile1 [rpmfile2] […] &hearts; 包组管理的相关命令： 包组管理的相关命令：&diams; yum groupinstall group1 [group2] […]&diams; yum groupupdate group1 [group2] […]&diams; yum grouplist [hidden] [groupwildcard] […]&diams; yum groupremove group1 [group2] […]&diams; yum groupinfo group1 […] yum仓库搭建&hearts; 光盘yum源 系统安装光盘作为本地yum仓库：&diams; 挂载光盘至某目录，例如/media&raquo; mount /dev/sr0 /media 创建配置文件&diams; 示例 1234567891011[media]#这个repo的名字name=media#仓库的路径baseurl=file:///media#是否启用这个repoenabled=1#是否检测包的合法性gpgcheck=yes#key的路径gpgkey=/media/RPM-GPG-KEY-CentOS-6 创建yum仓库&diams; createrepo [options] &raquo; 仓库一定会有一个repodata 目录用来存放各包的依赖关系，这个包由createrepo来创建 源码包安装&hearts; 程序包相关内容 开源程序源代码的获取：&diams; 官方自建站点：&raquo; apache.org (ASF：Apache Software Foundation)&raquo; mariadb.org &diams; 代码托管：&raquo; SourceForge.net&raquo; Github.com&raquo; code.google.com 程序包编译安装过程：&diams; Application-VERSION-release.src.rpm –&gt; 安装后，使用rpmbuild命令制作成二进制格式的rpm包，而后再安装&diams; 源代码–&gt;预处理–&gt;编译–&gt;汇编–&gt;链接–&gt;执行&diams; 源代码组织格式：&diams; 多文件：文件中的代码之间，很可能存在跨文件依赖关系C、C++：make 项目管理器&raquo; configure脚本 –&gt; Makefile.in –&gt; Makefile&raquo; java: maven&diams; 开发工具：&raquo; autoconf: 生成configure脚本&raquo; automake：生成Makefile.in &hearts; 程序包编译步骤 C语言源代码编译安装三步骤： &diams; ./configure&raquo; 通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的指定以及Makefile.in文件生成Makefile&raquo; 检查依赖到的外部环境，如依赖的软件包 &diams; make 根据Makefile文件，构建应用程序 &diams; make install 复制文件到相应路径 注意事项&diams; 安装前查看INSTALL，README&diams; 提供开发工具&raquo; 开发工具：make, gcc等 &diams; 提供开发环境&raquo; Development Tools&raquo; Server Platform Development 综合练习例题： 请配置一个自定义的yum源，给CentOS6系统使用，通过这个yum源可以顺利安装httpd软件，要求yum源中仅包含httpd相关的软件包，没有其他不相关的软件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263yum -y install yum-utils#找出httpd所依赖的包repoquery --requires --resolve httpd &gt;&gt; /opt/httpd.file#提取出来的名称会比光盘里的包里的包多一个0、2: 处理/opt/httpd.file文件sed -i.bak "s#[0-9]:##g" /opt/httpd.filemount /dev/sr0 /medials /media/Packages/ &gt;&gt; /opt/media.file# 利用脚本复制对应的包到对应的目录# httpd的yum仓库定义在/data/httpd目录下#!/bin/bashif [ -d /data/httpd ]then rm -rf /data/httpd &amp;&gt;/dev/null mkdir -p /data/httpd &amp;&gt;/dev/nullelse mkdir -p /data/httpdfifor i in `cat /opt/media.file`do for k in `cat /opt/httpd.file` do if [[ "$i" =~ "$k" ]] then cd /media/Packages/ cp "$i" /data/httpd &amp;&gt;/dev/null else true fi donedonerpm -qa | grep createrepo &amp;&gt;/dev/nullif [ $? -ne 0 ]then yum -y install createrepo &amp;&gt;/dev/nullelse trueficreaterepo /data/httpd &amp;&gt;/dev/nullcat &gt;&gt; /etc/yum.repos.d/httpd.repo &lt;&lt;EFO[httpd]name=httpdbaseurl=file:///data/httpdgpgcheck=0EFO#写成交互式read -t 30 -p "Please input a package: " var[ -z $var ] &amp;&amp; &#123; echo "You input is empty" ; exit 2 ; &#125;epoquery --requires --resolve $var &gt;&gt; /opt/$var.filecout=$(cat /opt/$var.file | wc -c)if [ $cout -eq 0 ]then echo "The package you entered does not exist" exit 2 else truefi#剩下的跟前面的步骤一下，目录用变量替换]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本处理工具sed]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7sed%2F</url>
    <content type="text"><![CDATA[处理文本的工具sedsed介绍&hearts; Stream EDitor, 行编辑器&hearts; sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。然后读入下行，执行下一个循环。如果没有使诸如‘D’的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。&hearts; 功能：主要用来自动编辑一个或多个文件,简化对文件的反复操作,编写转换程序等 sed用法&hearts; 常用选项 -n：不输出模式空间内容到屏幕，即不自动打印 -e: 多点编辑 -f：/PATH/SCRIPT_FILE: 从指定文件中读取编辑脚本 -r: 支持使用扩展正则表达式 -i.bak: 备份文件并原处编辑 &hearts; 地址定界： 不给地址：对全文进行处理 单地址：&diams; #: 指定的行，$：最后一行&diams; /pattern/：被此处模式所能够匹配到的每一行 地址范围：&diams; #,#&diams; #,+#&diams; /pat1/,/pat2/&diams; #, /pat1/ ~：步进&diams; 1~2 奇数行&diams; 2~2 偶数行 &hearts; 编辑命令： 选项&diams; d 删除模式空间匹配的行，并立即启用下一轮循环&diams; p 打印当前模式空间内容，追加到默认输出之后&diams; a []text 在指定行后面追加文本，支持使用\n实现多行追加&diams; i []text 在行前面插入文本&diams; c []text 替换行为单行或多行文本&diams; w /path/file 保存模式匹配的行至指定文件&diams; r /path/file 读取指定文件的文本至模式空间中匹配到的行后&diams; = 为模式空间中的行打印行号&diams; ! 模式空间中匹配行取反处理 &hearts; 查找替换 s/// 查找替换,支持使用其它分隔符，s@@@，s### 替换标记：&diams; g 行内全局替换&diams; p 显示替换成功的行&diams; w /PATH/FILE 将替换成功的行保存至文件中 &hearts; sed示例 sed ‘2p’ /etc/passwd sed –n ‘2p’ /etc/passwd sed –n ‘1,4p’ /etc/passwd sed –n ‘/root/p’ /etc/passwd sed –n ‘2,/root/p’ /etc/passwd 从2行开始 sed -n ‘/^$/=’ file 显示空行行号 sed –n –e ‘/^$/p’ –e ‘/^$/=’ file sed ‘/root/a\superman’ /etc/passwd行后 sed ‘/root/i\superman’ /etc/passwd 行前 sed ‘/root/c\superman’ /etc/passwd 代替行 sed ‘/^$/d’ file sed ‘1,10d’ file nl /etc/passwd | sed ‘2,5d’ nl /etc/passwd | sed ‘2a tea’ sed ‘s/test/mytest/g’ example sed –n ‘s/root/&amp;superman/p’ /etc/passwd 单词后 sed –n ‘s/root/superman&amp;/p’ /etc/passwd 单词前 sed -e ‘s/dog/cat/’ -e ‘s/hi/lo/’ pets sed –i.bak ‘s/dog/cat/g’ pets 高级编辑命令&hearts; 常用选项 P： 打印模式空间开端至\n内容，并追加到默认输出之前 h: 把模式空间中的内容覆盖至保持空间中 H：把模式空间中的内容追加至保持空间中 g: 从保持空间取出数据覆盖至模式空间 G：从保持空间取出内容追加至模式空间 x: 把模式空间中的内容与保持空间中的内容进行互换 n: 读取匹配到的行的下一行覆盖至模式空间 N：读取匹配到的行的下一行追加至模式空间 d: 删除模式空间中的行 D：如果模式空间包含换行符，则删除直到第一个换行符的模式空间中的文本，并不会读取新的输入行，而使用合成的模式空间重新启动循环。如果模式空间不包含换行符，则会像发出d命令那样启动正常的新循环 练习&hearts; 习题整理 删除centos7系统/etc/grub2.cfg文件中所有以空白开头的行行首的空白字符 1cat /etc/grub2.cfg | sed -r 's/^[[:space:]]+//g' 删除/etc/fstab文件中所有以#开头，后面至少跟一个空白字符的行的行首的#和空白字符 1cat /etc/fstab | sed -r 's/^#[[:space:]]+//g' 在centos6系统/root/install.log每一行行首增加#号 1cat /root/install.log| sed 's/^[^#]/#&amp;/g' 处理/etc/fstab路径,使用sed命令取出其目录名和基名 12echo /etc/fstab | sed -r 's#(.*/)([^/]+$)#\1#g'echo /etc/fstab | sed -r 's#(.*/)([^/]+$)#\2#g' 利用sed 取出ifconfig命令中本机的IPv4地址 1ifconfig | sed -n '/^eth0/,/inet/p' | sed -r -n '2s#( .*inet )(.*)( netmask .*)#\2#gp 统计centos安装光盘中Package目录下的所有rpm文件的以.分隔倒数第二个字段的重复次数 1ls /media/Packages/ | sed '/TRANS/d' |sed -r 's#(.*\.)([^.]+\.rpm$)#\2#' | sed -r 's#(.rpm)##g' | sort | uniq -c | sort -nr 统计/etc/init.d/functions文件中每个单词的出现次数，并排序（用grep和sed两种方法分别实现） 12cat /etc/init.d/functions | egrep -o '\&lt;[[:alpha:]]+\&gt;' | sort | uniq -c | sort -nrcat /etc/init.d/functions | sed -r 's#[^[:alpha:]]+#\n#g' | sort | uniq -c | sort -nr 将文本文件的n和n+1行合并为一行，n为奇数行 1seq 1 10 | sed 'N;s#\n##g' 用sed把/etc/passwd 中的奇数行保存到/opt/pass.file下 1cat /etc/passwd | sed -n '1~2w /opt/pass.file' 复制/etc/profile至/tmp/目录，用查找替换命令删除/tmp/profile文件中的行首的空白字符 1cat /etc/profile | sed -i.bak -r 's#^[[:space:]]+##g' 复制/etc/rc.d/init.d/functions文件至/tmp目录，用查找替换命令为/tmp/functions的每行开头为空白字符的行的行首添加一个#号 12cp /etc/rc.d/init.d/functions /tmp ; cd /tmpsed -i.bak -r 's/^[[:space:]]+/#&amp;/g' functions]]></content>
      <categories>
        <category>linuxshell</category>
      </categories>
      <tags>
        <tag>linuxshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件查找和压缩]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[文件查找&hearts; 概念：在文件系统上查找符合条件的文件 文件查找：locate, find&diams; 非实时查找(数据库查找)：locate&diams; 实时查找：find locate 使用&hearts; 介绍 查询系统上预建的文件索引数据库&diams; /var/lib/mlocate/mlocate.db 依赖于事先构建的索引&diams; 索引的构建是在系统较为空闲时自动进行(周期性任务)，管理员手动更新数据库(updatedb) 索引构建过程需要遍历整个根文件系统，极消耗资源 工作特点:&diams; 查找速度快&diams; 模糊查找&diams; 非实时查找&diams; 搜索的是文件的全路径，不仅仅是文件名&diams; 可能只搜索用户具备读取和执行权限的目录 &hearts; locate使用 locate KEYWORD 有用的选项&diams; -i 不区分大小写的搜索&diams; -n N 只列举前N个匹配项目&diams; -r 使用正则表达式 示例&diams; 搜索名称或路径中带有“conf”的文件&raquo; locate conf&diams; 使用Regex来搜索以“.conf”结尾的文件&raquo; locate -r ‘\.conf$’ find介绍 &hearts; 介绍 实时查找工具，通过遍历指定路径完成文件查找 工作特点：&diams; 查找速度略慢&diams; 精确查找&diams; 实时查找&diams; 可能只搜索用户具备读取和执行权限的目录 语法&hearts; 语法 find [OPTION]… [查找路径] [查找条件] [处理动作]&diams; 查找路径：指定具体目标路径；默认为当前目录&diams; 查找条件：指定的查找标准，可以文件名、大小、类型、权限等标准进行；默认为找出指定路径下的所有文件&diams; 处理动作：对符合条件的文件做操作，默认输出至屏幕 指搜索层级&hearts; 指定搜索条件 -maxdepth level 最大搜索目录深度,指定目录为第1级 -mindepth level 最小搜索目录深度 先处理目录内的文件，再处理目录&diams; -depth 根据文件名和inode查找：&hearts; 指定搜索条件 -name “文件名称”：支持使用glob *, ?, [], [^] -iname “文件名称”：不区分字母大小写 -inum n 按inode号查找 -samefile name 相同inode号的文件 -links n 链接数为n的文件 -regex “PATTERN”：以PATTERN匹配整个文件路径，而非文件名称 根据属主、属组查找：&hearts; 指定搜索条件 -user USERNAME：查找属主为指定用户(UID)的文件 -group GRPNAME: 查找属组为指定组(GID)的文件 -uid UserID：查找属主为指定的UID号的文件 -gid GroupID：查找属组为指定的GID号的文件 -nouser：查找没有属主的文件 -nogroup：查找没有属组的文件 根据文件类型查找： -type TYPE&hearts; 指定搜索条件 f: 普通文件 d: 目录文件 l: 符号链接文件 s：套接字文件 b: 块设备文件 c: 字符设备文件 p: 管道文件 空文件或目录&hearts; 指定搜索条件 -empty find /app -type d -empty 组合条件：&hearts; 指定搜索条件 与：-a 或：-o 非：-not, ! 德·摩根定律：&diams; (非 A) 或 (非 B) = 非(A 且 B)&diams; (非 A) 且 (非 B) = 非(A 或 B) 示例：&diams; !A -a !B = !(A -o B)&diams; !A -o !B = !(A -a B) 文件大小、时间来查找&hearts; 根据文件大小来查找： -size [+|-]#UNIT&diams; 常用单位：k, M, G，c（byte）&diams; #UNIT: (#-1, #]&raquo; 如：6k 表示(5k,6k]&diams; -#UNIT：[0,#-1]&raquo; 如：-6k 表示[0,5k]&diams; +#UNIT：(#,∞)&raquo; 如：+6k 表示(6k,∞) &hearts; 根据时间戳： 以“天”为单位&diams; -atime [+|-]#,&raquo; #: [#,#+1)&raquo; +#: [#+1,∞]&raquo; -#: [0,#)&diams; -mtime&diams; -ctime 以“分钟”为单位&diams; -amin&diams; -mmin&diams; -cmin 根据权限查找：&hearts; 权限 -perm [/|-]MODE&diams; MODE: 精确权限匹配&diams; /MODE：任何一类(u,g,o)对象的权限中只要能一位匹配即可，或关系，+ 从centos7开始淘汰&diams; -MODE：每一类对象都必须同时拥有指定权限，与关系&diams; 0 表示不关注 find -perm 755 会匹配权限模式恰好是755的文件 只要当任意人有写权限时，find -perm +222就会匹配 只有当每个人都有写权限时，find -perm -222才会匹配 只有当其它人（other）有写权限时，find -perm -002才会匹配 处理动作&hearts; 处理动作 -print：默认的处理动作，显示至屏幕 -ls：类似于对查找到的文件执行“ls -l”命令 -delete：删除查找到的文件 -fls file：查找到的所有文件的长格式信息保存至指定文件中 -ok COMMAND {} \; 对查找到的每个文件执行由COMMAND指定的命令，对于每个文件执行命令之前，都会交互式要求用户确认 -exec COMMAND {} \; 对查找到的每个文件执行由COMMAND指定的命令 {}: 用于引用查找到的文件名称自身 find传递查找到的文件至后面指定的命令时，查找到所有符合条件的文件一次性传递给后面的命令 &hearts; 参数替换xargs 由于很多命令不支持管道|来传递参数，而日常工作中有这个必要，所以就有了xargs命令 xargs用于产生某个命令的参数，xargs 可以读入 stdin 的数据，并且以空格符或回车符将 stdin 的数据分隔成为arguments 注意：文件名或者是其他意义的名词内含有空格符的情况 有些命令不能接受过多参数，命令执行可能会失败，xargs可以解决 示例：&diams; ls f* |xargs rm&diams; find /sbin -perm +700 |ls -l 这个命令是错误的&diams; find /sbin -perm +7000 | xargs ls –l 查找特殊权限的文件 ind和xargs格式：find | xargs COMMAND &hearts; find示例 备份配置文件，添加.orig这个扩展名&diams; find -name “*.conf” -exec cp {} {}.orig \; 提示删除存在时间超过３天以上的joe的临时文件&diams; find /tmp -ctime +3 -user joe -ok rm {} \; 在主目录中寻找可被其它用户写入的文件&diams; find ~ -perm -002 -exec chmod o-w {} \; 查找/data下的权限为644，后缀为sh的普通文件，增加执行权限&diams; find /data –type f -perm 644 -name “*.sh” –exec chmod 755 {} \; 查看/home的目录&diams; find /home –type d -ls 练习 查找/var目录下属主为root，且属组为mail的所有文件 1find /var -user root -group mail -ls 查找/var目录下不属于root、lp、gdm的所有文件 12find /var -not -user root -a -not -user lp -a -not -user gdmfind /var -not \( -user root -o -user lp -o -user gdm \) 查找/var目录下最近一周内其内容修改过，同时属主不为root，也不是postfix的文件 1find /var -mtime -7 -a -not \( -user root -o -user postfix \) | xargs ls 查找当前系统上没有属主或属组，且最近一个周内曾被访问过的文件 1find / -nouser -o -nogroup -type f -atime -7 查找/etc目录下大于1M且类型为普通文件的所有文件 1find /etc -type f -size +1M 查找/etc目录下所有用户都没有写权限的文件 12find /etc -type f -not -perm +222find /etc -type f -not -perm /222 查找/etc目录下至少有一类用户没有执行权限的文件 1find /etc -not -perm -111 -ls 查找/etc/init.d目录下，所有用户都有执行权限，且其它用户有写权限的文件 1find /etc/init.d/ -type f -perm -113 文件压缩及归档常见压缩类型&diams; 分类 compress/uncompress: .Z gzip/gunzip: .gz bzip2/bunzip2: .bz2 xz/unxz: .xz zip/unzip tar cpio compress&hearts; compress compress [-dfvcVr] [-b maxbits] [file …]&diams; -d: 解压缩，相当于uncompress&diams; -c: 结果输出至标准输出,不删除原文件&diams; -v: 显示详情 uncompress 解压缩 zcat file.Z &gt;file gzip/gunzip&hearts; gzip gzip [OPTION]… FILE …&diams; -d: 解压缩，相当于gunzip&diams; -c: 将压缩或解压缩的结果输出至标准输出&diams; -#：1-9，指定压缩比，值越大压缩比越大 zcat：不显式解压缩的前提下查看文本文件内容 bzip2/bunzip2/bzcat&hearts; bzip2 bzip2 [OPTION]… FILE …&diams; -k: keep, 保留原文件&diams; -d：解压缩&diams; -#：1-9，压缩比，默认为9 bzcat：不显式解压缩的前提下查看文本文件内容 xz/unxz/xzcat&hearts; xz xz [OPTION]… FILE …&diams; -k: keep, 保留原文件&diams; -d：解压缩&diams; -#：1-9，压缩比，默认为6 xzcat: 不显式解压缩的前提下查看文本文件内容 zip/unzip&hearts; zip 打包压缩&diams; zip –r /testdir/sysconfig /etc/sysconfig/ 解包解压缩&diams; unzip sysconfig.zip&diams; cat /var/log/messages | zip messages -&diams; unzip -p message &gt; message 总结&hearts; 通用的解压参数 -d tar&hearts; tar tar（Tape ARchive，磁带归档的缩写） tar [OPTION]…&diams; 创建归档&raquo; tar -cpvf /PATH/TO/SOMEFILE.tar FILE…&diams; 追加文件至归档： 注：不支持对压缩文件追加&raquo; tar -r -f /PATH/TO/SOMEFILE.tar FILE…&diams; 查看归档文件中的文件列表&raquo; tar -t -f /PATH/TO/SOMEFILE.tar&diams; 展开归档&raquo; tar -x -f /PATH/TO/SOMEFILE.tar&raquo; tar -x -f /PATH/TO/SOMEFILE.tar -C /PATH/ 结合压缩工具实现：归档并压缩&raquo; -j: bzip2, -z: gzip, -J: xz 123tar -zcvf etc.tar.gz /etctar -jcvf etc.tar.bz2 /etctar -Jcvf etc.tar.xz /etc -exclude 排除文件&diams; tar zcvf /root/a3.tgz –exclude=/app/host1 –exclude=/app/host2 /app 123tar -zcvf etc.tar.gz /etc --exclude=/etc/dockertar -jcvf etc.tar.bz2 /etc --exclude=/etc/dockertar -Jcvf etc.tar.xz /etc --exclude=/etc/docker splist: 分割一个文件为多个文件&diams; split –b Size –d tar-file-name prefix-name&diams; split -b 1M –d mybackup.tgz mybackup-parts&diams; split -b 1M mybackup.tgz mybackup-parts&diams; 合并：&raquo; cat mybackup-parts* &gt; mybackup.tar.gz cpio&hearts; cpio 功能：复制文件从或到归档 cpio命令是通过重定向的方式将文件进行打包备份，还原恢复的工具，它可以解压以“.cpio”或者“.tar”结尾的文件 cpio [选项] &gt; 文件名或者设备名 cpio [选项] &lt; 文件名或者设备名 选项&diams; -o 将文件拷贝打包成文件或者将文件输出到设备上&diams; -O filename 输出到指定的归档文件名&diams; -A 向已存在的归档文件中追加文件&diams; -i 解包，将打包文件解压或将设备上的备份还原到系统&diams; -I filename 对指定的归档文件名解压&diams; -t 预览，查看文件内容或者输出到设备上的文件内容&diams; -F filename 使用指定的文件名替代标准输入或输出&diams; -d 解包生成目录，在cpio还原时，自动的建立目录&diams; -v 显示打包过程中的文件名称 将etc目录备份：&diams; find ./etc -print |cpio -ov &gt;bak.cpio 将/data内容追加bak.cpio&diams; find /data | cpio -oA -F bak.cpio 内容预览&diams; cpio –tv &lt; etc.cpio 解包文件&diams; cpio –idv &lt; etc.cpio 1rpm2cpio /media/Packages/rpm-4.11.3-32.el7.x86_64.rpm | cpio -idv ./bin/rpm]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本编程基础]]></title>
    <url>%2F2018%2F08%2F01%2FShell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[编程基础程序介绍&hearts; 程序组成 程序：算法+数据结构 &diams; 算法：处理数据的方式 &diams; 数据结构：数据在计算机中的类型和组织方式 &raquo; 数据：是程序的核心 &hearts; 程序编程风格： 过程式：以指令为中心，数据服务于指令 对象式：以数据为中心，指令服务于数据 &hearts; 编程逻辑处理方式 顺序执行 循环执行 选择执行 &hearts; shell程序：提供了编程能力，解释执行、过程式编程 程序执行方式&hearts; 计算机：运行二进制指令&hearts; 编程语言：人与计算机之间交互的语言&hearts; 低级编程语言： 机器：二进制的0和1的序列，称为机器指令。与自然语言差异太大，难懂、难写 汇编：用一些助记符号替代机器指令，称为汇编语言&diams; 如：ADD A,B 将寄存器A的数与寄存器B的数相加得到的数放到寄存器A中&diams; 汇编语言写好的程序需要汇编程序转换成机器指令&diams; 汇编语言稍微好理解，即机器指令对应的助记符，助记符更接近自然语言 &hearts; 高级编程语言： 编译：高级语言–&gt;编译器–&gt;机器代码–&gt;执行&diams; C,C++ 解释：高级语言–&gt;执行–&gt;解释器–&gt;机器代码&diams; shell，python，php，JavaScript，perl 示例 shell脚本shell脚本介绍&hearts; shell脚本:包含一些命令或声明，并符合一定格式的文本文件&hearts; 格式要求：首行shebang机制 #!/bin/bash #!/usr/bin/python #!/usr/bin/perl &hearts; shell脚本的用途 自动化常用命令 执行系统管理和故障排除 创建简单的应用程序 处理文本或文件 shell脚本创建&hearts; 脚本规范 第一行一般为调用使用的语言 程序名，避免更改文件名为无法找到正确的文件 版本号 更改后的时间 作者相关信息 该程序的作用，及注意事项 最后是各版本的更新简要说明 &hearts; 示例 第一步：使用文本编辑器来创建文本文件&diams; 第一行必须包括shell声明序列：#!&raquo; #!/bin/bash&diams; 添加注释&raquo; 注释以#开头 第二步：脚本语法检测 &diams; 检测脚本中的语法错误 &raquo; bash -n /path/to/some_script &diams; 调试执行 &raquo; bash -x /path/to/some_script 第三步：运行脚本&diams; 给予执行权限，在命令行上指定脚本的绝对或相对路径&diams; 直接运行解释器，将脚本作为解释器程序的参数运行 示例12345678910111213#!/bin/bash# ------------------------------------------# Filename: hello.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fang# License: GPLecho “hello world” bash变量变量介绍&hearts; 变量：命名的内存空间 数据存储方式：&raquo; 字符：&raquo; 数值：整型，浮点型 &hearts; 变量作用 数据存储格式 参与的运算 表示的数据范围 变量类型&hearts; 强类型：变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。一般定义变量时必须指定类型、参与运算必须符合类型要求；调用未声明变量会产生错误 如：java ， c# ，python 如：print(‘magedu’+ 10) 提示出错，不会自动转换类型 如：print(‘magedu’+str(10)) 结果为magedu10，需要显示转换类型 &hearts; 弱类型：语言的运行时会隐式做数据类型转换。无须指定类型，默认均为字符型；参与运算会自动进行隐式类型转换；变量无须事先定义可直接调用 如：bash 不支持浮点数，php，javascript &hearts; 变量命名法则： 不能使程序中的保留字：例如if, for 只能使用数字、字母及下划线，且不能以数字开头 见名知义 统一命名规则：驼峰命名法 变量种类&hearts; 根据变量的生效范围等标准划分下面变量类型： 局部变量&hearts; 生效范围为当前shell进程；对当前shell之外的其它shell进程，包括当前shell的子shell进程均无效 变量赋值：name=‘value’ 可以使用引用value:&diams; 可以是直接字串; name=“root”&diams; 变量引用：name=”$USER”&diams; 命令引用：name=COMMAND name=$(COMMAND) 变量引用：${name} $name&diams; “”：弱引用，其中的变量引用会被替换为变量值&diams; ‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串 显示已定义的所有变量：set 删除变量：unset name 环境变量&hearts; 环境（全局）变量：生效范围为当前shell进程及其子进程 变量声明、赋值：&diams; export name=VALUE&diams; declare -x name=VALUE 变量引用：$name, ${name} 显示所有环境变量：&diams; env&diams; printenv&diams; export&diams; declare -x 删除变量：&diams; unset name bash内建的环境变量：&diams; PATH&diams; SHELL&diams; USER&diams; UID&diams; HOME&diams; PWD&diams; SHLVL&diams; LANG&diams; MAIL&diams; HOSTNAME&diams; HISTSIZE 位置和只读变量&hearts; 只读变量：只能声明，但不能修改和删除 声明只读变量：&diams; readonly name&diams; declare -r name 查看只读变量：&diams; readonly –p &hearts; 位置变量：在脚本代码中调用通过命令行传递给脚本的参数 $1, $2, …：对应第1、第2等参数，shift [n]换位置 $0: 命令本身 $*: 传递给脚本的所有参数，全部参数合为一个字符串 $@: 传递给脚本的所有参数，每个参数为独立字符串&diams; $@ $* 只在被双引号包起来的时候才会有差异 $#: 传递给脚本的参数的个数 set – 清空所有位置变量 退出状态&hearts; 进程使用退出状态来报告成功或失败 0 代表成功，1－255代表失败 $? 变量保存最近的命令退出状态 示例 12ping -c1 -w1 192.168.11.2 &amp;&gt;/dev/nullecho $? &hearts; bash自定义退出状态码 exit [n]：自定义退出状态码&diams; 注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字&diams; 注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码 算术运算&hearts; bash中的算术运算:help let +, -, *, /, %取模（取余）, **（乘方） 实现算术运算：&diams; let var=算术表达式&diams; var=$[算术表达式]&diams; var=$((算术表达式))&diams; var=$(expr arg1 arg2 arg3 …)&diams; declare –i var = 数值&diams; echo ‘算术表达式’ | bc 乘法符号有些场景中需要转义，如* bash有内建的随机数生成器：$RANDOM（0-32767)&diams; echo $[$RANDOM%50] ：0-49之间随机数 &hearts; 赋值： 增强型赋值：&diams; +=, -=, *=, /=, %= let varOPERvalue&diams; 例如:let count+=3 自增，自减：&diams; let var+=1&diams; let var++&diams; let var-=1&diams; let var– 逻辑运算&hearts; true, false 1,0 &hearts; 与 1 与 1 = 1 1 与 0 = 0 0 与 1 = 0 0 与 0 = 0 &hearts; 或 1 或 1 = 1 1 或 0 = 1 0 或 1 = 1 0 或 0 = 0 &hearts; 非：！ ! 1 = 0 ! 0 = 1 &hearts; 短路运算 短路与&diams; 第一个为0，结果必定为0&diams; 第一个为1，第二个必须要参与运算 短路或&diams; 第一个为1，结果必定为1&diams; 第一个为0，第二个必须要参与运算 异或：^&diams; 异或的两个值,相同为假，不同为真 判断测试条件判断&hearts; 判断某需求是否满足，需要由测试机制来实现专用的测试表达式需要由测试命令辅助完成测试过程&hearts; 评估布尔声明，以便用在条件性执行中 若真，则返回0 若假，则返回1 &hearts; 测试命令： test EXPRESSION [ EXPRESSION ] [[ EXPRESSION ]]&diams; 注意：EXPRESSION前后必须有空白字符 条件性的执行操作符&hearts; 根据退出状态而定，命令可以有条件地运行 &amp;&amp; 代表条件性的AND THEN || 代表条件性的OR ELSE 示例1ping -c1 -w1 192.168.11.2 &amp;&gt;/dev/null &amp;&amp; echo up || echo down test命令&hearts; 长格式的例子： test “$A” = “$B” &amp;&amp; echo “Strings are equal” test “$A”-eq “$B” &amp;&amp; echo “Integers are equal” &hearts; 简写格式的例子： [ “$A” = “$B” ] &amp;&amp; echo “Strings are equal” [ “$A” -eq “$B” ] &amp;&amp; echo “Integers are equal” bash的数值测试&hearts; 数值测试： -gt 是否大于 -ge 是否大于等于 -eq 是否等于 -ne 是否不等于 -lt 是否小于 -le 是否小于等于 bash的字符串测试&hearts; 字符串测试： = 是否等于 ascii码是否大于ascii码 &lt; 是否小于 != 是否不等于 =~ 左侧字符串是否能够被右侧的PATTERN所匹配&diams; 注意: 此表达式一般用于[[ ]]中；扩展的正则表达式 -z “STRING“ 字符串是否为空，空为真，不空为假 -n “STRING“ 字符串是否不空，不空为真，空为假 注意：用于字符串比较时的用到的操作数都应该使用引号 Bash的文件测试&hearts; 存在性测试 -e FILE: 文件存在性测试，存在为真，否则为假 &hearts; 存在性及类别测试 -b FILE：是否存在且为块设备文件 -c FILE：是否存在且为字符设备文件 -d FILE：是否存在且为目录文件 -f FILE：是否存在且为普通文件 -h FILE 或 -L FILE：存在且为符号链接文件 -p FILE：是否存在且为命名管道文件 -S FILE：是否存在且为套接字文件 Bash的文件权限测试&hearts; 文件权限测试： -r FILE：是否存在且可读 -w FILE: 是否存在且可写 -x FILE: 是否存在且可执行 &hearts; 文件特殊权限测试： -u FILE：是否存在且拥有suid权限 -g FILE：是否存在且拥有sgid权限 -k FILE：是否存在且拥有sticky权限 &hearts; 文件大小测试： -s FILE: 是否存在且非空 &hearts; 文件是否打开： -t fd: fd 文件描述符是否在某终端已经打开 -N FILE：文件自从上一次被读取之后是否被修改过 -O FILE：当前有效用户是否为文件属主 -G FILE：当前有效用户是否为文件属组 &hearts; 双目测试： FILE1 -ef FILE2: FILE1是否是FILE2的硬链接 FILE1 -nt FILE2: FILE1是否新于FILE2（mtime） FILE1 -ot FILE2: FILE1是否旧于FILE2 Bash的组合测试条件&hearts; 第一种方式： COMMAND1 &amp;&amp; COMMAND2 并且 COMMAND1 || COMMAND2 或者 ! COMMAND 非 如：[[ -r FILE ]] &amp;&amp; [[ -w FILE ]] &hearts; 第二种方式： EXPRESSION1 -a EXPRESSION2 并且 EXPRESSION1 -o EXPRESSION2 或者 ! EXPRESSION 必须使用测试命令进行 示例12[ -z $HOSTNAME -o "$HOSTNAME"=="nginx" ] &amp;&amp; echo yes || echo no[ -f /bin/cat -a -x /bin/cat ] &amp;&amp; cat /etc/fstab read命令&hearts; 使用read来把输入值分配给一个或多个shell变量 -p 指定要显示的提示 -s 静默输入，一般用于密码 -n N 指定输入的字符长度N -d ‘字符’ 输入结束符 -t N TIMEOUT为N秒 &hearts; read 从标准输入中读取值，给每个单词分配一个变量所有剩余单词都被分配给最后一个变量 示例&diams; read -t 30 -p “Enter a filename: “ FILE bashbash展开命令行过程&hearts; 过程 把命令行分成单个命令词 展开别名 展开大括号的声明（{}） 展开波浪符声明（~） 命令替换$() 和 ``） 再次把命令行分成命令词 展开文件通配（*、?、[abc]等等） 准备I/0重导向（&lt;、&gt;） 运行命令 &hearts; 防止扩展 反斜线（\）会使随后的字符按原意解释&diams; $ echo Your cost: \$5.00&diams; Your cost: $5.00 加引号来防止扩展&diams; 单引号（’）防止所有扩展&diams; 双引号（”）也防止所有扩展，但是以下情况例外：&raquo; $（美元符号） － 变量扩展&raquo; `（反引号） － 命令替换&raquo; \（反斜线） － 禁止单个字符扩展&raquo; !（叹号） － 历史命令替换 bash的配置文件登陆过程&hearts; 按生效范围划分，存在两类： 全局配置：&diams; /etc/profile&diams; /etc/profile.d/*.sh&diams; /etc/bashrc 个人配置：&diams; ~/.bash_profile&diams; ~/.bashrc &hearts; 交互式登录： 直接通过终端输入账号密码登录 使用“su - UserName” 切换的用户 执行顺序：/etc/profile –&gt; /etc/profile.d/*.sh –&gt; ~/.bash_profile –&gt; ~/.bashrc –&gt; /etc/bashrc &hearts; 非交互式登录： su UserName 图形界面下打开的终端 执行脚本 执行顺序： ~/.bashrc –&gt; /etc/bashrc –&gt; /etc/profile.d/*.sh Profile类&hearts; 按功能划分，存在两类： profile类和bashrc类 &hearts; profile类：为交互式登录的shell提供配置 全局：/etc/profile, /etc/profile.d/*.sh 个人：~/.bash_profile 功用：&diams; 用于定义环境变量&diams; 运行命令或脚本 Bashrc类&hearts; bashrc类：为非交互式和交互式登录的shell提供配置 全局：/etc/bashrc 个人：~/.bashrc 功用：&diams; 定义命令别名和函数&diams; 定义本地变量 生效配置文件&hearts; 修改profile和bashrc文件后需生效 两种方法:&diams; 重新启动shell进程&diams; 或source 例:&diams; . ~/.bashrc &hearts; Bash 退出任务 保存在~/.bash_logout文件中（用户） 在退出登录shell时运行 用于&diams; 创建自动备份&diams; 清除临时文件 练习 编写脚本/root/bin/systeminfo.sh,显示当前主机系统信息，包括主机名，IPv4地址，操作系统版本，内核版本，CPU型号，内存大小，硬盘大小 123456789101112131415161718192021222324252627#!/bin/bash# ------------------------------------------# Filename: systeminfo.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fangname=$(hostname)ip=$(ifconfig | grep '^eth' -A1 | egrep -o '([[:digit:]]&#123;1,3&#125;.)&#123;4&#125;' | grep -v 255)iso=$(cat /etc/centos-release)kernel=$(uname -r)cpu=$(lscpu | grep 'Model name' | awk '&#123;print $5&#125;')mem=$(free -h | awk '/^Mem/&#123;print $2&#125;')disk=$(lsblk | awk '/^sda/&#123;print $4&#125;')echo "hostname is $name"echo "Ip is $ip"echo "iso is $iso"echo "kernel is $kernel"echo "cpu is $cpu"echo "Mem sum is $mem"echo "disk sum is $disk" 编写脚本/root/bin/backup.sh，可实现每日将/etc/目录备份到/root/etcYYYY-mm-dd中 123456789101112131415161718#!/bin/bash# ------------------------------------------# Filename: backup.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fangdate=$(date +%F%T)dest=/rootsrc=/etccp -ar $src $dest/"etc$date" 编写脚本/root/bin/disk.sh,显示当前硬盘分区中空间利用率最大的值 123456789101112131415#!/bin/bash# ------------------------------------------# Filename: disk.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fangmax=$(df -h | awk '/sd/&#123;print int($5)&#125;' | sort -nr | head -1)echo $max 编写脚本/root/bin/sumid.sh，计算/etc/passwd文件中的第10个用户和第20用户的ID之和 123456789101112131415161718#!/bin/bash# ------------------------------------------# Filename: sumid.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fanguid1=$(cat /etc/passwd | sed -n '10p' | cut -d: -f3)uid2=$(cat /etc/passwd | sed -n '20p' | cut -d: -f3)sum=$(($uid1+$uid2))echo "The sum of 10,20 UID is $sum" 编写脚本/root/bin/sumspace.sh，传递两个文件路径作为参数给脚本，计算这两个文件中所有空白行之和 1234567891011121314151617181920212223#!/bin/bash# ------------------------------------------# Filename: sumspace.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fangread -t 30 -p "Please enter two files: " var1 var2[ -z "$var1" -o ! -f "$var1" ] &amp;&amp; &#123; echo "$var1 Not a valid file" ; exit 2 ; &#125;[ -z "$var2" -o ! -f "$var2" ] &amp;&amp; &#123; echo "$var2 Not a valid file" ; exit 2 ; &#125;space1=$(cat $var1 | grep '^[[:space:]]*$' | wc -l )space2=$(cat $var2 | grep '^[[:space:]]*$' | wc -l )sum=$(($space1+$space2))echo "The sum of two file space is $sum" 编写脚本/root/bin/sumfile.sh,统计/etc, /var, /usr目录中共有多少个一级子目录和文件 1234567891011121314151617181920212223242526272829#!/bin/bash# ------------------------------------------# Filename: sumfile.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fangdiretc=$(ls -d /etc/*/ | wc -l)sumetc=$(ls -d /etc/* | wc -l)fileetc=$(($sumetc-$diretc))dirvar=$(ls -d /var/*/ | wc -l)sumvar=$(ls -d /var/* | wc -l)filevar=$(($sumvar-$dirvar))dirusr=$(ls -d /usr/*/ | wc -l)sumusr=$(ls -d /usr/* | wc -l)fileusr=$(($sumusr-$dirusr))dirsum=$(($diretc+$dirvar+$dirusr))filesum=$(($fileetc+$fileusr+$filevar))echo "The sum of Dir is $dirsum"echo "The sum of file is $filesum" 编写脚本/root/bin/argsnum.sh，接受一个文件路径作为参数；如果参数个数小于1，则提示用户“至少应该给一个参数”，并立即退出；如果参数个数不小于1，则显示第一个参数所指向的文件中的空白行数 12345678910111213141516171819#!/bin/bash# ------------------------------------------# Filename: argsnum.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fang[ $# -lt 1 ] &amp;&amp; &#123; echo "You should enter a valid filename"; exit 2 ; &#125;[ ! -f "$1" ] &amp;&amp; &#123; echo "Not a file" ; exit 2 ; &#125;space=$(cat $1 | grep '^[[:space:]]*$' | wc -l )echo "The file $1 space sum is $space" 编写脚本/root/bin/hostping.sh，接受一个主机的IPv4地址做为参数，测试是否可连通。如果能ping通，则提示用户“该IP地址可访问”；如果不可ping通，则提示用户“该IP地址不可访问” 12345678910111213141516171819#!/bin/bash# ------------------------------------------# Filename: hostping.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fangread -t 30 -p "Please input a IP: such as 192.168.1.1 : " var[ -z $var ] &amp;&amp; &#123; echo "empty" ; exit 2 ; &#125;ping -c 1 -w 1 $var &amp;&gt;/dev/null[ $? -eq 0 ]&amp;&amp; echo "The ip is ok" || echo "The ip is down" 编写脚本/root/bin/checkdisk.sh，检查磁盘分区空间和inode使用率，如果超过80%，就发广播警告空间将满 12345678910111213141516#!/bin/bash# ------------------------------------------# Filename: checkdisk.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fangdisk=$(df -h | grep -w '/' | egrep -o [0-9]+% | cut -d% -f1)inode=$(df -i | grep -w '/' | egrep -o [0-9]+% | cut -d% -f1)[ "$disk" -gt 80 -o "$inode" -gt 80 ] &amp;&amp; "wall The / will funning !!!!" 编写脚本/bin/per.sh,判断当前用户对指定参数文件，是否不可读并且不可写 12345678910111213141516#!/bin/bash# ------------------------------------------# Filename: per.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fangread -t 30 -p "Please input a file: " var[ -z "$var" ]&amp;&amp; &#123; echo "You input is empty" ; exit 2 ; &#125;[ ! -r "$var" -a ! -w "$var" ] &amp;&amp; echo "yes " || echo "no" 编写脚本/root/bin/excute.sh ，判断参数文件是否为sh后缀的普通文件，如果是，添加所有人可执行权限，否则提示用户非脚本文件 123456789101112131415161718192021222324#!/bin/bash# ------------------------------------------# Filename: excute.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fang[ $# -ne 1 ] &amp;&amp; &#123; echo "Please input a file"; exit 2; &#125;if [ -h "$1" -o ! -f "$1" ]then echo "Please you input not a common file" exit 2elif [[ "$1" =~ .*\.sh$ ]]then chmod a+x $1else echo "Not bash file"fi 编写脚本/root/bin/nologin.sh和login.sh,实现禁止和充许普通用户登录系统 1234567891011121314151617#!/bin/bash# ------------------------------------------# Filename: nologin.sh# Revision: 1.1# Date: 2018/08/01# Author: fang# Email: fang@gmail.com# Website: www.xfanyi.top# Description: This is the first script# ------------------------------------------# Copyright: 2018 fang#思路 /etc目录存在 nologin 文件普通用户不能登陆，反之亦然touch /etc/nologin#允许普通用户登陆rm -rf /etc/nologin 让所有用户的PATH环境变量的值多出一个路径，例如：/usr/local/apache/bin 1234cat &gt;&gt; /etc/profile.d/apache.sh &lt;&lt;EFOexport PATH=/usr/local/apache/bin:$PATHEFOsource /etc/profile.d/apache.sh]]></content>
      <categories>
        <category>linuxshell</category>
      </categories>
      <tags>
        <tag>linuxshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本处理工具 grep]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-grep%2F</url>
    <content type="text"><![CDATA[文本处理工具文件查看命令：&hearts; cat，tac，rev cat [OPTION]… [FILE]…&diams; -E: 显示行结束符$&diams; -n: 对显示出的每一行进行编号&diams; -A：显示所有控制符&diams; -b：非空行编号&diams; -s：压缩连续的空行成一行 tac 倒过来显示，cat命令的结果以x轴为中心旋转180度。 rev 输出结果以Y轴为中心，旋转180度。 分页查看文件内容&hearts; 分页查看文件 more [OPTIONS…] FILE…&diams; -d: 显示翻页及退出提示，不能往上翻页 less：一页一页地查看文件或STDIN输出&diams; 查看时有用的命令包括：&diams; less 命令是man命令使用的分页器 显示文本前或后行内容&hearts; head [OPTION]… [FILE]… -c #: 指定获取前#字节 (取随机数常用) -n #: 指定获取前#行 &hearts; tail [OPTION]… [FILE]… -c #: 指定获取后#字节 -n #: 指定获取后#行 -f: 跟踪显示文件fd新追加的内容,常用日志监控 (常用)&diams; 相当于 –follow=descriptor -F: 跟踪文件名，相当于—follow=name –retry &hearts; tailf 类似tail –f，当文件不增长时并不访问文件 按列抽取文本cut&hearts; cut [OPTION]… [FILE]… -d DELIMITER: 指明分隔符，默认tab&diams; cut -d: -f1 /etc/passwd&diams; cat /etc/passwd | cut -d: -f7 -f FILEDS:&diams; #: 第#个字段&diams; #,#[,#]：离散的多个字段，例如1,3,6&diams; #-#：连续的多个字段, 例如1-6&diams; 混合使用：1-3,7&diams; -c 按字符切割&diams; –output-delimiter=STRING指定输出分隔符 paste合并两个文件同行号的列到一行&hearts; paste [OPTION]… [FILE] -d 分隔符:指定分隔符，默认用TAB -s : 所有行合成一行显示 paste f1 f2 paste -s f1 f2 分析文本的工具&hearts; 文本数据统计：wc 计数单词总数、行总数、字节总数和字符总数 以对文件或STDIN中的数据运行&diams; wc story.txt 39 237 1901 story.txt 行数 字数 字节数 常用选项&diams; -l 只计数行数&diams; -w 只计数单词总数&diams; -c 只计数字节总数&diams; -m 只计数字符总数&diams; -L 显示文件中最长行的长度 文本排序sort、uniq&hearts; 把整理过的文本显示在STDOUT，不改变原始文件 sort [options] file(s) 常用选项&diams; -r 执行反方向（由上至下）整理&diams; -R 随机排序&diams; -n 执行按数字大小整理&diams; -f 选项忽略（fold）字符串中的字符大小写&diams; -u 选项（独特，unique）删除输出中的重复行&diams; -t c 选项使用c做为字段界定符&diams; -k X 选项按照使用c字符分隔的X列来整理能够使用多次1cat /etc/passwd | sort -n -t: -k3 &hearts; uniq命令：从输入中删除前后相接的重复的行 uniq [OPTION]… [FILE]…&diams; -c: 显示每行重复出现的次数&diams; -d: 仅显示重复过的行&diams; -u: 仅显示不曾重复的行&diams; 注：连续且完全相同方为重复 常和sort 命令一起配合使用：&diams; sort userlist.txt | uniq -c 练习 找出ifconfig “网卡名” 命令结果中本机的IPv4地址 1ifconfig | head -n2 | tail -1 | tr -s " " | cut -d" " -f3 查出分区空间使用率的最大百分比值 1df -h | tr -s " " | cut -d " " -f5 | cut -d% -f1 | sort -nr 查出用户UID最大值的用户名、UID及shell类型 1cat /etc/passwd | sort -nr -t: -k3 | cut -d: -f1,3,7 查出/tmp的权限，以数字方式显示 1stat /tmp/ | head -n4 | tail -n1 | tr '/' '(' | cut -d"(" -f2 grep及正则表达式grep：文本过滤工具&hearts; grep: Global search REgular expression and Print out the line 作用：文本搜索工具，根据用户指定的“模式”对目标文本逐行进行匹配检查；打印匹配到的行 模式：由正则表达式字符及文本字符所编写的过滤条件 grep [OPTIONS] PATTERN [FILE…]&diams; –color=auto: 对匹配到的文本着色显示&diams; -v: 显示不被pattern匹配到的行&diams; -i: 忽略字符大小写&diams; -n：显示匹配的行号&diams; -c: 统计匹配的行数&diams; -o: 仅显示匹配到的字符串&diams; -q: 静默模式，不输出任何信息&diams; -A #: after, 后#行&diams; -B #: before, 前#行&diams; -C #：context, 前后各#行&diams; -e：实现多个选项间的逻辑or关系&diams; -w：匹配整个单词&diams; -E：使用ERE&diams; -F：相当于fgrep，不支持正则表达式 示例&diams; grep root /etc/passwd&diams; grep “$USER” /etc/passwd&diams; grep ‘$USER’ /etc/passwd&diams; grep whoami /etc/passwd 正则表达式&hearts; 正则表达示介绍 REGEXP：由一类特殊字符及文本字符所编写的模式，其中有些字符（元字符）不表示字符字面意义，而表示控制或通配的功能 程序支持：grep,sed,awk,vim, less,nginx,varnish等 分两类：&diams; 基本正则表达式：BRE&diams; 扩展正则表达式：ERE 正则表达式引擎：&diams; 采用不同算法，检查处理正则表达式的软件模块&diams; PCRE（Perl Compatible Regular Expressions） 元字符分类：字符匹配、匹配次数、位置锚定、分组 man 7 regex 基本正则表达式元字符&hearts; 基础正则 字符匹配:&diams; . 匹配任意单个字符&diams; [] 匹配指定范围内的任意单个字符&diams; [^] 匹配指定范围外的任意单个字符&diams; [:alnum:] 字母和数字&diams; [:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z&diams; [:lower:] 小写字母 [:upper:] 大写字母&diams; [:blank:] 空白字符（空格和制表符）&diams; [:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广）&diams; [:cntrl:] 不可打印的控制字符（退格、删除、警铃…）&diams; [:digit:] 十进制数字 [:xdigit:]十六进制数字&diams; [:graph:] 可打印的非空白字符&diams; [:print:] 可打印字符&diams; [:punct:] 标点符号 匹配次数：&diams; 匹配前面的字符任意次，包括0次 贪婪模式：尽可能长的匹配&diams; . 任意长度的任意字符&diams; \? 匹配其前面的字符0或1次&diams; + 匹配其前面的字符至少1次&diams; {n} 匹配前面的字符n次&diams; {m,n} 匹配前面的字符至少m次，至多n次&diams; {,n} 匹配前面的字符至多n次&diams; {n,} 匹配前面的字符至少n次 位置锚定&diams; ^ 行首锚定，用于模式的最左侧&diams; $ 行尾锚定，用于模式的最右侧&diams; ^PATTERN$ 用于模式匹配整行&raquo; ^$ 空行&raquo; ^[[:space:]]*$ 空白行&diams; \&lt; 或 \b 词首锚定，用于单词模式的左侧&diams; > 或 \b 词尾锚定；用于单词模式的右侧&diams; \&lt;PATTERN> 匹配整个单词 分组：() 将一个或多个字符捆绑在一起，当作一个整体进行处理，如：(root)+ 分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \1, \2, \3, … \1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符 示例&diams; (string1+(string2)*)&diams; \1 ：string1+(string2)*&diams; \2 ：string2 后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身 练习 显示/proc/meminfo文件中以大小s开头的行(要求：使用两种方法) 123cat /proc/meminfo | grep -i '^s'cat /proc/meminfo | grep '^[Ss]'cat /proc/meminfo | egrep '^(S|s)' 显示/etc/passwd文件中不以/bin/bash结尾的行 1cat /etc/passwd | grep '/bin/bash$' 显示用户rpc默认的shell程序 1cat /etc/passwd | grep -w '^rpc' | cut -d: -f7 找出/etc/passwd中的两位或三位数 1cat /etc/passwd | grep -w '[0-9]\&#123;2,3\&#125;' 显示CentOS7的/etc/grub2.cfg文件中，至少以一个空白字符开头的且后面有非空白字符的行 1cat /etc/grub2.cfg | grep '^[[:space:]]\+[^[:space:]]' 找出“netstat -tan”命令结果中以LISTEN后跟任意多个空白字符结尾的行 1netstat -nta | grep 'LISTEN[[:space:]]*$' 显示CentOS7上所有系统用户的用户名和UID 1cat /etc/passwd | grep -v '/bin/bash$' | cut -d: -f1,3 添加用户bash、testbash、basher、sh、nologin(其shell为/sbin/nologin),找出/etc/passwd用户名和shell同名的行 1cat /etc/passwd | egrep '^(\&lt;[[:alpha:]]&#123;4,&#125;\&gt;):.*\1$' 利用df和grep，取出磁盘各分区利用率，并从大到小排序 1df -h | grep '/dev/sd' | grep -o '[0-9]\+%' | grep -o '[0-9]\+' | sort -nr egrep及扩展的正则表达式&hearts; 扩展正则 egrep = grep -E egrep [OPTIONS] PATTERN [FILE…] 扩展正则表达式的元字符： 字符匹配：&diams; . 任意单个字符&diams; [] 指定范围的字符&diams; [^] 不在指定范围的字符 次数匹配：&diams; *：匹配前面字符任意次&diams; ?: 0或1次&diams; +：1次或多次&diams; {m}：匹配m次&diams; {m,n}：至少m，至多n次 位置锚定：&diams; ^ :行首&diams; $ :行尾&diams; \&lt;, \b :语首&diams; >, \b :语尾 分组：&diams; ()&diams; 后向引用：\1, \2, … 或者&diams; a|b: a或b&diams; C|cat: C或cat&diams; (C|c)at:Cat或cat 扩展练习 显示三个用户root、fang、sshdUID和默认shell 1cat /etc/passwd | egrep -w '^(root|fang|sshd)' | cut -d: -f3,7 找出/etc/rc.d/init.d/functions文件中行首为某单词(包括下划线)后面跟一个小括号的行 1cat /etc/rc.d/init.d/functions | egrep -w -o '[[:alnum:]]+\(\)' 使用egrep取出/etc/rc.d/init.d/functions/中其基名和目录名 12echo /etc/rc.d/init.d/functions/ | egrep -o '[^/]+/?$' | egrep -o '[[:alnum:]]+'echo /etc/rc.d/init.d/functions/ | egrep -o '.*/' | cut -d"/" -f1-4 统计last命令中以root登录的每个主机IP地址登录次数 1last | grep -w '^root' | egrep -o '([0-9]&#123;1,3&#125;.)&#123;4&#125;' | sort | uniq -c | sort -nr 利用扩展正则表达式分别表示0-9、10-99、100-199、200-249、250-255 123450-9 seq 0 300 | grep -o -w '[0-9]'10-99 seq 0 300 | egrep -o -w '[0-9]&#123;2&#125;'100-199 seq 0 300 | egrep -o -w '1[0-9]&#123;2&#125;'200-249 seq 0 300 | egrep -o -w '2[0-4][0-9]'250-255 seq 0 300 | egrep -o -w '25[0-5]' 显示ifconfig命令结果中所有IPv4地址 1ifconfig | grep '^eth' -A1 | grep 'inet' | egrep -o '([0-9]&#123;1,3&#125;.)&#123;4&#125;' | grep -v 255 将此字符串：welcome to my blog 中的每个字符去重并排序，重复次数多的排到前面 1echo "welcome to my blog" | grep -o '[[:alnum:]]' | sort | uniq -c | sort -nr]]></content>
      <categories>
        <category>linuxshell</category>
      </categories>
      <tags>
        <tag>linuxshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户组和权限管理]]></title>
    <url>%2F2018%2F07%2F22%2F%E7%94%A8%E6%88%B7%E7%BB%84%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[用户组和权限管理用户相关内容介绍&hearts; 资源分派： Authentication：认证 Authorization：授权 Accouting|Audition：审计 &hearts; 用户user 令牌token,identity Linux用户：Username/UID 管理员：root, 0 用户类型&diams; 系统用户：1-499, 1-999 （CentOS7）&raquo; 对守护进程获取资源进行权限分配&diams; 登录用户：500+, 1000+（CentOS7）&raquo; 交互式登录 &hearts; 组group Linux组：Groupname/GID 管理员组：root, 0 组分类：&diams; 系统组：1-499, 1-999（CENTOS7）&diams; 普通组：500+, 1000+（CENTOS7） Linux组的类别&diams; 用户的主要组(primary group)&raquo; 用户必须属于一个且只有一个主组&raquo; 组名同用户名，且仅包含一个用户，私有组&diams; 用户的附加组(supplementary group)&raquo; 一个用户可以属于零个或多个辅助组 用户、组相关配置文件用户配置相关文件&hearts; /etc/passwd：用户及其属性信息(名称、UID、主组ID等） 12cat /etc/passwd | head -1root:x:0:0:root:/root:/bin/bash login name：登录用名（root） passwd：密码 (x) UID：用户身份编号 (0)&diams; root不一定为管理员，但UID为0的一定是管理员 GID：登录默认所在组编号 (0) GECOS：用户全名或注释 home directory：用户主目录 (/root) shell：用户默认使用shell (/bin/bash) &hearts; /etc/shadow：用户密码及其相关属性12cat /etc/shadow | head -n1root:$6$gyjqlS03YxzP24zx$SxxpFy5f1hveOnmOexnNUjo8x5UTQa4LedfsmLNGjoIhqaaxfBLKAHsWKC64IbtzpXRLZA5gpy8kq4hVHAo7G.:17730:0:99999:7::: 登录用名 用户密码:一般用sha512加密 从1970年1月1日起到密码最近一次被更改的时间 密码再过几天可以被变更（0表示随时可被变更） 密码再过几天必须被变更（99999表示永不过期） 密码过期前几天系统提醒用户（默认为一周） 密码过期几天后帐号会被锁定 从1970年1月1日算起，多少天后帐号失效 保留 组相关配置文件&hearts; /etc/group：组及其属性信息12cat /etc/grouproot:x:0: 群组名称：就是群组名称 群组密码：通常不需要设定，密码是被记录在 /etc/gshadow GID：就是群组的 ID 以当前组为附加组的用户列表(分隔符为逗号) &hearts; /etc/gshadow：组密码及其相关属性12cat /etc/gshadowroot::: 群组名称：就是群组名称 群组密码： 组管理员列表：组管理员的列表，更改组密码和成员 以当前组为附加组的用户列表：(分隔符为逗号) 加密介绍&hearts; 加密机制： 加密：明文–&gt; 密文 解密：密文–&gt; 明文 &hearts; 单向加密：哈希算法 原文不同，密文必不同 相同算法定长输出，获得密文不可逆推出原始数据 雪崩效应：初始条件的微小改变，引起结果的巨大改变 加密算法&diams; md5: message digest, 128bits&diams; sha1: secure hash algorithm, 160bits&diams; sha224: 224bits&diams; sha256: 256bits&diams; sha384: 384bits&diams; sha512: 512bits &hearts; 更改加密算法： authconfig –passalgo=sha256 –update &hearts; 密码设置 密码的复杂性策略&diams; 使用数字、大写字母、小写字母及特殊字符中至少3种 足够长 使用随机密码 定期更换,不要使用最近曾经使用过的密码 用户和组管理命令用户管理命令useradd&hearts; 用户创建：useradd useradd [options] LOGIN&diams; -u UID&diams; -o 配合-u 选项，不检查UID的唯一性&diams; -g GID：指明用户所属基本组，可为组名，也可以GID&diams; -c “COMMENT”：用户的注释信息&diams; -d HOME_DIR: 以指定的路径(不存在)为家目录&diams; -s SHELL: 指明用户的默认shell程序，可用列表在/etc/shells文件中&diams; -G GROUP1[,GROUP2,…]：为用户指明附加组，组须事先存在&diams; -N 不创建私用组做主组，使用users组做主组&diams; -r: 创建系统用户 CentOS 6: ID&lt;500，CentOS 7: ID&lt;1000&diams; -m 创建家目录，用于系统用户&diams; -M 不创建家目录，用于非系统用户 默认值设定：/etc/default/useradd文件中 显示或更改默认设置&diams; useradd -D&diams; useradd –D -s SHELL&diams; useradd –D –b BASE_DIR&diams; useradd –D –g GROUP id&hearts; 查看用户相关信息：id id [OPTION]… [USER]&diams; -u: 显示UID&diams; -g: 显示GID&diams; -G: 显示用户所属的组的ID&diams; -n: 显示名称，需配合ugG使用 passwd&hearts; 设置密码：passwd passwd [OPTIONS] UserName: 修改指定用户的密码 常用选项：&diams; -d：删除指定用户密码&diams; -l：锁定指定用户&diams; -u：解锁指定用户&diams; -e：强制用户下次登录修改密码&diams; -f：强制操作&diams; -n mindays：指定最短使用期限&diams; -x maxdays：最大使用期限&diams; -w warndays：提前多少天开始警告&diams; -i inactivedays：非活动期限&diams; –stdin：从标准输入接收用户密码&raquo; echo “PASSWORD” | passwd –stdin USERNAME (常用) chage [OPTION]… LOGIN&diams; -d LAST_DAY&diams; -E –expiredate EXPIRE_DATE&diams; -I –inactive INACTIVE&diams; -m –mindays MIN_DAYS&diams; -M –maxdays MAX_DAYS&diams; -W –warndays WARN_DAYS&diams; –l 显示密码策略 示例：&diams; chage -d 0 tom 下一次登录强制重设密码&diams; chage -m 0 –M 42 –W 14 –I 7 tom&diams; chage -E 2018-09-10 tom usermod&hearts; 属性修改：usermod usermod [OPTION] login&diams; -u UID: 新UID&diams; -g GID: 新主组&diams; -G GROUP1[,GROUP2,…[,GROUPN]]]：新附加组，原来的附加组将会被覆盖；若保留原有，则要同时使用-a选项&diams; -s SHELL：新的默认SHELL&diams; -c ‘COMMENT’：新的注释信息&diams; -d HOME: 新家目录不会自动创建；若要创建新家目录并移动原家数据，同时使用-m选项&diams; -l login_name: 新的名字；&diams; -L: lock指定用户,在/etc/shadow 密码栏的增加 !&diams; -U: unlock指定用户,将 /etc/shadow 密码栏的 ! 拿掉&diams; -e YYYY-MM-DD: 指明用户账号过期日期&diams; -f INACTIVE: 设定非活动期限 su&hearts; 用户切换：su su [options…] [-] [user [args…]] 切换用户的方式：&diams; su UserName：非登录式切换，即不会读取目标用户的配置文件，不改变当前工作目录&diams; su - UserName：登录式切换，会读取目标用户的配置文件，切换至家目录，完全切换 root su至其他用户无须密码；非root用户切换时需要密码 换个身份执行命令：&diams; su [-] UserName -c ‘COMMAND’ 选项：-l –login&diams; su -l UserName 相当于 su - UserName userdel&hearts; 用户删除：userdel userdel [OPTION]… login&diams; -r: 删除用户家目录 组管理命令groupadd&hearts; 组创建：groupadd groupadd [OPTION]… group_name&diams; -g GID: 指明GID号；[GID_MIN, GID_MAX]&diams; -r: 创建系统组&raquo; CentOS 6: ID&lt;500&raquo; CentOS 7: ID&lt;1000 gpasswd&hearts; 组密码：gpasswd gpasswd [OPTION] GROUP&diams; -a user 将user添加至指定组中&diams; -d user 从指定组中移除用户user&diams; -A user1,user2,… 设置有管理权限的用户列表 newgrp命令：临时切换主组&diams; 如果用户本不属于此组，则需要组密码 groupmod&hearts; 组属性修改：groupmod groupmod [OPTION]… group&diams; -n group_name: 新名字&diams; -g GID: 新的GID groupdel&hearts; 组删除：groupdel groupdel GROUP groupmems&hearts; 组成员修改：groupmems groupmems [options] [action]&diams; options&raquo; -g, –group groupname 更改为指定组 (只有root)&diams; Actions:&raquo; -a, –add username 指定用户加入组&raquo; -d, –delete username 从组中删除用户&raquo; -p, –purge 从组中清除所有成员&raquo; -l, –list 显示组成员列表 groups [OPTION].[USERNAME]… 查看用户所属组列表 练习 创建用户gentoo，附加组为bin和root，默认shell为/bin/csh，注释信息为“Gentoo Distribution” 1useradd -G bin,root -s /bin/csh -c "Gentoo Distribution" gentoo 创建下面的用户、组和组成员关系&diams; 名字为webs 的组&diams; 用户nginx 使用webs 作为附属组&diams; 用户varnish，也使用webs 作为附属组&diams; 用户mysql，不可交互登录系统，且不是webs 的成员，nginx，varnish，mysql密码都是fang 1234567groupadd websusermod -G webs nginxusermod -G webs varnishuseradd -r mysqlecho fang | passwd --stdin nginxecho fang | passwd --stdin varnishecho fang | passwd --stdin mysql 文件权限文件属性及普通权限&hearts; 文件属性 &hearts; 文件属性操作 chown 设置文件的所有者&diams; chown [OPTION]… [OWNER][:[GROUP]] FILE…&diams; 用法&raquo; OWNER&raquo; OWNER:GROUP&raquo; :GROUP&raquo; 命令中的冒号可用.替换&raquo; -R: 递归 chgrp 设置文件的属组信息&diams; chgrp [OPTION]… GROUP FILE…&diams; chgrp [OPTION]… –reference=RFILE FILE…&diams; -R 递归 &hearts; 文件权限对象 任何一个可执行程序文件能不能启动为进程：取决发起者对程序文件是否拥有执行权限 文件的权限主要针对三类对象进行定义&diams; owner: 属主, u&diams; group: 属组, g&diams; other: 其他, o 每个文件针对每类访问者都定义了三种权限&diams; r: Readable&raquo; 文件：可使用文件查看类工具获取其内容&raquo; 目录: 可以使用ls查看此目录中文件列表&diams; w: Writable&raquo; 文件：可修改其内容&raquo; 目录：可在此目录中创建文件，也可删除此目录中的文件&diams; x: eXcutable&raquo; 文件：可以把此文件提请内核启动为一个进程&raquo; 目录：x: 可以使用ls -l查看此目录中文件元数据（须配合r），可以cd进入此目录&raquo; X:只给目录x权限，不给文件x权限 &hearts; 文件权限操作 chmod 文件权限操作命令 chmod [OPTION]… OCTAL-MODE FILE…&diams; -R: 递归修改权限 chmod [OPTION]… MODE[,MODE]… FILE…&diams; 修改一类用户的所有权限：&raquo; u= g= o= ug= a= u=,g=&diams; 修改一类用户某位或某些位权限&raquo; u+ u- g+ g- o+ o- a+ a- + - 示例123456chgrp sales testfilechown root:admins testfilechmod u+wx,g-r,o=rxchmod -R g+rwX /testdirchmod 600 filechown fang testfile &hearts; 文件默认权限 umask值 可以用来保留在创建文件权限 新建FILE权限: 666-umask&diams; 如果所得结果某位存在执行（奇数）权限，则将其权限+1 新建DIR权限: 777-umask 非特权用户umask是 002 root的umask 是 022 umask: 查看 umask #: 设定&diams; umask 002 umask –S 模式方式显示 umask –p 输出可被调用 全局设置： /etc/bashrc 用户设置：~ /.bashrc 练习 当用户docker对/testdir 目录无执行权限时，意味着无法做哪些操作？ 1答：能查看目录的元数据信息，不能进入目录，用ls命令能看到目录下的文件面，但不能查看文件的元数据信息。 当用户mongodb对/testdir 目录无读权限时，意味着无法做哪些操作？ 1答：能查看目录的元数据信息，能进入目录，但查看不了目录里面的内容 当用户redis 对/testdir 目录无写权限时，该目录下的只读文件file1是否可修改和删除？ 1答：可以查看file1的内容，不能修改和删除。 当用户zabbix对/testdir 目录有写和执行权限时，该目录下的只读文件file1是否可修改和删除？ 1答：可以修改和删除file1文件，因没有读权限，所以没法用ls命令查看、也没法补全路径 复制/etc/fstab文件到/var/tmp下，设置文件所有者为tomcat读写权限，所属组为apps组有读写权限，其他人无权限 1cp /etc/fstab /var/tmp/ ; chown tomcat:apps /var/tmp/fstab ; chmod 660 /var/tmp/fstab 误删除了用户git的家目录，请重建并恢复该用户家目录及相应的权限属性 1cp -r /etc/skel/ /home/git ; chmod 700 /home/git ; chown -R git:git /home/git 文件特殊权限&hearts; SUID 作用对像：文件 SUID设置在目录上无意义 启动为进程之后，其进程的属主为原程序文件的属主 SUID只对二进制可执行程序有效 权限设定：&diams; chmod u+s FILE…&diams; chmod u-s FILE… &hearts; SGID 作用对像：文件&diams; 启动为进程之后，其进程的属组为原程序文件的属组&diams; 权限设定：&raquo; chmod g+s FILE…&raquo; chmod g-s FILE… 作用对像：目录&diams; 默认情况下，用户创建文件时，其属组为此用户所属的主组&diams; 一旦某目录被设定了SGID，则对此目录有写权限的用户在此目录中创建的文件所属的组为此目录的属组&diams; 通常用于创建一个协作目录&diams; 权限设定：&raquo; chmod g+s DIR…&raquo; chmod g-s DIR… &hearts; Sticky 作用对像：目录&diams; 作用文件，没有意义 具有写权限的目录通常用户可以删除该目录中的任何文件，无论该文件的权限或拥有权 在目录设置Sticky 位，只有文件的所有者或root可以删除该文件 权限设定：&diams; chmod o+t DIR…&diams; chmod o-t DIR… &hearts; chattr chattr +i 不能删除，改名，更改 chattr +a 只能追加内容 lsattr 显示特定属性 访问控制列表 ACL&hearts; ACL介绍 ACL：Access Control List，实现灵活的权限管理 除了文件的所有者，所属组和其它人，可以对更多的用户设置权限 CentOS7 默认创建的xfs和ext4文件系统具有ACL功能 CentOS7 之前版本，默认手工创建的ext4文件系统无ACL功能,需手动增加&diams; tune2fs –o acl /dev/sdb1&diams; mount –o acl /dev/sdb1 /mnt/test ACL生效顺序：所有者，自定义用户，自定义组，其他人 ACL文件上的group权限是mask 值（自定义用户，自定义组，拥有组的最大权限）,而非传统的组权限 &hearts; ACL使用 ACL：设置&diams; setfacl -m u:fang:rwx -R file|directory&diams; setfacl -m d:u:fang:rwx -R file|directory ACL：查看&diams; getfacl file |directory ACL：删除&diams; setfacl -k dir 删除默认ACL权限&diams; setfacl –b file1清除所有ACL权限 ACL：备份与恢复&diams; 主要的文件操作命令cp和mv都支持ACL，只是cp命令需要加上-p 参数。但是tar等常见的备份工具是不会保留目录和文件的ACL信息&raquo; getfacl -R /tmp/dir1 &gt; acl.txt&raquo; setfacl -R -b /tmp/dir1&raquo; setfacl -R –set-file=acl.txt /tmp/dir1&raquo; setfacl –restore acl.txt&raquo; getfacl -R /tmp/dir1 练习 在/testdir/dir里创建的新文件自动属于webs组，组apps的成员如：tomcat能对这些新文件有读写权限，组dbs的成员如：mysql只能对新文件有读权限，其它用户（不属于webs,apps,dbs）不能访问这个文件夹 123mkdir /testdir/dir -pv ; chown -R root:webs /testdir/dir; chmod 2750 -R /testdir/dirsetfacl -m g:apps:rwx -R /testdir/dirsetfacl -m g:dbs:rx -R /testdir/dir 备份/testdir/dir里所有文件的ACL权限到/root/acl.txt中，清除/testdir/dir中所有ACL权限，最后还原ACL权限 123456#备份cd /testdir/ ; getfacl -R dir/ &gt; /root/acl.txt#清除setfacl -b dir/#恢复setfacl -R --set-file=/opt/acl.txt dir/]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准I/O和管道]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%A0%87%E5%87%86I-O%E5%92%8C%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[标准I/O和管道标准输入和输出&hearts; 标准输入和输出 Linux给程序提供三种I/O设备&diams; 标准输入（STDIN）－0 默认接受来自键盘的输入&diams; 标准输出（STDOUT）－1 默认输出到终端窗口&diams; 标准错误（STDERR）－2 默认输出到终端窗口 I/O重定向：改变默认位置 标准输出和标准错误可以被重定向到文件&diams; 命令 操作符号 文件名 支持的操作符号包括：&diams; &gt; 把STDOUT重定向到文件&raquo; &gt; 文件内容会被覆盖&raquo; set –C 禁止将内容覆盖已有文件,但可追加&raquo; &gt;| file 强制覆盖&raquo; set +C 允许覆盖&raquo; &gt;&gt; 原有内容基础上，追加内容 &diams; 2&gt; 把STDERR重定向到文件&raquo; 2&gt; 覆盖重定向错误输出数据流&raquo; 2&gt;&gt; 追加重定向错误输出数据流 &diams; 标准输出和错误输出各自定向至不同位置&raquo; COMMAND &gt; /path/to/file.out 2&gt; /path/to/error.out &diams; &amp;&gt; 把所有输出重定向到文件&raquo; &amp;&gt; 覆盖重定向&raquo; &amp;&gt;&gt; 追加重定向&raquo; COMMAND &gt; /path/to/file.out 2&gt;&amp;1 （顺序很重要）&raquo; COMMAND &gt;&gt; /path/to/file.out 2&gt;&amp;1 &diams; ()：合并多个程序的STDOUT&raquo; ( cal 2007 ; cal 2008 ) &gt; all.txt tr命令&hearts; tr tr 转换和删除字符 tr [OPTION]… SET1 [SET2] 常用选项：&diams; -c –C –complement：取字符集的补集&diams; -d –delete：删除所有属于第一字符集的字符&diams; -s –squeeze-repeats：把连续重复的字符以单独一个字符表示&diams; -t –truncate-set1：将第一个字符集对应字符转化为第二字符集对应的字符 从文件中导入STDIN&hearts; 从文件中导入STDIN 使用&lt;来重定向标准输入 某些命令能够接受从文件中导入的STDIN&diams; tr ‘a-z’ ‘A-Z’&lt; /etc/issue&diams; 该命令会把/etc/issue中的小写字符都转换成写写字符&diams; tr –d abc &lt; /etc/fstab 删除fstab文件中的所有abc中任意字符 cat &gt; file 123cat &gt; filehello world#按ctrl+d离开，可以使用文件来代替键盘的输入 &diams; Cat &gt; filea &lt; fileb &hearts; 把多行发送给STDIN 使用“&lt;&lt;终止词”命令从键盘把多行重导向给STDIN&diams; 直到 终止词 位置的所有文本都发送给STDIN&diams; 有时被称为就地文本（heretext） 管道&hearts; 管道（使用符号\“|”表示）用来连接命令 命令1 | 命令2 | 命令3 | …&diams; 将命令1的STDOUT发送给命令2的STDIN，命令2的STDOUT发送到命令3的STDIN&diams; STDERR默认不能通过管道转发，可利用2&gt;&amp;1 或 |&amp; 实现&diams; 最后一个命令会在当前shell进程的子shell进程中执行用来&diams; 组合多种工具的功能&raquo; ls | tr ‘a-z’ ‘A-Z’&raquo; ls -l /etc | less&raquo; echo “test email” | mail -s “test” user@example.com&raquo; echo “test print” | lpr -P printer_name tee&hearts; 重定向到多个目标 命令1 | tee [-a ] 文件名 | 命令2&diams; 把命令1的STDOUT保存在文件中，做为命令2的输入&diams; -a 追加 使用：&diams; 保存不同阶段的输出&diams; 复杂管道的故障排除&diams; 同时查看和记录输出 练习 将/etc/issue文件中的内容转换为大写后保存至/tmp/issue.out文件中 1cat /etc/issue | tr [a-z] [A-Z] &gt;&gt; /tmp/issue.out 将当前系统登录用户的信息转换为大写后保存至/tmp/who.out文件中 1who | tr [a-z] [A-Z] &gt;&gt; /tmp/who.out 一个linux用户给root发邮件，要求邮件标题为”help”，邮件正文如下：Hello, I am 用户名,The system version is here,please help me to check it ,thanks!操作系统版本信息 1234mail -s "help" root &lt;&lt;EFO&gt; Hello ,I am `whoami`,The system version is here,please help me to check it ,thanks!&gt; `cat /etc/centos-release`&gt; EFO 将/root/下文件列表，显示成一行，并文件名之间用空格隔开 1ls /root | tr "\n" " " 计算1+2+3+..+99+100的总和 12echo &#123;1..100&#125; | tr " " "+" | bc seq -s "+" 1 100 | bc 删除Windows文本文件中的‘^M’字符 123yum -y install unix2dosdos2unix fileunix2dos file 处理字符串“xt.,l 1 jr#!$mn 2 c*/fe 3 uz 4”，只保留其中的数字和空格 1echo 'xt.,l 1 jr#clearmn 2 c*/fe 3 uz 4' | tr -dc "[0-9 ]" 将PATH变量每个目录显示在独立的一行 1echo $PATH | tr ":" "\n" 将指定文件中0-9分别替代成a-j 1tr [0-9] [a-j] &lt; file 将文件/etc/centos-release中每个单词（由字母组成）显示在独立一行，并无空行 1cat /etc/centos-release | tr -sc "[:alnum:]." "\n" 下面那一个选项结果不一样 （ B ）A app.sh &gt; f1.log 2&gt;&amp;1B app.sh 2&gt;&amp;1 &gt; f1.logC app.sh 2&gt;f1.log 1&gt;&amp;2D app.sh &amp;&gt;f1.log]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件管理]]></title>
    <url>%2F2018%2F07%2F18%2F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件管理文件系统结构&hearts; 文件系统与目录结构介绍 文件和目录被组织成一个单根倒置树结构 文件系统从根目录下开始，用“/”表示 根文件系统(rootfs)：root filesystem 文件名称区分大小写 以.开头的文件为隐藏文件 路径分隔的 / 文件有两类数据：&diams; 元数据：metadata&diams; 数据：data 文件系统分层结构：LSB Linux Standard Base FHS: (Filesystem Hierarchy Standard)&diams; http://www.pathname.com/fhs/ 文件名最长255个字节 包括路径在内文件名称最长4095个字节 蓝色–&gt;目录 绿色–&gt;可执行文件 红色–&gt;压缩文件 浅蓝色–&gt;链接文件 灰色–&gt;其他文件 除了斜杠和NUL,所有字符都有效.但使用特殊字符的目录名和文件不推荐使用，有些字符需要用引号来引用它们。 标准Linux文件系统（如ext4），文件名称大小写敏感。例如：MAIL, Mail, mail, mAiL &hearts; 各目录介绍 /boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录 /bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的程序 /sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序 /lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules) /lib64：专用于x86_64系统上的辅助共享库文件存放位置 /etc：配置文件目录 /home/USERNAME：普通用户家目录 /root：管理员的家目录 /media：便携式移动设备挂载点 /mnt：临时文件系统挂载点 /dev：设备文件及特殊文件存储位置&diams; b: block device，随机访问&diams; c: character device，线性访问 /opt：第三方应用程序的安装位置 /srv：系统上运行的服务用到的数据 /tmp：临时文件存储位置 /usr: universal shared, read-only data&diams; bin: 保证系统拥有完整功能而提供的应用程序&diams; sbin:&diams; lib：32位使用&diams; lib64：只存在64位系统&diams; include: C程序的头文件(header files)&diams; share：结构化独立的数据，例如doc, man等&diams; local：第三方应用程序的安装位置&raquo; bin, sbin, lib, lib64, etc, share /var: variable data files&diams; cache: 应用程序缓存数据目录&diams; lib: 应用程序状态信息数据&diams; local：专用于为/usr/local下的应用程序存储可变数据；&diams; lock: 锁文件&diams; log: 日志目录及文件&diams; opt: 专用于为/opt下的应用程序存储可变数据；&diams; run: 运行中的进程相关数据,通常用于存储进程pid文件&diams; spool: 应用程序数据池&diams; tmp: 保存系统两次重启之间产生的临时数据 /proc: 用于输出内核与进程信息相关的虚拟文件系统 /sys：用于输出当前系统上硬件设备相关信息虚拟文件系统 /selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置 &hearts; CentOS 7目录变化 /bin 和 /usr/bin /sbin 和 /usr/sbin /lib 和/usr/lib /lib64 和 /usr/lib64 &hearts; 应用程序组成部分 二进制程序：/bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 库文件：/lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64 配置文件：/etc, /etc/DIRECTORY, /usr/local/etc 帮助文档&diams; /usr/share/man, /usr/share/doc, /usr/local/share/man, /usr/local/share/doc Linux下的文件类型及目录&hearts; 文件类型 -：普通文件 d: 目录文件 b: 块设备 c: 字符设备 l: 符号链接文件 p: 管道文件pipe s: 套接字文件socket &hearts; 相关概念 显示当前工作目录&diams; 每个shell和系统进程都有一个当前的工作目录&diams; CWD:current work directory&diams; 显示当前shell CWD的绝对路径 &diams; pwd: printing working directory&raquo; -P 显示真实物理路径&raquo; -L 显示链接路径（默认） 绝对路径&diams; 以正斜杠开始&diams; 完整的文件的位置路径&diams; 可用于任何想指定一个文件名的时候 相对路径名&diams; 不以斜线开始&diams; 指定相对于当前工作目录或某目录的位置&diams; 可以作为一个简短的形式指定一个文件名 基名:basename 目录名:dirname 相关命令cd&hearts; 命令：cd 改变目录 使用绝对或相对路径：&diams; cd /home/fang&diams; cd home/fang 切换至父目录： cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd - 选项：-P 相关的环境变量：&diams; PWD：当前目录路径&diams; OLDPWD：上一次目录路径 ls&hearts; 命令：ls 列出当前目录的内容或指定目录 用法：ls [options] [files_or_dirs] 示例&diams; ls -a 包含隐藏文件&diams; ls -l 显示额外的信息&diams; ls -R 目录递归通过&diams; ls -ld 目录和符号链接信息&diams; ls -1 文件分行显示&diams; ls –S 按从大到小排序&diams; ls –t 按mtime排序&diams; ls –u 配合-t选项，显示并按atime从新到旧排序&diams; ls –U 按目录存放顺序显示&diams; ls –X 按文件后缀排序 stat&hearts; 命令：stat 文件：metadata, data 三个时间戳：&diams; access time：访问时间，atime，读取文件内容&diams; modify time: 修改时间, mtime，改变文件内容（数据）&diams; change time: 改变时间, ctime，元数据发生改变 touch&hearts; 命令：touch touch [OPTION]… FILE…&diams; -a 仅改变 atime和ctime&diams; -m 仅改变 mtime和ctime&diams; -t [[CC]YY]MMDDhhmm[.ss]&diams; -c 如果文件不存在，则不予创建 cp&hearts; 命令：cp cp [OPTION]… [-T] SOURCE DEST cp [OPTION]… SOURCE… DIRECTORY cp [OPTION]… -t DIRECTORY SOURCE… cp常用选项&diams; -i：覆盖前提示 –n:不覆盖，注意两者顺序&diams; -r, -R: 递归复制目录及内部的所有内容&diams; -a: 归档，相当于-dR –preserv=all （保留属性常用）&diams; -d：–no-dereference –preserv=links 不复制原文件，只复制链接名&diams; –preserv[=ATTR_LIST]&raquo; mode: 权限&raquo; ownership: 属主属组&raquo; timestamp:&raquo; links&raquo; xattr&raquo; context&raquo; all&diams; -p: 等同–preserv=mode,ownership,timestamp&diams; -v: –verbose&diams; -f: –force&diams; -u:–update 只复制源比目标更新文件或目标不存在的文件&diams; –backup=numbered 目标存在，覆盖前先备份加数字后缀 cp SRC DEST SRC是文件：&diams; 如果目标不存在：新建DEST，并将SRC中内容填充至DEST中&diams; 如果目标存在：&raquo; 如果DEST是文件：将SRC中的内容覆盖至DEST中&raquo; 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填充至新文件中 cp SRC DEST SRC是目录：&diams; 此时使用选项：-r&diams; 如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；&diams; 如果DEST存在：&raquo; 如果DEST是文件：报错&raquo; 如果DEST是目录:在DEST下新建与原目录同名的目录，并将SRC中内容复制至新目录中&diams; 示图 mv&hearts; 命令：mv mv [OPTION]… [-T] SOURCE DEST mv [OPTION]… SOURCE… DIRECTORY mv [OPTION]… -t DIRECTORY SOURCE… 常用选项&diams; -i: 交互式&diams; -f: 强制 rm&hearts; 命令：rm rm [OPTION]… FILE… 常用选项：&diams; -i 交互式&diams; -f 强制删除&diams; -r 递归&diams; rm -rf 慎用 tree&hearts; 命令：tree -d: 只显示目录 -L level：指定显示的层级数目 -P pattern: 只显示由指定pattern匹配到的路径 mkdir&hearts; 命令：mkdir -p: 存在于不报错，且可自动创建所需的各目录 -v: 显示详细信息 -m MODE: 创建目录时直接指定权限 rmdir&hearts; 命令：rmdir -p: 递归删除父空目录 -v: 显示详细信息 file&hearts; 命令：file 文件可以包含多种类型的数据 检查文件的类型，然后确定适当的打开命令或应用程序使用 file [options] … 常用选项:&diams; -b 列出文件辨识结果时，不显示文件名称&diams; -f filelist 列出文件filelist中文件名的文件类型&diams; -F 使用指定分隔符号替换输出文件名后默认的”:”分隔符&diams; -L 查看对应软链接对应文件的文件类型&diams; –help 显示命令在线帮助 文件通配符&hearts; 通配符 * 匹配零个或多个字符 ? 匹配任何单个字符 ~ 当前用户家目录 ~mage 用户mage家目录 ~+ 当前工作目录 ~- 前一个工作目录 [0-9] 匹配数字范围 [a-z]：字母 [A-Z]：字母 [fang] 匹配列表中的任何的一个字符 [^fang] 匹配列表中的所有字符以外的字符 &hearts; 预定义的字符类 [:digit:]：任意数字，相当于0-9 [:lower:]：任意小写字母 [:upper:]: 任意大写字母 [:alpha:]: 任意大小写字母 [:alnum:]：任意数字或字母 [:blank:]：水平空白字符 [:space:]：水平或垂直空白字符 [:punct:]：标点符号 [:print:]：可打印字符 [:cntrl:]：控制（非打印）字符 [:graph:]：图形字符 [:xdigit:]：十六进制字符 索引节点inode&hearts; inode介绍 inode（index node）表中包含文件系统所有文件列表 一个节点 （索引节点）是在一个表项，包含有关文件的信息（ 元数据 ），包括：&diams; 文件类型，权限，UID，GID&diams; 链接数（指向这个文件名路径名称个数）&diams; 该文件的大小和不同的时间戳&diams; 指向磁盘上文件的数据块指针&diams; 有关文件的其他数据 inode表结构&diams; 示图 目录与inode关系&diams; 文件引用的是 inode号&diams; 人是通过文件名来引用一个文件&diams; 一个目录是目录下的文件名和文件inode号之间的映射&diams; 示图 相关命令与inode索引关系cp和inode&hearts; cp和inode 命令： cp&diams; 分配一个空闲的inode号，在inode表中生成新条目&diams; 在目录中创建一个目录项，将名称与inode编号关联&diams; 拷贝数据生成新的文件 rm和inode&hearts; rm和inode 命令： rm&diams; 链接数递减，从而释放的inode号可以被重用&diams; 把数据块放在空闲列表中&diams; 删除目录项&diams; 数据实际上不会马上被删除，但当另一个文件使用数据块时将被覆盖。 mv和inode&hearts; mv和inode 如果mv命令的目标和源在相同的文件系统，作为mv 命令&diams; 用新的文件名创建对应新的目录项&diams; 删除旧目录条目对应的旧的文件名&diams; 不影响inode表（除时间戳）或磁盘上的数据位置：没有数据被移动！ 如果目标和源在一个不同的文件系统， mv相当于cp和rm 软、硬链接硬链接&hearts; 硬链接 创建硬链接会增加额外的记录项以引用文件 对应于同一文件系统上一个物理文件 每个目录引用相同的inode号 创建时链接数递增 删除文件时：&diams; rm命令递减计数的链接&diams; 文件要存在，至少有一个链接数&diams; 当链接数为零时，该文件被删除 不能跨越驱动器或分区 语法:&diams; ln filename [linkname ] 软（或符号）链接&hearts; 软链接 一个符号链接指向另一个文件 ls - l的 显示链接的名称和引用的文件 一个符号链接的内容是它引用文件的名称 可以对目录进行 可以跨分区 指向的是另一个文件的路径；其大小为指向的路径字符串的长度；不增加或减目标文件inode的引用计数； 语法：&diams; ln -s filename ​​[linkname] 创建软链接&diams; ln -snf newfilename [linkname] 更改软链接 练习 显示/var目录下所有以l开头，以一个小写字母结尾，且中间出现至少一位数字的文件或目录 1ls /var/l*[0-9]*[a-z] 显示/etc目录下以任意一位数字开头，且以非数字结尾的文件或目录 1ls /etc/[0-9]*[^0-9] 显示/etc/目录下以非字母开头，后面跟了一个字母及其它任意长度任意字符的文件或目录 1ls -d /etc/[^:alpha:][:alpha:]* 显示/etc/目录下所有以rc开头，并后面是0-6之间的数字，其它为任意字符的文件或目录 1ls -d /etc/rc[0-6]* 显示/etc目录下，所有以.d结尾的文件或目录 1ls -d /etc/*\.d 显示/etc目录下，所有.conf结尾，且以m,n,r,p开头的文件或目录 1ls -d /etc/[mnrp]*\.conf 只显示/root下的隐藏文件和目录 1ls -d /root/.* 只显示/etc下的非隐藏目录 1ls -d /etc/*/ 定义别名命令baketc，每天将/etc/目录下所有文件，备份到/app独立的子目录下，并要求子目录格式为 backupYYYY-mm-dd，备份过程可见 1alias baketc='cp -rv /etc /app/"backup$(date +"%F%T")"' 创建/app/rootdir目录，并复制/root下所有文件到该目录内，要求保留原有权限 1cp -ar /root /app/rootdir 如何创建/testdir/dir1/x, /testdir/dir1/y, /testdir/dir1/x/a, /testdir/dir1/x/b, /testdir/dir1/y/a, /testdir/dir1/y/b 1mkdir -pv /testdir/dir1/&#123;x,y&#125;/&#123;a,b&#125; 如何创建/testdir/dir2/x, /testdir/dir2/y, /testdir/dir2/x/a,/testdir/dir2/x/b 1mkdir -pv /testdir/dir2/&#123;x/&#123;a,b&#125;,y&#125; 如何创建/testdir/dir3, /testdir/dir4, /testdir/dir5, /testdir/dir5/dir6, /testdir/dir5/dir7 1mkdir -pv /testdir/&#123;dir3,dir4,dir5/&#123;dir6,dir7&#125;&#125;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感恩生活，善待自己]]></title>
    <url>%2F2018%2F07%2F17%2F%E4%B8%BB%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[所有的成功，都来自于不倦的努力和奔跑，所有的幸福，都来自平凡的奋斗和坚持，没有其它的捷径。]]></content>
      <categories>
        <category>essays</category>
      </categories>
      <tags>
        <tag>essays</tag>
      </tags>
  </entry>
</search>
